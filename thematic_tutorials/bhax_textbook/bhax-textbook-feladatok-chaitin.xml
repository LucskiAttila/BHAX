<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
                
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban a Lisp nyelvet fogjuk megismerni. A nyelvet John McCarthy alkotta meg 1958-ban.
            Ez nevezhető a második magas szintű programozási nyelvnek, melynél csak a Fortran régebbi. Ez az
            alapján gondolhatnánk azt, hogy nem sok értelme van róla beszélni, tekintve korát, de a 
            mesterséges intelligencia kutatások egyre nagyobb előretörése újra előtérbe hozta. Most
            nem a mestreséges intelligenciával foglalkozunk, és nem is a Lisp nyelvvel önmagában, hanem
            a GIMP képszerkesztő programjának egy különlegességével. Ezt nevezik Script-fu-nak, mely lehetőséget
            ad, hogy a Windows rendszereken megismert makrókhoz hasonló dolgokat alkossunk meg. Ehhez pedig a 
            Lisp nyelvet fogjuk használni. A nyelv szintaktikailag nem bonyolult, viszont van pár dolog, amire oda 
            kell figyelni. Ilyen az, hogy nem infix alakban kell megadni a műveleteket, hanem prefix-ben. A másik 
            fontos dolog, hogy a zárójelek használatára is oda kell figyelni, ugyanis a Lisp teljesen zárójelezett 
            programozási nyelv. Nézzük is, hogy hogyan néz ki a feladat megoldása.  
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Magát a gimpet így tudod letölteni (terminálon keresztül):
                <programlisting>
                    sudo apt-get install gimp
                </programlisting>
            </para>
        </caution>
        <para>
            Maga a faktoriális kiszámítása nyelvtől függetlenül ugyan úgy
            kell megoldani. Persze vannak eltérő megoldások, de az alapja ugyanaz.
            Az <function>n!</function> faktoriális értéke a következő:
            <programlisting>
                n * (n-1) * (n-2) ... * 2 * 1
            </programlisting>
            Az iteratív megoldásnál adná magát, hogy egy <function>for</function>
            vagy egy <function>while</function> ciklust kéne használni. De ez
            Lispben nem egészen így van. Ciklust fogunk használni, ami nagyon 
            hasonlít a <function>while</function> ciklushoz, viszont ezt expliciten
            nem írjuk ki.
            <programlisting><![CDATA[
(define (fakt n)
    (if (= 0 n) 
                (set! n 1)
    )
    (let loop ((variable (- n 1)))
        (if (> variable 1)                               
            (begin
                (set! n (* n variable))
                (loop (- variable 1) )
            )
        )
    )
    n
)]]>
            </programlisting>
            Tehát definiálunk egy függvényt, aminek a neve <function>fakt</function>,
            és egy paramétert kér. Az első <function>if</function>-ben ellenőrizzük, hogy
            a megadott paraméter nulla-e. Ha igen, akkor az <function>n</function> értékét
            1-re állítjuk, mivel ez a 0! értéke.
            A <function>let</function> operátor teszi lehetővé, hogy
            változókat hozzunk létre, és azokkal művelteket hajtsunk végre. Jelen esetben a
            ciklusváltozót hozzuk létre, melynek értéke paraméterül kapott szám és az 1
            különbsége. Aztán megfogalmazunk egy feltételt, ha a változó nagyobb, mint
            1, akkor a paraméter értékét megváltozatatjuk a faktoriális szabályának
            megfelelően. Tehát a <function>set</function> segítségével adhatunk
            új értéket egy véktozónak. Ha ezt megtettük, akkor a csökkentjük a 
            ciklusváltozót 1-el. Végezetül pedig visszadjuk az <function>n</function>
            értékét, amikor a ciklus lefutott.
        </para>
        <para>
            Az iteratív megoldással szemben a rekurzív sokkal rövidebb, viszont 
            átlátni talán egy kicsit nehezebb, hogy mi is történik a háttérben.
            <programlisting><![CDATA[
(define (fakt n)
    (
    if (< n 1) 
         1 
    (* n (fakt (- n 1))) ;else ag
    )
)]]>
            </programlisting>
            A függvény fejrésze teljesen megegyezik az előző példával, de utána
            láthatjuk a rekurzív megoldás erősségét. Nincs szükségünk ciklusokra.
            Ezt azzal érjük el, hogy a függvény önmagát hívja meg, abban az esetben, ha
            a paraméter értéke nagyobb, mint 1. Ellenkező esetben pedig 1-et 
            adunk vissza.
            Matematikai szempontból ez a megoldás
            teljesen helyes és pontos. Viszont fontos látni, hogy programozói szempontból
            a ez tartalmaz egy felesleges függvéynhívást. Hiszen a vezérlés akkor is
            az <function>else</function> ágra ugrik, amikor az <function>n</function> 1, pedig
            tudjuk 1!-nak az értéke 1.
            A programot így módosíthatjuk:
            <programlisting><![CDATA[
(define (fakt n)
    (
    if (< n 2) 
         1 
    (* n (fakt (- n 1))) ;else ag
    )
)]]>  
            </programlisting>
            Ezzel a módosítással elérjük. hogyha az <function>n</function> 1, akkor
            ne ugorjon a vezérlés az <function>else</function> ágra. Hogy jobban lásd, mi is történik a háttérben ennél a
            megoldásnál, vess egy pillantást az alábbi ábrára:
            <figure>
                <title>Rekurzió</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/fakt_seged.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A képen láthatod, hogyan is zajlik az 5!-nak a kiszámolása. Tehát folyamatosan
            az <function>else</function> ágra ugrik a vezérlés, egészen addig, ameddig el
            nem érünk az 1!-ig. Ekkor visszatérünk eggyel, és fokozatosan haladunk vissza
            a hívási láncba, mindig visszaadva a megfelelő értéket, vagyis az éppen
            aktuális n és az (n-1) szorzatát.
        </para>
    </section>

    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://bit.ly/2DFLPe6">itt</link>               
        </para>
        <caution>
            <title>Használat</title>
            <para>
                Ha már telepítetted a faktorálisos feladat alapján a GIMP-et, akkor
                a következőt kell tenned, hogy használhasd a scriptet:
                <programlisting><![CDATA[
cp *.scm /home/<user_name>/snap/gimp/165/.config/GIMP/2.10/scripts/]]>
                </programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az előző feladatban megismert Script-fu alrendszert fogjuk használni ebben a 
            feladatban is. Ahogy a feladatban is látható, egy szövegre kell alkalmazni a 
            króm effektet. Nézzük is meg, hogyan lehet ezt megvalósítani.
            <programlisting>
(define (color-curve)
    (let* (
        (tomb (cons-array 8 'byte))
    )
        (aset tomb 0 0)
        (aset tomb 1 0)
        (aset tomb 2 50)
        (aset tomb 3 190)
        (aset tomb 4 110)
        (aset tomb 5 20)
        (aset tomb 6 200)
        (aset tomb 7 190)
    tomb)    
)
            </programlisting>
            Első lépésként definiálunk egy függvényt, amely létrehoz egy 
            8 elemből álló tömböt, majd az elemket beállítjuk a megfelelő értékekre.
            <programlisting>
(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)   
            </programlisting>
            Az <function>elem</function> függvény segítségével azt oldjuk
            meg, hogy elérjük egy lista x. elemét. Ehhez rekurziót használunk. 
            A <function>car</function> függvény egy lista első elemét adja vissza,
            ezért abban az esetben, ha az <function>x</function> 1, akkor 
            ezt hívjuk meg. A <function>cdr</function> pedig a lista első elemét
            törli. Tehát, ha a második elemet akarjuk megkapni, akkor a program 
            törli a lista első elemét, majd visszadja a korábban még másodiknak
            számító elemet a <function>car</function> függvénnyel.  
            <programlisting>
(define (text-wh text font fontsize)
(let*
    (
        (text-width 1)
        (text-height 1)
    )
 
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    (set! text-height (elem 2  (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    
    (list text-width text-height)
    )
)
            </programlisting>
            A <function>text-wh</function> függvény egy listát ad vissza a 
            paramétereként kapott szöveg szélességéről és magasságáról.
            A <function>let*</function> lehetővé teszi, hogy változókat 
            hozhassunk létre. 
            A szöveg méretének meghatározásához a 
            <function>gimp-text-get-extents-fontname</function> függvényre van szükség,
            amely meghatározza a szöveget bekerítő "doboz" méretét. Egy listát ad vissza,
            melynek első paramétere a szélesség, a második a magasság. Ahhoz, hogy a 
            <function>text-height</function> változó értékét megadjuk az 
            <function>elem</function> függvény segítségével kell kinyernünk a viszzaadott
            list a második elemét. Ez a folyamat a <function>text-width</function>
            esetán könnyű, mivel elég a <function>car</function> függvényt használnunk.
            Most, hogy a szükséges segédfüggvényeket definiáltuk, jöhet a feladat lényegi
            megoldása a Chrome effekt. A <function>script-fu-bhax-chrome</function>
            egy szöveget, egy betűtipust, egy betűméretet, a létrehozandó kép
            méretét, egy színt és egy színátmenetet kér paraméteréül.
            Mint a többi függvénynél, itt is a
            változók definiálásával kezdünk:
            <programlisting>
(define (script-fu-bhax-chrome text font fontsize width height color gradient)
(let*
    (
        (image (car (gimp-image-new width height 0)))
        (layer (car (gimp-layer-new image width height RGB-IMAGE "bg" 100 LAYER-MODE-NORMAL-LEGACY)))
        (textfs)
        (text-width (car (text-wh text font fontsize)))
        (text-height (elem 2 (text-wh text font fontsize)))
        (layer2)        
    )
            </programlisting>
            Az <function>image</function> változóban tároljuk el a 
            <function>gimp-image-new</function> függvéyn által létrehozott
            képet, pontosabban annak az azonosítóját. A kép a felhasználó
            által megadott értékeknek megfelelő méretű lesz. A harmadik paraméter
            pedig azt jelöli, hogy RGB képet hoztunk létre. A <function>layer</function>
            változó fogja tartalmazni az újonan létrehozott réteg azonosítóját. A réteget
            a <function>gimp-layer-new</function> függvénnyel alkotjuk meg. Paramétereként
            meg kell adni azt a képet, amihez hozzá szeretnénk adni a réteget, a réteg 
            méretét, azt, hogy milyen színkezelést használjon. A réteget el is kell 
            nevezni, meg kell határozni a kép átlátszóságát és a kombinációs módját.
            Tehát jelen esetben egy a képpel megyegyező méretű réteget hozunk létre, ami
            RGB színeket használ, a neve bg és teljesen átlátszó. A <function>text-width</function>
            és <function>text-height</function> változók értékét a <function>text-wh</function>
            függvény segítségével adjuk meg. Mivel ez a függvény egy listát ad vissza, ezért
            ismét alkalmaznunk kell az <function>elem</function> függvényt, ahhoz, hogy a
            szöveg magasságát meghatározzuk. A változókat definiáltuk, most jöhetnek
            az érdemi módosítások.
            <programlisting>
    (gimp-image-insert-layer image layer 0 0)
    (gimp-context-set-foreground '(0 0 0))
    (gimp-drawable-fill layer  FILL-FOREGROUND )
    (gimp-context-set-foreground '(255 255 255))
   
    (set! textfs (car (gimp-text-layer-new image text font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 0)   
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text-width 2)) (- (/ height 2) (/ text-height 2)))
   
    (set! layer (car(gimp-image-merge-down image textfs CLIP-TO-BOTTOM-LAYER))) 
            </programlisting>
            Elsőnek a <function>layer</function> változóhoz társított réteget
            beszúrjuk a létrehozott képbe. Az utolsó két paraméter azt jelölné, hogy
            van-e szülője a rétegnek, és listában elfoglalt helyét adják meg. Jelen
            esetben nincs szülőréteg, és a lista legtetejére rakjuk. Itt a listát úgy
            kell elképzelni, hogyha van sok réteg, akkor ebben az esetben mindegyik
            fölé kerülne az új réteg. A <function>gimp-context-set-foreground</function>
            beállítja az előtér színét, melyet a réteg színezéséhez használunk. Ezt a 
            <function>gimp-drawable-fill</function> függvénnyel oldjuk meg. Az első paramétere
            azt adja  meg, hogy mit szeretnénk kitölteni, a második pedig azt, hogy előtér-
            vagy háttérszínnel. Ezután pedig az előtér színét megváltozatjuk fehérre. Ezzel a 
            színnel fog kiíródni a szöveg addig, ameddig nem alkalmazzuk rá a Chrome effektet.
            A <function>textfs</function> változóban fogjuk tárolni a szöveges réteg azonosítóját.
            Szöveges réteget a <function>gimp-text-layer-new</function> függvény hoz létre. 
            Természetesen meg kell adnunk a szöveget, a stílust, a méretet, és azt is, hogy a méret
            milyen mértékegységben van. Ezt a réteget is ráillesztjük a képre a már 
            ismert módon, vagyis a lista elejére. A <function>gimp-layer-set-offsets</function>
            függvény segítségével be tudjuk állítani a réteg eltolását. Jelen esetben ezt arra
            használjuk, hogy a szöveget a kép közepére mozgassuk. Alapesetben a szöveg a 
            bal felső sarokban lenne, ezért a középre való eltolás a kép szélességének
            és magasságának a fele lenne, viszont akkor a szöveg bal felső sarka lenne 
            középen, emiatt még ki kell vonni a szöveg szélességét és magasságát. Végül
            pedig a szövegréteget lefelé az első aktív réteggel összevonjuk. Erre 
            használjuk a <function>gimp-image-merge-down</function> függvényt. Ezzel
            meg van a kép, amit alapjául szolgál a feladat megoldásához.
            <figure>
                <title>Alap</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Chrome/elso.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure> 
            <programlisting>
    (plug-in-gauss-iir RUN-INTERACTIVE image layer 15 TRUE TRUE)  
            </programlisting>
            A <function>plug-in-gauss-iir</function> függvény segítségével a réteget
            elhomályosítjuk. A haramdik paraméterrel tudjuk meghatározni a homályosítás mértékét.
            Az utolsó két érték pedig azt szabályozza, hogy vízszintesen vagy függőlegesen
            homályosítson, most ezt mind a két irányból alkalmazzuk.
            <figure>
                <title>Blur effect</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Chrome/masodik.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure> 
            <programlisting>
    (gimp-drawable-levels layer HISTOGRAM-VALUE .11 .42 TRUE 1 0 1 TRUE)
            </programlisting>
            Hogy ez a függvény mit csinál az már egy kicsit bonyolultabb. A histogram
            lényegében egy diagram lenne, ami azt mutatja, hogy az egyes színek
            árnyalatai hogyan oszlanak el a képen. Tehát ez a függvény befolyásolja
            a kép hisztogramján előforduló érékeket. A legalacsonabb értéknek az 
            intenzitását kisebbre állítjuk, mint a legmagasabbét. Ezt láthatkjuk a 
            3. és 4. paramétereknél. Az 5. paraméter a clampolást állítja be. 
            A clampolásra azért van szükség, mert a sima képek élei túl 
            recések lehetnek. Ez megoldható, ahogyan mi is csináltuk, homályosítással.
            Ezzel viszont az a baj, hogy a kép tartalam így nehezebben látható. A clampolás
            abban segít, hogy az elhomályosított kép részkleteit visszakapjuk, de az élek
            finomabbak maradjanak. A 6. paraméter a fényerősséget állítja be. A 7. azt 
            jelenti, hogy a kimeneti értékek közül a legalacsonyabbat teljesen kiveszzük
            a képből, mert annak intenzitását 0-ra állítjuk. A legmagasabb értéket pedig
            maximális intezitásra állítjuk. Végezetül pedig engedélyezzük a clampolás
            eredményeként kapott érékek visszaadását.
            <figure>
                <title>Clamp</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Chrome/harmadik.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure> 
            <programlisting>
    (plug-in-gauss-iir RUN-INTERACTIVE image layer 2 TRUE TRUE)  
            </programlisting>
            A clampolás után kapott képen ismét alkalmazunk homályosítást, de 
            azzal előbbinél jóval kisebb mértékben.
            <programlisting>
    (gimp-image-select-color image CHANNEL-OP-REPLACE layer '(0 0 0))
    (gimp-selection-invert image)
            </programlisting>
            A <function>gimp-image-select-color</function> függvény segítségével
            a rétegen minden fekete pixelt kijelölünk. Majd pedig a 
            <function>gimp-selection-invert</function>  inverzévé fordítja az
            előbbi kijelölést, tehát minden pixel, ami nem fekete, ki lesz jelölve.
            <programlisting>
    (set! layer2 (car (gimp-layer-new image width height RGB-IMAGE "2" 100 LAYER-MODE-NORMAL-LEGACY)))
    (gimp-image-insert-layer image layer2 0 0)
            </programlisting>
            A kijelölés után létrehozunk egy új réteget, amelyet kép 
            rétegeinek a legtetejére rakunk. Ezt a réteget a <function>layer2</function>
            változóban tároljuk.
            <programlisting>
    (gimp-context-set-gradient gradient) 
    (gimp-edit-blend layer2 BLEND-CUSTOM LAYER-MODE-NORMAL-LEGACY GRADIENT-LINEAR 100 0 REPEAT-NONE 
        FALSE TRUE 5 .1 TRUE width (/ height 3) width  (- height (/ height 3)))
            </programlisting>
            A hsználni kívánt színátmenetet a <function>gimp-context-set-gradient</function>
            függvény segítségével tudjuk beállítani. Jelen esetben a függvénynek a 
            felhasználó által megadott színátmenetet adjuk paraméterül. Ezzel még nem 
            alkalmaztuk a színátmenetet a szövegre, ahhoz a  
            <function>gimp-edit-blend</function> függvényre van szükség. Ennek nem megyünk végig
            mindegyik paraméterén, de nézzük a fonotosabbakat. Elsőnek meg kell adni, hogy 
            melyik rétegre szeretnénk alkalmazni, utána a színkeverést egyénire állítjuk. A 
            színátmenet típusa lináris lesz, tehát vizszintesen változik a színe a szövegnek.
            Ami fontos még a koordináták, meg kell adni a színezés kezdő és végpontját.
            <figure>
                <title>Színetmenet alkalmazása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Chrome/negyedik.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure> 
            <programlisting>
    (plug-in-bump-map RUN-NONINTERACTIVE image layer2 layer 120 25 7 5 5 0 0 TRUE FALSE 2)
            </programlisting>
            A <function>plug-in-bump-map</function> függvény lehetővé teszi, hogy a 
            szöveget dombornyomat szerűvé tegyük. Ehhez szükség van egy másik rétegre, ami
            kiindulásként szolgál folyamathoz. Lényegében az szolgáltatja a bump map-et.
            <programlisting>
    (gimp-curves-spline layer2 HISTOGRAM-VALUE 8 (color-curve))
            </programlisting>
            Végezetül a második réteg színeinek intenzitását módosítja egy
            görbe alapján. A görbe pontjait pedig a <function>color-curve</function>
            függvény tartalmazza.
            <figure>
                <title>Végeredmény</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Chrome/utolso.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Lehetőségünk van alapértelmezett értékeket megadni a felhasználónak. Erre a szólgál a 
            programkód következő része:
            <programlisting>
(script-fu-register "script-fu-bhax-chrome"
    "Chrome3"
    "Creates a chrome effect on a given text."
    "Norbert Bátfai"
    "Copyright 2019, Norbert Bátfai"
    "January 19, 2019"
    ""
    SF-STRING       "Text"      "Bátf41 Haxor"
    SF-FONT         "Font"      "Sans"
    SF-ADJUSTMENT   "Font size" '(100 1 1000 1 10 0 1)
    SF-VALUE        "Width"     "1000"
    SF-VALUE        "Height"    "1000"
    SF-COLOR        "Color"     '(255 0 0)
    SF-GRADIENT     "Gradient"  "Crown molding"    
)
            </programlisting>
            Nem csak alapértelmezett adatok adhatók meg, hanem a script nevét is 
            itt adhatjuk meg, amit a GIMP mutat majd, a script leírását és a szerzői
            jogokat is ide írjuk. Azt, hogy a GIMP menüjében hol található a script
            azt pedig a következő sorok határozzák meg:
            <programlistin><![CDATA[
(script-fu-menu-register "script-fu-bhax-chrome" 
    "<Image>/File/Create/BHAX"
)]]>
            </programlistin>
            Végezetül pedig lássuk, hogy milyen lett a programunk által elkészített
            Chrome effekt.
            <figure>
                <title>Végeredmény</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Chrome/utolso.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>  
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://bit.ly/2VCaEBY">itt</link>               
        </para>
        <caution>
            <title>Használat</title>
            <para>
                Ha már telepítetted a faktorálisos feladat alapján a GIMP-et, akkor
                a következőt kell tenned, hogy használhasd a scriptet:
                <programlisting><![CDATA[
cp *.scm /home/<user_name>/snap/gimp/165/.config/GIMP/2.10/scripts/]]>
                </programlisting>
                Ha új betústílusokat akarsz hozzáadni a GIMP-hez, akkor pedig ezt:
                <programlisting><![CDATA[
cp *.ttf /home/<user_name>/snap/gimp/165/.config/GIMP/2.10/fonts/]]>
                </programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A mandala lényegében egy alakzat, amit a neved forgatásával, állítasz elő.
            Magát az alakzatot a GIMP-ben bárki meg tudja csinálni, erről egy
            <link xlink:href="https://bit.ly/2GGZaU4">tutoriál</link> található az 
            interneten. A mi programunk is nagyjából ezt valósítja meg, azzal a 
            különbséggel, hogy a folyamatok automatizálva vannak, tehát nem kell
            kézzel előállítani a saját mandaládat.
        </para>            
        <para>
            Az előző feladatokban már megismerkedtünk a Lisp programozási 
            nyelvvel, szóval a szintaktika már nem lesz újdonság, lássuk is a 
            forrást:
            <programlisting><![CDATA[
(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)]]>
            </programlisting>
            Az első függvényünk egy listának az <function>x.</function> elemét
            adja vissza. Ehhez a rekurziót használjuk, tehát ha az első elemét
            keressük a listának, akkor a <function>car</function> függvénysegítségével
            visszaadjuk, de ha nem, akkor lesz szükség további hívásokra. A 
            megoldás lényege, hogy mindig eggyel kisebb <function>x</function>-re
            hívjuk meg az <function>elem</function> függvényt, és a lista első 
            elemét töröljük. Ha egy 5 elemű lstából ki szeretnénk venni az utolsó
            elemet, akkor tehát 4-szer hívja meg önmagát a fóüggvény, majd visszaadja
            a lista első elemét, ami ekkor már az eredeti lista utolsó eleme lesz.
            <programlisting>
(define (text-width text font fontsize)
(let*
    (
        (text-width 1)
    )
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    

    text-width
    )
)
            </programlisting>
            A <function>text-width</function> függvény paraméteréül egy szöveget
            kér, annak a betűstílusát és a méretét. A <function>let*</function>
            függvény segítségével definiálunk egy változót. A <function>set!</function>
            függvény beállítja a <function>text_width</function> változó értékét az
            általunk megadott értékre. Jelen esetben ez a <function>gimp-text-get-extents-fontname</function>
            függvény által visszaadott lista első eleme. Ez a függvény egy szövegdobozt
            hoz létre az általunk megadott szöveggel, és ennek a szövegdoboznak a 
            szélességével, magasságával tér vissza. A visszaadott listában van
            még két elem, de azok a feladat megoldásának sezmpontjából nem fontosak.
            Tehát a függvény visszaadja a szövegünk szélességét.
            <programlisting>
(define (text-wh text font fontsize)
(let*
    (
        (text-width 1)
        (text-height 1)
    )
    ;;;
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;; ved ki a lista 2. elemét
    (set! text-height (elem 2  (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;;    
    
    (list text-width text-height)
    )
)  
            </programlisting>
            Ez a függvény nagyon hasonlít az előzőre, de ebben az a különbség, hogy nem
            csak a szélességet, de a magasságot is vissza kell adnunk. Az eredeti 
            mandalához elég lenne az előző függvény, de a mi programunk a 
            mandala közepére kiír egy másik szöveget is. Ennek a helyes pozícionálásához
            nélkülözhetetlen a <function>text-wh</function> függvény. Mivel a 
            <function>gimp-text-get-extents-fontname</function> által visszaadott
            lista második eleme a magasság, ezért használjuk a már korábban megírt
            <function>elem</function> függvényt, ezzel a <function>text-height</function>
            változó értékét is meg tudjuk határozni. Végezetelül visszadajuk a 
            szövegdoboz szélességéből és magasságából álló listát. 
        </para>
        <para>
            Az eddig tárgyalt függvények csak segédfüggvények voltak, a mandala
            készítő függvény most jön.
            <programlisting>
(define (script-fu-bhax-mandala text text2 font fontsize width height text2_color gradient)
(let*
    (
        (image (car (gimp-image-new width height 0)))
        (layer (car (gimp-layer-new image width height RGB-IMAGE "bg" 100 LAYER-MODE-NORMAL-LEGACY)))
        (textfs)
        (text-layer)
        (text-width (text-width text font fontsize))
        ;;;
        (text2-width (car (text-wh text2 font fontsize)))
        (text2-height (elem 2 (text-wh text2 font fontsize)))
        ;;;
        (textfs-width)
        (textfs-height)
        (gradient-layer)
    ) 
            </programlisting>
            A neve <function>script-fu-bhax-mandala</function>. Alap esetben csak
            egy szöveget kérne paraméteréül, de most kettőt kérünk a 
            felhasználótól. Megadható a betűstílus, a betűméret, a kép mérete, a második
            szöveg színe és
            a kép elkészítéséhez szükséges grádiens.
            A szokásos módon létrehozunk változókat. Az <function>image</function>
            változóban tároljuk a képet, amit a <function>gimp-image-new</function>-val
            létrehozunk. Ennek képnek a mérete az általunk megadott paraméterek. Ezután
            létrehozunk egy új réteget, amelynél megadjuk, hogy melyik képhez
            adja hozzá az új réteget, meagdjuk a réteg méretét, a típusát, ami 
            jelen esetben RGB, tehát a réteg képes lesz kezelni az RGB színeket. Ezeken
            felül megadható a réteg neve, az átlátszósága és a réteg kombináció módja.
            A új réteget a <function>layer</function> változóban tároljuk. Ezen a részen
            érdemes még megemlíteni a <function>text-width</function>, 
            <function>text2-width</function> és <function>text2-height</function>
            változókat. Ezeknek az értékét a már fentebb taglalt függvényekkel
            számoljuk ki. A többi változóról majd a későbbiekben lesz szó.
            <programlisting>
    (gimp-image-insert-layer image layer 0 0)

    (gimp-context-set-foreground '(0 255 0))
    (gimp-drawable-fill layer FILL-FOREGROUND)
    (gimp-image-undo-disable image) 

    (gimp-context-set-foreground text2_color)
            </programlisting>
            A <function>gimp-context-insert-layer</function> függvény azt 
            teszi lehetővé, hogy egy réteget hozzáadjunk egy képhez. Jelen
            esetben az <function>image</function> változóban tárolt
            képhez adjuk hozzá a korábban létrehozott rétegünket. Az utolsó
            2 paraméter a szülő réteg számát és a beillesztés helyét adja meg.
            Tehát a réteg a kép többi rétegével egyenrangú lesz, mivel egyik sem a 
            szülője, és ő kerül legfelülre.
            A <function>gimp-context-set-foreground</function>
            segitségével lehet az előtérszínt módosítani, de ez nem azt jelenti, hogy
            ezzel a paranccsal a kép ilyen színű lesz, csak ezután bármit írnánk, 
            rajzolnánk a képre, az ilyen színű lenne. A <function>gimp-drawable-fill</function>
            segítségével színezzük be a rétegünket az előbb megadott előtérszínnel.
            A <function>gimp-image-undo-disable</function> arra szolgál, hogy ne lehessen
            visszavonni az előző módosításokat az <function>image</function>-en. Végezetül
            újra meghívjuk a <function>gimp-context-set-foreground</function>, ezúttal
            a második szöveg színe lesz ilyen. Ha már elolvastad a belinkelt 
            tutoriált, akkor tudhatod, hogy elsőnek maga az ábra is ilyen lesz, csak
            utána alkalmazunk rá grádienst, ami átszínezi a többit.
            <programlisting>
    (set! textfs (car (gimp-text-layer-new image text font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text-width 2))  (/ height 2))
    (gimp-layer-resize-to-image-size textfs)
            </programlisting>
            A <function>textfs</function> változóban tároljuk el a 
            <function>gimp-text-layer-new</function> által létrehozott
            szöveges rétegünket, amelhez meg kell adni, hogy melyik képre
            szeretnénk ráilleszteni, milyen szöveggel, milyen 
            betűstílussal és betűmérettel. Ezen kívül, még azt is
            meg kell adni, hogy a betűméretet milyen mértékegységben adtuk meg, jelen
            esetben pixelekben. Ezt a réteget beszúrjuk az <function>image</function>-be,
            egészen pontosan az éppen aktív réteg fölé. A <function>gimp-layer-set-offsets</function>
            függvépyn felelős a réteg eltolásának a meghatározásában. Tehát a 
            szöveget űgy toljuk el, hogy az x-tengelyen középen legyen, viszont az y
            tengelyen kicsit lejjebb, mint a középérték. Végezetül pedig a réteget
            a kép ,méretével megegyezővé tesszük a <function>gimp-layer-resize-to-image-size</function>
            függvénnyel. Ezután létrehozunk egy új réteget.
            <programlisting>
    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate-simple text-layer ROTATE-180 TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))
            </programlisting>
            Az új réteget úgy kapjuk, hogy lényegében lemásoljuk az <function>textfs</function>
            réteget. Ehhez a <function>gimp-layer-new-from-drawable</function> függvényre
            van szükség. Majd a réteget uygan úgy beillesztjük a képbe, mint előzőleg, tehát
            az éppen aktív réteg fölé. Majd elforgatjuk 180°-al, ehhez a
            <function>gimp-item-transform-rotate-simple</function> függvényt használjuk. 
            A paraméterekj közül egyértelmű, hogy meg kell adni, hogy mit forgatunk, és hány
            fokban. Viszont az utolsó 3 már érdekesebb, a <function>TRUE</function>
            azt jelenti, hogy a automatikusan a kijelölés közepe körül forgasson, az 
            utolsó kettő pedig a forgatás középpontjának koordinátái. A 
            <function>gimp-image-merge-down</function> függvény a képnek a megadott
            rétegét és az alatta lévő első látható réteget vonja össze. A 
            <function>CLIP-TO-BOTTOM-LAYER</function> paraméter azt adja meg, hogy a 
            az eredményül kapott réteget olyan méretűre kell állítani, mint a legalsó réteg.
            Ugyanezeket a lépéseket végzi el a program még 90°-al, 45°-al és 30°-al.
            Ha kész van a forgatásokkl előállított alakzat, akkor következik annak 
            szépítése.
            <programlisting>
    (plug-in-autocrop-layer RUN-NONINTERACTIVE image textfs)
    (set! textfs-width (+ (car(gimp-drawable-width textfs)) 100))
    (set! textfs-height (+ (car(gimp-drawable-height textfs)) 100))  
            </programlisting>
            A <function>plug-in-autocrop-layer</function> körbevágja az
            aktív réteget, vagyis azt, amelyiken az alakzatunk van. A 
            <function>textfs-width</function> és a <function>textfs-height</function> 
            változóknak átadjuk a <function>textfs</function> réteg 100x100 pixellel
            növelt méretét.
            <programlisting>
    (gimp-layer-resize-to-image-size textfs)
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
    (plug-in-sel2path RUN-NONINTERACTIVE image textfs)
            </programlisting>
            A <function>textfs</function> méretét visszaálltjuk a képpel megegyező méretre,
            majd ellipszis kijelölést alkalmazunk a képen. Ehhez meg kell adnunk
            az ellipszist magába foglaló téglalap bal felső sarkának koordinátáit, és magának 
            a téglalapnak a szélességét és magasságát. Ezt az ellipszis kijelölést a 
            <function>plug-in-sel2path</function> függvény segítségével görbévé alakítjuk.
            <programlisting>
    (gimp-context-set-brush-size 22)
    (gimp-edit-stroke textfs) 
            </programlisting>
            A létrehozott görbe vonalvastagságát a <function>gimp-context-set-brush-size</function>
            függvénnyel állítjuk be. A <function>gimp-edit-stroke</function> pedig a 
            <function>textfs</function> rétegben kijelült területet, vagyis a görbét az 
            előtér színére színezi. Ezekkel az utasításokkal létrehoztuk a külső 
            gyűrűt, ugyanígy hozzuk létre a belsőt is.
            <programlisting>
    (set! textfs-width (- textfs-width 70))
    (set! textfs-height (- textfs-height 70))
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
    (plug-in-sel2path RUN-NONINTERACTIVE image textfs)
        
    (gimp-context-set-brush-size 8)
    (gimp-edit-stroke textfs)
            </programlisting>
            Annyia különbség, hogy csökkentjük a <function>textfs-width</function>
            és a <function>textfs-height</function> változók értékét 70-nel. Egy másik
            különbség, hogy a vonalvastagsága is vékonyabb lesz a belső gyűrűnek.
            Ha nem alkalmaznánk grádienst, aza szín átmenetet, akkor itt véget is
            érhetne a program, a következő eredménnyel:
            <figure>
                <title>Alap mandala</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Mandala/elso.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Ennél még befolyásolhatjuk mandala színét a <function>text2_color</function>
            néven átadott paraméter segítségével, ahogy azt a feladat elején is említettem.
            De ezzel nem elégszünk meg, nézzük, hogyan lehet tovább javítani a kinézetét.
        </para>
        <para>
            Következő lépésként a színátmenetet oldjuk meg, mellyel sokkal látványosabb
            mandalákat lehet készíteni.
            <programlisting>
    (set! gradient-layer (car (gimp-layer-new image width height 
                RGB-IMAGE "gradient" 100 LAYER-MODE-NORMAL-LEGACY)))
            </programlisting>
            Első lépésként létrehozunk egy új réteget, melynek szélesége és
            magassága megyegyezik a kép méretével, ez is RGB színeket használ, és
            teljesen átlátszó.
            <programlisting>
    (gimp-image-insert-layer image gradient-layer 0 -1)
    (gimp-image-select-item image CHANNEL-OP-REPLACE textfs)
    (gimp-context-set-gradient gradient) 
    (gimp-edit-blend gradient-layer BLEND-CUSTOM LAYER-MODE-NORMAL-LEGACY GRADIENT-RADIAL 100 0 REPEAT-NONE FALSE TRUE 5 .1 TRUE 500 500 (+ (+ 500 (/ textfs-width 2)) 8) 500)
            </programlisting>
            A szokásos módon az új réteget, amit a <function>gradient-layer</function>
            változóban tárolunk, a kép utolsó aktív rétege fölé. A
            <function>gimp-image-select-item</function> függvény a megadott réteget
            kijelöléssé alakítja, vagyi annak az alfa csatornáját. A kijelölt területre
            a <function>gimp-edit-blend</function> függvény segítségével tudunk
            színátmenetet beállítani, melynek paraméteréül a felhasználó által megadott 
            grádiens nevét, a színezés módját, a színátmenet típusát és azt a területet, ahol színezni szeretnénk,
            kell megadni. Rengeteg más paramétere van, de ezek a legfontosabbak.
            <programlisting>
                (plug-in-sel2path RUN-NONINTERACTIVE image textfs)
            </programlisting>
            A kijelölést görbévé alakítjuk a szokásos módon.
            <programlisting>
    (set! textfs (car (gimp-text-layer-new image text2 font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text2-width 2)) (- (/ height 2) (/ text2-height 2)))
            </programlisting>
            A második szöveget, amit meg tudunk adni, ezekkel a sorokkal helyezzük al a kép közepére.
            <programlisting>
    (gimp-selection-none image)
    
    (gimp-display-new image)
    (gimp-image-clean-all image)
    )
)
            </programlisting>
            Végezetül pedig megszüntetjük a kijelölést, a képet új ablakban jelenítjük meg a 
            GIMP-ben, ehhez a <function>gimp-display-new</function> függvéynt használjuk.
            A <function>gimp-image-clean-all</function> függvénnyel pedig eltüntetjük a
            képből a szükségtelen információkat.
            Ahhoz, hogy alaértelmezett értékeket állítsunk be a felhasználóknak a 
            következő utsasításokat kell elvégezni:
            <programlisting>
(script-fu-register "script-fu-bhax-mandala"
    "Mandala9"
    "Creates a mandala from a text box."
    "Norbert Bátfai"
    "Copyright 2019, Norbert Bátfai"
    "January 9, 2019"
    ""
    SF-STRING       "Text"      "Bátf41 Haxor"
    SF-STRING       "Text2"     "BHAX"
    SF-FONT         "Font"      "Sans"
    SF-ADJUSTMENT   "Font size" '(100 1 1000 1 10 0 1)
    SF-VALUE        "Width"     "1000"
    SF-VALUE        "Height"    "1000"
    SF-COLOR        "Color"     '(255 0 0)
    SF-GRADIENT     "Gradient"  "Deep Sea"
)
            </programlisting>
            Ebben a részben adhatunk nevet, magyarázó szöveget a scriptünknek. Beállíthatjuk, hogy
            a script megnyitásakor mik legyenek az alap értékek, amiből a felhasználó kiindulhat.
            Azt pedig, hogy honnan legyen elérhető a script a GIMP menüjéből a követkeőképpen
            tudjuk meghatározni:
            <programlisting><![CDATA[
(script-fu-menu-register "script-fu-bhax-mandala" 
    "<Image>/File/Create/BHAX"
)]]>
            </programlisting>
            Végezetül pedig lássuk, hogy milyen képet tudunk készíteni ezzel a scripttel.
            <figure>
                <title>Végső mandala</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Mandala/vege.png" format="PNG" scale="200"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                
