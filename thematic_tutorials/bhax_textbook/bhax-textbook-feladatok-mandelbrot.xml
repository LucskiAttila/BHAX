<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot">itt</link>               
        </para>
        <para>
            Mielőtt a Mandelbrot halmazzal foglalkoznánk, elsőnek tisztázzuk, hogy
            mik is a fraktálok, és mi a kapcsolatuk a MAndelbrot-halmazzal. A
            fraktálok lényegében olyan alakzatok, melyek végtelenül komplexek.
            Két fő tulajdonságuk van, az egyik, hogy a legtöbb geometria alakzattal
            ellentétben a fraktálok szélei "szakadozottak", nem egyenletesek. A 
            másik tulajdonságuk pedig, hogy nagyon hasonlítanak egymásra. Ha egy 
            kör határfelületét folyamatosan nagyítjuk, egy idő után kisimul(a
            csúcsokat leszámítva), megkülönböztethetetlenné válik egy egyenestől.
            Ezzel szemben a fraktálok első tulajdonsága, mi szerint határfelöletük
            szakadozott, megmarad, függetlenül a nagyítás mértékétől.
            A Mandelbrot halmaz is a fraktálok közé tartozik. Ezt és a hozzá 
            tartozó szabályt Benoit Mandelbrot fedezte fel 1979-ben. A halmaz
            komplex számokból áll, melyek az alábbi sorozat elemei:
            <emphasis role="strong">x<subscript>1</subscript>:=c,
            x<subscript>n+1</subscript>:=(x<subscript>n</subscript>)<superscript>2</superscript>
            +c</emphasis>, és ez a sorozat konvergens, azaz korlátos. Ezeket a 
            számokat ábrázolva a komplex számsíkon kapjuk meg a Mandelbrot-halmaz
            híres farktálját.
            <figure>
                <title>Mandelbrot halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/mandelbrot.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
            Ezt az ábrát fogjuk mi megalkotni a C++ programunkkal. Ehhez a png++ header
            fájlra lesz szükségünk, mely nincs alapból telepítve. 
            A <function>sudo apt-get install libpng++-dev</function> paranccsal tudjuk
            feltelepíteni, és a g++ fordító használatánál szükségünk lesz a 
            <function>-lpng</function> kapcsolóra. Most vegyük szépen végig a programot.
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
#include <iostream>
#include <png++/png.hpp>

int main (int argc, char *argv[])
{
    ...
}]]>
            </programlisting>
            Tehát, ahogy már említettem, szükségünk lesz a <function>p++/png.hpp</function>
            header-re. Parancssori algumentum segítségével adjuk meg, hogy melyik
            fájlba szeretnénk elmenteni a képet.
            <programlisting language="c++"><![CDATA[
    if (argc != 2) {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }]]>
            </programlisting>
            Ha nem adjuk meg az argumentumot, akkor dobunk egy hibaüzenetet, amely
            tartalmazza, a helyes használat leírását. Ha megadtuk az argumentumot,
            akkor elkezdődik a lényeg.
            <programlisting language="c++">
    double a = -2.0, b = .7,  c = -1.35, d = 1.35;
    int szelesseg = 600, magassag = 600, iteraciosHatar = 1000;
            </programlisting>
            Első lépésként megadjuk a függvény értékkészletét és
            értelmezésitartományát. Majd meghatározzuk a létrehozandó
            kép méretét, és az iterációs határt.
            <programlisting language="c++"><![CDATA[
                png::image <png::rgb_pixel> kep (szelesseg, magassag);]]>
            </programlisting>
            Ezzel az utasítással létrehozunk egy üres png-t, melybe majd 
            betöltjük a Mandelbrot halmaz ábráját.
            <programlisting language="c++">
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
            </programlisting>
            Megadjuk a lépésközt, amellyel majd végig megyünk a koordináta-rendszer
            rácspontjain. Deklaráljuk a változókat, amikben a c és a z komplex 
            számok valós és imaginárius részét fogjuk tárolni. Ezután pedig 
            végigmegyünk a rácson 2 egymásba ágyazott for ciklus segítségével.
            <programlisting language="c++"><![CDATA[
    for (int j=0; j<magassag; ++j) {
        for (int k=0; k<szelesseg; ++k) {
            reC = a+k*dx;
            imC = d-j*dy;
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            while (reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                
                ++iteracio;
                
            }
            
            kep.set_pixel(k, j, png::rgb_pixel(255-iteracio%256,
                                               255-iteracio%256, 255-iteracio%256));
        }
        std::cout << "." << std::flush;
    }]]>
            </programlisting>
            A valós számokat képesek vagyunk egy számegyenesen ábrázolni, de 
            a komplex számokat már nem, szükségünk van ugyanis egy másik tengelyre
            amelyen a képzetes részeket ábrázoljuk. Így lényegében egy 
            koordináta rendszert kapunk, ahol minden számnak van egy x és
            egy y koordinátája, jelen esetben egy valós és egy képzetes rész.
            Tehát elkezdünk végig lépkedni az értelmezési tartományon, és minden
            iterációban megadjuk a c számot, melyhez kiszámoljuk a z értékeket.
            Ehhez van szükség egy while ciklusra, melyben egészen addig számoljuk
            a halmaz következő elemeit, ameddig a z komplex szám négyzete kisebb, mint
            4 és még nem értük el az iterációs határt. Ha elértük az iterációs határt,
            az iteráció konvergens, tehát a c eleme a Mandelbrot halmaznak.
            <programlisting language = "c++">
                kep.set_pixel(k, j, png::rgb_pixel(255-iteracio%256,
                                               255-iteracio%256, 255-iteracio%256));
            </programlisting> 
            Megadjuk létehozott png képünk egyes pixeleinek a 
            megfelelőt színt, ezzel kirajzolódik a Mandelbrot-halmaz ábrája.
            <programlisting language="c++">
                kep.write (argv[1])
            </programlisting>
            Végezetül pedig a létrehozott képünk tartalmát beleírjük abba fájlba, amit
            a felhasználó megad argumentumként.
            <figure>
                <title>Program fordítás, futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/futtatas.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/abra.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot">itt</link>               
        </para>
        <para>
            Az előző feladatot fogjuk megoldani, csak most egy kicsit másképpen. Ahogy láttad,
            az előbb a komplex számokat két változóban tároltuk, egyikben a valós, ,másikban
            pedig a képzetes részét. De az infromatikusok lusták, mindek használnánk 2
            változót, ha lehet egyet is. Ezt teszi számunkra lehetőve a <function>complex</function>
            library, melynek segítségével a gép képes kezelni ezeket a számokat.
        </para>
        <para>
            Ahogy az előbb, most is végigfutunk a forráson. Az első különbség ott van, hogy
            a felhasználó adhatja meg a létrehozandó kép attribútumait, de ezt ki is hagyhatjuk,
            akkor az alapértelmezett értékeket használja a program.  
            <programlisting language="c++">
  int szelesseg = 1920;
  intmagassag = 1080;
  intiteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
            </programlisting>
            Az <function>atoi</function> és <function>atof</function> segítségével
            tudjuk átalakítani a parancssori argumentum stringet
            <function>int</function> és <function>double</function> típusra.
            Ezután létrehozzuk az üres png-t, mint legutóbb, majd a szükséges 
            változókat.
            <programlisting language = "c++"><![CDATA[
  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;]]>
            </programlisting>
            A két egymásba ágyazott for ciklus segítségével bejárjuk a rácsot,és
            beállítjuk a kép pixeleit a megfelelő értékre, mely most eltér az 
            előzőhöz képest. Itt egy színesebb ábrát fogunk kapni, az 
            előzőhöz képest.
            <programlisting><![CDATA[
 for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam
          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0; 
      //kiírja, hogy hány százaléknél tart a képgenerálás
      std::cout << "\r" << szazalek << "%" << std::flush;
    }]]>
            </programlisting>
        
        Na itt néhány dolog eltér az előző feladathoz képest. Itt használjuk elsőnek
        a complex típust, ami <function>double</function>-ket tartalmaz, és két
        részből áll, a valós és az imaginárius részből. Ennek a segítségével
        definiáljuk a c és a z_n változókat. Majd, innen már ismerős lehet, 
        kiszámoljuk minden c esetén a z_n-eket, és ha elérjük az iterációs határt
        akkor, tudhatjuk, hogy az iteráció konvergens.
        Ebből következik, hogy
        a c eleme a Mandelbrot halmaznak.  A while fejrészében 
        látható <function>abs()</function> függvény az abszolút értékét adja meg
        az bemenetként kapott argumentumának. A halmazt lértehozó sorozat
        képzési szabálya egy az egyben beírható a programba, nincs szükség
        semmilyen szétbontásra, mint az előző programnál volt, köszönhetően
        annak, hogy képesek vagyunk kezelni a komplex számokat. 
        Pusz dolog, hogy a a program a futása 
        azt is látjuk, hogy hány százalékát végezte el a számításoknak a gép. 
        Végezetül pedig itt is kiírjuk a png fájlt a parancssori argumnetumként 
        megadott fájlba a <function>write</function> segítségével.
            <figure>
                <title>Program fordítása és futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/futtatas_c.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/abra_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Tovább folytatjuk a Mandelbrot-os témakört. Ezzel a feladattal nem egészen 
            direkt a kapcsolata a Mandelbrot halmaznak, inkább a Julia halmazokkal
            lesz szoros rokonságban. A Mandelbrot halmaz tartalmazza az összes Julia
            halmazt. Ez abból következik, hogy a Julia halmaz esetén a c konstans, és
            a rácsot a z-vel járjuk be, viszont a Mandelbrot halmazban a c változóként
            szerepel, melyhez kiszámoljuk a z értékeket. Szóval mindig újabb és újabb 
            Julia halmazt számolunk ki vele. 
        </para>
        <para>
            A Biomorfokra Clifford Pickover talált rá, méghozzá egy Julia halmazt rajzoló
            prgramjának írása közben. A programja rejtett egy bugot, és emiatt egészen
            furcsa dolgokat produkált a program, melyre azt hitte, hogy valami természeti
            csodára lelt rá. Magáról a Biomorfokról, és a Pickover történetéről
            részletesebben olvashatsz
            <link xlink:href="https://bit.ly/2HCbCYs">itt</link>.
            Mi is ez alapján készítettük el a biomorf rajzoló programunkat, mely
            a Mandelbrot-os programra alapul, annak egy továbbfejlesztett verziója.
        </para> 
        <para>
            A program eleje teljesen megegyezik a Mandelbrot halmazos programunkkal, azzal
            a kivétellel, hogy most a felhasználótól kérjük be a cc konstans érékét, és a 
            küszöbszámot. Ezek az adatok megtalálhatóak a cikkben, minden biomorfhoz 
            külön-külön.
            <programlisting language = "c++"><![CDATA[
#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }]]>
            </programlisting>
            Ahogy látható a parancssori argumentumok száma 10-re nőtt, melyeket
            nem kötelező megadni, ilyenkor az alapértelmezett értékeket használja.
            Ezt követően létrehozzuk az üres png-t, a lépésközt a rácsok között,
            és most a cc szám deklarációja is a cikluson kívülre kerül, mivel
            az jelen esetben konstans.
            <programlisting language="c++"><![CDATA[
    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );]]>
            </programlisting>
            Egy kisebb átalakításra volt szükség a cilusok tekintetében, melyet 
            ezen algoritmus alapján módosítottunk:
            <programlisting><![CDATA[
1 for x = xmin to xmax by s do
2   for y = ymin to ymax by s do
3       z = x + yi
4       ic = 0
5       for i = 1 to K do
6           z = f(z) + c
7           if |z| > R then
8               ic = i
9               break
10      PrintDotAt(x, y) with color ic
//forrás: https://bit.ly/2HCbCYs]]>
            </programlisting>
            Ennek a C++ implementációja a következő:
            <programlisting><![CDATA[
 for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, z_n) + std::pow(z_n,6) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*60)%255, (iteracio*100)%255, (iteracio*40)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }]]>
            </programlisting>
            A két egymásba ágyazott for ciklus segítségével végigmegyünk a rácspontokon
            és egy harmadik for ciklussal pedig kiszámoljuk a függvéynértékeket,
            egészen addig, amíg el nem érjük az iterációs határt, vagy nem 
            teljesül ez a feltétel:
            <programlisting language="c++"><![CDATA[
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)]]>
            </programlisting>
            Ez volt az a bug, amit Clifford Pickover programja tartalmazott,
            egy sor, ami nélkül ez a feladat lehet, hogy soha nem készült
            volna el.
            Végezetül pedig beállítjuk az egyes pixelek színét, makd kírjuk egy fájlba
            a tartalmát.
            <programlisting language="c++">
                kep.write ( argv[1] );
            </programlisting>
            <figure>
                <title>Program fordítása és futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Biomorf/futtat.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Biomorf</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Biomorf/biomorf.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Sajnos nem sikerült elérni ugyanazt a színt, mint a cikkben, de lényeg
            ezen is látható.
        </para>                       
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/CUDA">itt</link> 
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Tovább folytatjuk a MAndelbrot-halmazos programunk fejlesztését, ezúttal
            az Nvidia CUDA technológiáját hívjuk segítségül, mallyel jelentősen fel tudjuk
            gyorsítani a kép generálását. A tecknika lényege, hogy egy 600x600 darab blokkból
            álló gridet hozunk létre, és mindegy blokkhoz tartozik egy szál. Ezzel
            sikerül a program futását párhuzamosítani.
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A CUDA használatához nvidia GPU-ra van szükség, és telepíteni
                kell a <function>nvidia-cuda-toolkit</function>-et.
            </para>
        </caution>
        <para>
            Lássuk akkor a forrást:
            <programlisting language="c++"><![CDATA[
#define MERET 600
#define ITER_HAT 32000

__device__ int
mandel (int k, int j)
{
    // Végigzongorázza a CUDA a szélesség x magasság rácsot:
    // most eppen a j. sor k. oszlopaban vagyunk

    // számítás adatai
    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

    // a számítás
    float dx = (b - a) / szelesseg;
    float dy = (d - c) / magassag;
    float reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;

    // c = (reC, imC) a rács csomópontjainak
    // megfelelő komplex szám
    reC = a + k * dx;
    imC = d - j * dy;
    // z_0 = 0 = (reZ, imZ)
    reZ = 0.0;
    imZ = 0.0;
    iteracio = 0;
    // z_{n+1} = z_n * z_n + c iterációk
    // számítása, amíg |z_n| < 2 vagy még
    // nem értük el a 255 iterációt, ha
    // viszont elértük, akkor úgy vesszük,
    // hogy a kiinduláci c komplex számra
    // az iteráció konvergens, azaz a c a
    // Mandelbrot halmaz eleme
    while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
    {
        // z_{n+1} = z_n * z_n + c
        ujreZ = reZ * reZ - imZ * imZ + reC;
        ujimZ = 2 * reZ * imZ + imC;
        reZ = ujreZ;
        imZ = ujimZ;

        ++iteracio;

    }
    return iteracio;]]>
}
 
            </programlisting>
            Előre definiáljuk a méret és az iterációs határ értékét. 
            A <function>mandel</function> fügvénnyel hozzuk létre a 
            Mandelbrot halmazt. Ez teljes mértékben megegyezik
            az első Mandelbrot-os feladatunkkal, ahol nem használtuk
            a complex típust. Érdekesség lehet, hogy a függvény
            visszatérési értéke előtt megtalálható a <function>__device__</function>
            kifejezés, mellyel azt jelezzük, hogy CUDA-val fogjuk számolni.
            Amikor az <function>nvcc</function>-vel fordítunk, akkor
            a fordító két részre osztja a programot, egy eszközhöz kapcsolódó részre, amelyet
            az NVIDIA fordító készít el, és egy host részre, mely a gcc-vel fordul.
            Amelyik delkaráció elé odaírjuk a <function>__device__</function> vagy
            a <function>__global__</function> kifejezést, azt az NVIDIA fordító
            fogja gépi kóddá alakítani.
            A régebbi feladatban a számok <function>double</function> típusúak
            voltak, itt áttértünk a <function>float</function> típusra, mivel
            a fordító úgyis erre konvertálta volna őket.
            <programlisting language="c++">
__global__ void
mandelkernel (int *kepadat)
{

    int tj = threadIdx.x;
    int tk = threadIdx.y;

    int j = blockIdx.x * 10 + tj;
    int k = blockIdx.y * 10 + tk;

    kepadat[j + k * MERET] = mandel (j, k);

}
            </programlisting>
            Ahogy említettem a <function>__global__</function> előtag jelzi,
            hogy ezt is a GPU-val fogjuk elvégeztetni. Ebben a részben adjuk át
            a <function>mandel</function> függvénynek az aktuálisan feldolgozás
            alatt álló érték indexét, amelyhez kiszámoljuk az összes lehetséges
            z értéket. A <function>threadIdx.x/y</function> jelöli, hogy melyik
            szálon fut az aktuális x és y számhoz tartozó érték kiszámítása. Ahhoz,
            hogy ezekenek a pontos indexét meg tudjuk adni, tudnunk kell, hogy melyik
            blokkba van éppen benne a szám, és hogy mekkora a blokk mérete, ezek
            segítségével a fent látható módon eltudjuk tárolni a koordinátákat a
            j és k változókban. Egy ábra, hogy könnyebben megértsd, hogyan működik
            ez az indexelés.
            <figure>
                <title>Indexelés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/cuda_seged.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <programlisting language="c++"><![CDATA[
void
cudamandel (int kepadat[MERET][MERET])
{

int *device_kepadat;
cudaMallocManaged ((void **) &device_kepadat, MERET * MERET * sizeof (int));


// dim3 grid (MERET, MERET);
// mandelkernel <<< grid, 1 >>> (device_kepadat);

dim3 grid (MERET / 10, MERET / 10);
dim3 tgrid (10, 10);
mandelkernel <<< grid, tgrid >>> (device_kepadat);  

cudaMemcpy (kepadat, device_kepadat,
        MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
cudaFree (device_kepadat);

}]]>
            </programlisting>
            A <function>cudamandel</function> függvénynek átadunk egy 600x600-as
            tömböt. Létrehozunk egy pointert, és a memóriában foglalunk neki egy
            az átadott tömmbbel megegyező méretű területet, melyre ráállítjuk. Majd
            ezt pointert fogjuk átadni a <function>mandelkernel</function>
            függvénynek. A függvényhívásnál észrevehetsz egy furcsaságot. A 
            <![CDATA[<<<a, b>>>]]> kifejezésben lévő 2 érték közül az <function>a</function>
            jelöli, hogy hány blokkot akarunk létrehozni, a <function>b</function>
            pedig a blokkokhoz tatrtozó szálak számát. A előbbi értéke jelen esetben
            3600, míg az utóbbié 100 lesz. Ha függvény lefutott, akkor átmásoljuk
            az értékeket a argumentumként megadott tömbbe, és felszabadítjuk a 
            lefoglalt területet.
            <programlisting language="c++"><![CDATA[
int
main (int argc, char *argv[])
{

// Mérünk időt (PP 64)
clock_t delta = clock ();
// Mérünk időt (PP 66)
struct tms tmsbuf1, tmsbuf2;
times (&tmsbuf1);

if (argc != 2)
    {
    std::cout << "Hasznalat: ./mandelpngc fajlnev";
    return -1;
    }

int kepadat[MERET][MERET];

cudamandel (kepadat);

png::image < png::rgb_pixel > kep (MERET, MERET);

for (int j = 0; j < MERET; ++j)
    {
    //sor = j;
    for (int k = 0; k < MERET; ++k)
    {
    kep.set_pixel (k, j,
            png::rgb_pixel (255 -
                    (255 * kepadat[j][k]) / ITER_HAT,
                    255 -
                    (255 * kepadat[j][k]) / ITER_HAT,
                    255 -
                    (255 * kepadat[j][k]) / ITER_HAT));
    }
    }
kep.write (argv[1]);

std::cout << argv[1] << " mentve" << std::endl;

times (&tmsbuf2);
std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

delta = clock () - delta;
std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

}]]>
            </programlisting>
            A <function>main</function> függvény nem tartalmaz nagy újdonságokat
            az előző feladatokhoz képest, annyi különbséggel, hogy most
            a futási időt is mérjük, hogy össze tudjuk hasonlítani a CUDA-s 
            verziót a simával. Itt is végigmegyünk az egyes pixleken, és
            beállítjuk a megfelelő színeket, melyhez felhasználjuk a képadatban
            tárolt értékeket.
            <figure>
                <title>Két program hasonlítása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/hason.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Hogy a két programot összetudjuk hasonlítani, a régi C++-os Mandelbrot 
            programunkat alakítottuk ást, hogy az is számolja a futási időt. Ahogy
            a képen is láthatod, a különbség letaglózó. Kevesebb mint az egy tizenhetede
            a CUDA-s implementáció, az eredetinek. Hogy lássuk, nem árulok zsákbamacskát,
            megmutatom az egyik és a másik által készített képeket is.
            <figure>
                <title>CUDA variáns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/mandel.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>C++ megvalósítás, párhuzamosítás nélkül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/mandel_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Összességében elmondhatjuk, hogy a CUDA egy nagyon hasznos
            technológia, mely jelentős gyorsulást érhetünk el, főleg olyan
            programokban, ahol képet kell generálni. De videók renderelésnél
            is nagyon hasznos.
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
            
        <para>
            Megoldás forrása:<link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot/Zoom">itt</link>  
        </para>

        <para>
            Megoldás videó: 
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A feladat megoldásában tutorként részt vett Racs Tamás.
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Használata</title>
            <para>
                Telepíteni: sudo apt-get install libqt4-dev
            </para>
        </caution>
        <caution>
            <title>Megjegyzés</title>
            <para>A feladat megoldásában tutorként részt vett Racs Tamás</para>
        </caution>
        <para>
            A program a QT GUI-t használja, ennek segítségével tudjuk elkészíteni a 
            Mandelbrot halmazt beutazó programunkat. Ez a GUI az egyik legertejedtebb
            garfikus interfésze a C++-nak, rengeteg tutorial van róla fent a neten.  
        </para>
        <para>
                Fordítás:
                Az szükséges 4 fájlnak egy mappában kell lennie. A mappában futtatni
                kell a <function>qmake -project</function> parancsot. Ez létre fog
                hozni egy <function>*.pro</function> fájlt. Ebbe a fájlba be kell
                írni a következőt: <function>QT += widgets</function> sort. Ezután futtatni kell
                a <function>qmake *.pro</function>.
                Ezután lesz a mappában
                egy <function>Makefile</function>, ezt kell majd használni. Ki 
                adjuk a <function>make</function> parancsot, mely létrehoz 
                egy bináris fájlt. Ezt pedig a szokásos módon futtatjuk.
            <figure>
                <title>1. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/elso.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>2. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/szerk.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>3. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/vege.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Rengeteg figyelmeztetést ad vissza, de ezzel most nem kell törődni, hiszan a bináris fájl
            elkészült, melyet futtatunk, és elindul az utazásunk a végtelenbe.
            <figure>
                <title>4. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/futtat.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Alapállapot</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/kep_1.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/kep_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Tovább nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/kep_3.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Ahhoz, hogy részletesebb képet kapj a ránagyított területről, az "n" billentyűt
            kell lenyomnod, mely kiszámolja a z-ket a megadott területen. Itt lehet látni, hogyan
            mosósdik össze a Mandelbrot és a Biomorfos téma. A hatmadik kép, már majdnem olyan, mint
            egy biomorf.
        </para>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot/Zoom_java">itt</link> 
        </para>
        <para>
            <emphasis role = "strong">
                Tanulságok, tapasztalatok, magyarázat...
            </emphasis>
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Telepíteni: sudo apt-get install openjdk-8-jdk 
            </para>
        </caution>
        <para>
            Az előző feladatban készített nagyító Java implementációját
            kell most elkészíteni. A forrás egy kicsit bugos, mivel amikor
            nagyítasz. akkor új ablakban nyílik meg a nagyítás, melynek
            mérete a kijelölt terület függvényében változik. Érdekesség
            ebben a Java programban már includálva van
            másik java program, a <filename>MandelbrotHalmaz.java</filename>.
            Ezt a következő sorral érjük el:
            <programlisting language="java">
                public class MandelbrotHalmazNagyító extends MandelbrotHalmaz
            </programlisting>
            A Javaban nincs a már megszokott <function>#include</function>, helyette az <function>import</function>-ot
            vagy jelen esetben az <function>extends</function>-et használjuk.
            <figure>
                <title>Fordítás, futtatás</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/fordit.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_1.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Tovább nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_3.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Még tovább javítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_4.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Az élesítést itt is az "n" billentyűvel tudod elérni.
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
