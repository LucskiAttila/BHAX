<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
            hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
            példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
            az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
        </para>
        <para>
            <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf(16-22 fólia)</link>
        </para>
        <para>
            Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)                
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Pol%C3%A1rGen">itt</link>
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A korábbi fejezetben már megismertük mind a C++, mind a Java forrást. Most azt fogjuk megnézni, hogy a hivatalos Java
            <function>random</function> szám generátor mennyiben hasonlít a mi megoldásunkra. 
        </para>
        <para>
            Elsőnek nézzük ár újra a Java forrást,
            <programlisting language="java"><![CDATA[
public class PolarGenerator
{
    boolean nincsTarolt = true;
    double tarolt;
    
    public PolarGenerator()
    {
        nincsTarolt = true;
    }
    
    public double kovetkezo() 
    {
        if(nincsTarolt)
        {
            double u1, u2, v1, v2, w;
            do{
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2* u1 -1;
                v2 = 2* u2 -1;
                w = v1*v1 + v2*v2;
            } while (w>1);
            
            double r = Math.sqrt((-2 * Math.log(w) / w));
            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;
            return r * v1;
        }
        else
        {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
}
            ]]></programlisting>
        </para>
        <para>
            Tehát a program annyit csinál, hogy generál 2 random számot. Az egyiket eltárolja, a másikat pedig visszaadja.
            Elsőnek meg kell viszgálni, hogy van-e tárolt elem. Ehhez szükségünk van a <function>nincsTarolt</function>
            logikai változóra, mely alapértelmezetten igaz. Majd a <function>double</function> függvény, abban az esetben
            ha ez a változó igaz értékű, akkor kiszámolja a két random számot. Eltárolja az egyiket, majd a
            <function>nincsTarolt</function>-t hamisra állítja. Így elkerülhetjük azt, hogy a programnak feleslegesen kelljen
            újra random számot generálnia. 
        </para>
        <para>
            Most, hogy láttuk, hogyan működik a saját Polár generátorunk, nézzük, hogy a OpenJDK <filename>Random.java</filename>
            forrásában, hogyan oldották meg ezt.
            <programlisting language="java"><![CDATA[
    private double nextNextGaussian;
    private boolean haveNextNextGaussian = false;
                
    public synchronized double nextGaussian() {
        // See Knuth, ACP, Section 3.4.1 Algorithm C.
        if (haveNextNextGaussian) {
            haveNextNextGaussian = false;
            return nextNextGaussian;
        } else {
            double v1, v2, s;
            do {
                v1 = 2 * nextDouble() - 1; // between -1 and 1
                v2 = 2 * nextDouble() - 1; // between -1 and 1
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s == 0);
            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
            nextNextGaussian = v2 * multiplier;
            haveNextNextGaussian = true;
            return v1 * multiplier;
        }
    }

            ]]></programlisting>
            Ahogy láthatjuk a hivatalos megoldás teljesen ugyanaz, mint a mi sajátunk. Ez a feladat arra ad példát, hogy
            az objektumorientált programozás egyáltalán nem annyira nehéz, mint azt sokan gondolják.
        </para>
        <para>
            Végezetül pedig lássuk, újra ennek a C++-os megoldását.
            <programlisting language="c++"><![CDATA[
class PolarGen {

	public:

		PolarGen(); //konstruktor

		~PolarGen(){} //destruktor

		double kovetkezo(); //random lekérés

	private:

		bool nincsTarolt;
		double tarolt; //random értéke

};


PolarGen::PolarGen() { //a konstruktor kifejtése
	nincsTarolt = false;
	std::srand (std::time(NULL)); //random inicializálás
};


double PolarGen::kovetkezo() { //random lekérő függvény kifejtése
	if (nincsTarolt)
{
		double u1, u2, v1, v2, w;

		do{
			u1 = std::rand () / (RAND_MAX + 1.0); //innentől jön az algoritmus
			u2 = std::rand () / (RAND_MAX + 1.0);
			v1 = 2 * u1 - 1;
			v2 = 2 * u2 - 1;
			w = v1 * v1 + v2 * v2;
		    }
		while (w > 1);

		double r = std::sqrt ((-2 * std::log (w)) / w);

		tarolt = r * v2; 
		nincsTarolt = !nincsTarolt;

		return r * v1; //idáig tart az algoritmus
	}
	
	else
	{
		nincsTarolt = !nincsTarolt; //ha van korábbi random érték, akkor azt adja vissza
		return tarolt;
	}
};    
            ]]></programlisting>
        </para>
    </section>        

    <section>
        <title>Homokózó</title>
        <para>
            Írjuk át az első védési programot (LZW binfa) C++ nyelvről Java nyelvre, ugyanúgy működjön!
            Mutassunk rá, hogy gyakorlatilag a pointereket és referenciákat kell kiirtani és minden máris működik
            (erre utal a feladat neve, hogy Java-ban minden referencia, nincs választás, hogy mondjuk egy
            attribútum pointer, referencia vagy tagként tartalmazott legyen).
        </para>
        <para>
            Miután már áttettük Java nyelvre, tegyük be egy Java Servletbe és a böngészőből GET-es kéréssel
            (például a böngésző címsorából) kapja meg azt a mintát, amelynek kiszámolja az LZW binfáját!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://git.io/Je3cZ">https://git.io/Je3cZ</link>                
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A könyv korábbi részében részletesen elemztük már, hogy hogyan működik az LZW binfa. 
            Megvizsgáltuk a C++ forrás felépítését, és több feladatban módosítottunk is rajta. Most
            viszont az eredeti <filename>z3a7.cpp</filename>-hez nyúlunk vissza, annak fogjuk 
            elkészíteni a Java implementációját, és megismerkedünk azzal is, hogyan lehet ezt 
            Java Servlet-ként böngészőben futtatni. Ahogy a feladat leírásásban olvashatod, 
            elég csak a pointereket és a referenciákat eltüntetni a forrásból. Természetesen ez 
            költői túlzás, de a feladat nem nehéz. 
        </para>
        <para>
            A Java programozási nyelv biztosítja azt, hogy ne kelljen azon gondolkodni, hogy 
            egy objektumot refernciakánt, pointerként, vagy esetleg csak értékként adjuk át.
            Mivel bármilyen objektumot is példányosítunk, az lényegében egy objektumrefernciát hoz
            létre. Kivételt képeznek ezalól a primitív típusok, mint az <function>int, double, char</function> stb.
            Ezekhez a Java nyelv csomagoló osztályokat biztosít, mint például az <function>Integer</function>,
            melyet már objektumreferenciaként példányosítjuk. Még egy fontos megjegyzés, mielőtt tovább haladunk,
            hogy a Java nem támogatja a operátor túlterhelést, szóval ezeket kénytelenek vagyunk
            hagyomásnyos függvényekkel helyettesíteni.
        </para>
        <para>
            Lássuk a forrást:
            <programlisting language="java"><![CDATA[
class LZWBinFa
{
    public LZWBinFa ()
    {
        fa = gyoker;
    }

    public void hozzarendel(char b)
    {
        if (b == '0')
        {
            if (fa.nullasGyermek () == null)
            {
                Csomopont uj = new Csomopont ('0');
                fa.ujNullasGyermek (uj);
                fa = gyoker;
            }
            else			
            {
                fa = fa.nullasGyermek ();
            }
        }
        else
        {
            if (fa.egyesGyermek () == null)
            {
                Csomopont uj = new Csomopont ('1');
                fa.ujEgyesGyermek (uj);
                fa = gyoker;
            }
            else
            {
                fa = fa.egyesGyermek ();
            }
        }
    }
    public void kiir ()
    {
        melyseg = 0;
        kiir (gyoker, new java.io.BufferedWriter(new java.io.OutputStreamWriter(System.out)));
    }

    public int getMelyseg ()
    {
        melyseg = maxMelyseg = 0;
        rmelyseg (gyoker);
        return maxMelyseg - 1;
    }
    public double getAtlag ()
    {
        melyseg = atlagosszeg = atlagdb = 0;
        ratlag (gyoker);
        atlag = ((double) atlagosszeg) / atlagdb;
        return atlag;
    }
    public double getSzoras ()
    {
        atlag = getAtlag ();
        szorasosszeg = 0.0;
        melyseg = atlagdb = 0;

        rszoras (gyoker);

        if (atlagdb - 1 > 0)
            szoras = java.lang.Math.sqrt (szorasosszeg / (atlagdb - 1));
        else
            szoras = java.lang.Math.sqrt (szorasosszeg);

        return szoras;
    }
    public void kiir (java.io.BufferedWriter os)
    {
        melyseg = 0;
        kiir (gyoker, os);
    }

    private class Csomopont
    {
        public Csomopont (char b)
        {
            betu = b;
            balNulla = null;
            jobbEgy = null;
        }
        public final Csomopont nullasGyermek ()
        {
            return balNulla;
        }
        public final Csomopont egyesGyermek ()
        {
            return jobbEgy;
        }
        public void ujNullasGyermek (Csomopont gy)
        {
            balNulla = gy;
        }
        public void ujEgyesGyermek (Csomopont gy)
        {
            jobbEgy = gy;
        }
        public final char getBetu ()
        {
            return betu;
        }

        private char betu;
        private Csomopont balNulla;
        private Csomopont jobbEgy;
    }

    private Csomopont fa;
    private int melyseg, atlagosszeg, atlagdb;
    private double szorasosszeg;

    public void kiir (Csomopont elem, java.io.BufferedWriter os)
    {
        if (elem != null)
        {
            try{
            ++melyseg;
            kiir (elem.egyesGyermek (), os);
            for (int i = 0; i < melyseg; ++i)
                os.write("---");
            os.write(elem.getBetu () + "(" + (melyseg - 1) + ")\n");
            kiir (elem.nullasGyermek (), os);
            --melyseg;
            }
            catch(java.io.IOException e){
                System.out.println("Csomópont írása nem sikerült.");
            }
        }
    }
    protected Csomopont gyoker = new Csomopont('/');
    protected int maxMelyseg;
    protected double atlag, szoras;

    protected void rmelyseg (Csomopont elem)
    {
        if (elem != null)
        {
            ++melyseg;
            if (melyseg > maxMelyseg)
                maxMelyseg = melyseg;
            rmelyseg (elem.egyesGyermek ());
            rmelyseg (elem.nullasGyermek ());
            --melyseg;
        }
    }
    protected void ratlag(Csomopont elem) {
        if (elem != null) {
            ++melyseg;
            ratlag(elem.egyesGyermek());
            ratlag(elem.nullasGyermek());
            --melyseg;
            if (elem.egyesGyermek() == null && elem.nullasGyermek() == null) {
                ++atlagdb;
                atlagosszeg += melyseg;
            }
        }

    }
    protected void rszoras(Csomopont elem) {
        if (elem != null) {
            ++melyseg;
            rszoras(elem.egyesGyermek());
            rszoras(elem.nullasGyermek());
            --melyseg;
            if (elem.egyesGyermek() == null && elem.nullasGyermek() == null) {
                ++atlagdb;
                szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
            }
        }

    }
            ]]></programlisting>
            Ahogy látható, semmilyen címképző operátorra, vagy csillagra nincs szükség a kódban.
            Maga az osztály konstruktora az nagyon hasonlít az eredetire. Viszont nincs már szükség
            destruktorra. Tehát a C++ forrásban lévő <function>szabadit</function>-ra már nincs szükségünk.
            Ez annak köszönhető, hogy Java szemétgyűjtögetője automatikusan törli azokat az objektumokat a memóriából, amire
            már nincs érvényes referencia. Lehet úgy példányosítani egy osztályt, mint ahogy C++-ban a sima változókat
            deklaráltuk
            <programlisting language="java">
                Csomopont fa;
            </programlisting>
            Ebben az esetben egy <function>null</function> referenciát kapunk, vagyis ennek még át kell adni egy
            bizonyos memóriacímen található objektumot. Jelen esetben ez nem okoz problémát a programban, mert a
            a <function>fa</function> objektumrefernciának átadjuk a <function>gyoker</function> által
            mutatott objektumot. az átírás során én nem inicializáltam a <function>gyoker</function>
            refenciát, így hibát dobott a program, mivel után a <function>fa</function> referencia is
            null referencia maradt, mely által mutatott objektumra hivatkozunk a későbbi függvényekbe.
            C++-hoz hasonlóan a <function>new</function> operátorral tudunk tárhelyet foglalni, mely Java-ban
            referenciát ad át.
        </para>
        <para>
            Az objektumorientált programozás alap építőkövének számító adatrejtés egy kicsit másabb, mint a
            C++-ban megszoktuk. Ahhoz, hogy az egyes tagváltozók és tagfüggvények elérhetőségét szabályozzuk, 
            mindegyik definíciója elé meg kell adni, hogy milyen elérést biztosítsunk hozzájuk. A Java nyelv 
            nem támogatja a operátor túlterhelést, új metódus jelent meg a programban, a 
            <function>hozzarendel</function>. Mostmár ezzel lehet a fába beletteni a nullákat és az egyeseket.
        </para>
        <para>
            Most, hogy már láttuk magát az osztályt, akkor nézzük meg a <function>main</function> függvényt. 
            <programlisting language="java"><![CDATA[
public static void main (String[] args)
{
    if (args.length != 3)
    {
        usage ();
        System.exit(-1);
    }

    String inFile = args[0];

    if (args[1].charAt(1) != 'o')
    {
        System.out.println("Missing -o argument");
        usage ();
        System.exit(-2);
    }

try {
        java.io.FileInputStream beFile = new java.io.FileInputStream(inFile);
        java.io.DataInputStream beFile_datastream = new java.io.DataInputStream(beFile);
        java.io.BufferedReader beFile_bufferedreader = new java.io.BufferedReader(new java.io.InputStreamReader(beFile_datastream));
        
        java.io.FileWriter kiFile = new java.io.FileWriter(args[2]);
        java.io.BufferedWriter kiFile_bufferedwriter = new java.io.BufferedWriter(kiFile);
        LZWBinFa binFa = new LZWBinFa(); // s nyomjuk majd be az LZW fa objektumunkba
        
        int c;
        while ((c = beFile_bufferedreader.read()) != -1){
            if (c == 0x0a) {
                break;
            }
        }
        boolean kommentben = false;

    while ((c = beFile_bufferedreader.read()) != -1)
    {
 
        if (c == 0x3e) {			// > karakter
                kommentben = true;
                continue;
            }

        if (c == 0x0a) {			// újsor
            kommentben = false;
            continue;
        }

        if (kommentben) {
            continue;
        }

        if (c == 0x4e) // N betű
        {
            continue;
        }

        for (int i = 0; i < 8; ++i) {
            if ((c & 0x80) == 128) // ha a vizsgált bit 1, akkor az '1' betűt nyomjuk az LZW fa objektumunkba
            {
                binFa.hozzarendel('1');
            } else // különben meg a '0' betűt:
            {
                binFa.hozzarendel('0');
            }
            c <<= 1;
        }

    }


    binFa.kiir(kiFile_bufferedwriter);
    kiFile_bufferedwriter.write("depth = " + binFa.getMelyseg() + '\n');
    kiFile_bufferedwriter.write("mean = " + binFa.getAtlag()+ '\n');
    kiFile_bufferedwriter.write("var = " + binFa.getSzoras() + '\n');

    kiFile_bufferedwriter.close();
    kiFile.close ();
    beFile_datastream.close ();
    beFile_bufferedreader.close();
    beFile.close();
    } catch (Exception e) {
        for (StackTraceElement elem : e.getStackTrace()) {
            System.err.println(elem);
        }
    }

}
            ]]></programlisting>
            A függvény lénnyegében ugyanazt csinálja, mint korábban. Feltűnhet, hogy már nem 
            4 paraméternek kell lennie, hanem csak 3-nak. Ez abból adódik, hogy Java-ban az
            első paraméter nem a program neve, hanem az álatulnk megadott első paraméter a 
            program neve után. Tehát leellenőrizzük, hogy meg van-e minden szükséges paraméter.
            Ezután jön egy érdekesség, mely a korábbi programban nem volt benne, de gyakorlott
            C++ programozóknak már nem lehet újdonság, ez a <function>try-catch</function> blokk.
            Java-ban a kivételkezelés sok esetben elvárásnak számít. Jelen esetben a fájlkezelés
            miatt volt rá szükség, mivel enélkül le se fordulna a kód. De ezzel az esetleges
            null referenciákra való hivatkozást is ki tudjuk szűrni.
            Első lépésként 
            megnyitjuk a bemenethez és a kimenethez szükséges fájlokat. Ehhez a java.io osztályait
            használjuk. Ezután pedig elkezdjük beolvasni a forrást, és az abban lévő betűk függvényében
            0-kal és 1-kel feltölteni a fát. A <function>for</function> ciklust kellett egy kicsit átalakítani, 
            mivel Java-ban a bájtsorrend big-endian, ezért nem 1-el kell egyenlőnek lennie a
            <function><![CDATA[(c & 0x80)]]></function> kifejezésnek, hanem 128-al, ahhoz, hogy 
            1-est nyomjunk a fába. Majd a fát és annak mélységét, átlagát, szórását kiírjuk a 
            kimenetként kapott fájba. Egy dologra vigyázni kell, hogy a <function>BufferedWriter</function>
            osztály nem azonnal írja ki a fájlba a tartalmat, hanem csak akkor, amikor bezárjuk az 
            általa megnyitott fájlt. Tehát ha ezt elfelejtjük megtenni, akkor azt nem kapjuk meg a
            program eredményét.
        </para>
        <para>
            A következőkben a Java Servletről lesz szó.
        </para>
    </section>        
    
    <section>
        <title>Gagyi</title>
        <para>
            Az ismert formális
            <function><![CDATA[„while (x <= t && x >= t && t != x);"]]></function> tesztkérdéstípusra adj a szokásosnál
            (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
            referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
            értékekkel meg nem! A példát építsd a JDK Integer.java forrására
            , hogy a 128-nál inkluzív objektum
            példányokat poolozza!
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A feladat arra épül, hogy a Java <function>Integer</function> osztálya 
            a 128-nál kisebb egészeket pool-ozza. Ez abban nyilvánul meg, hogy 
            ha példányosítunk egy <function>Integer</function> objektumot, ami 
            128-nál kisebb értéket kap, akkor az objektum referencia ugyanarra a 
            memóriaterületre hivatkozik. Lássuk a forrást:
            <programlisting language="java"><![CDATA[
class Gagyi{
	public static void main (String[] args){
            if (args.length != 2){
                System.out.println("Használat: java Gagyi szám");
                return;
            }
            
            Integer x = Integer.parseInt(args[0]);
            Integer t = Integer.parseInt(args[0]);
                
            while (x >= t && x <= t && x != t){
                System.out.println("Gagyiiii");
            }
	}
} 
            ]]></programlisting>
            A program 1 egész számot kér paraméterként, majd ezek értékét átadjuk
            x és t objektumrefernciáknak. Ezután pedig végrehajtjuk a feladatban megadott
            ciklust. A ciklus ellentmondása abból adódna egy laikusnak, hogy lényegében a 
            feltétel azt vizsgálja, hogy teljesül-e az, hogy <function>x</function> és
            <function>t</function> egyenlő, emellett pedig <function>x</function> és 
            <function>t</function> nem egyenlő. Viszont Java-ban létezik az automatikus 
            csomagolás fogalma. Ennek annyi a lényege, hogy a program autmatikusan 
            kicsomagolja az <function>Integer</function> osztály értékét, abban az 
            esetben, ha ez szükséges. Például a <function><![CDATA[<=, >=]]></function>
            operátorok esetén megtörténik a kicsomagolás. Ellenben a
            <function><![CDATA[!=]]></function> operátor objektum refernciákat
            hasolít össze. Ha a két <function>Integer</function> objektum 
            értéke ugyanaz, és 128-nál kisebb az értéke, akkor nem lépünk be a 
            végtelen ciklusba. Ellenben ha 127-nél nagyobb egészt adunk meg, akkor
            viszont belépünk, amiatt, mert ebben az esetben az objektum referenciák
            különbözőek lesznek.
        </para>
    </section>    
            
    <section>
        <title>Yoda</title>
        <para>
            Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
            conditions-t! 
        </para>
        <para>
            <link xlink:href="https://en.wikipedia.org/wiki/Yoda_conditions">https://en.wikipedia.org/wiki/Yoda_conditions</link>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A Yoda conditions nevét a Star Wars-ból ismert Yoda karakterről kapta. Az
            említett filmben ő angolul beszél, viszont nem a nyekv hagyományos
            szintaxisával. Ilyen furcsaságról van szó itt is. Azért találták ki, hogy
            megkönnyítsék a programozók számára az elírások kiszűrését, abban az esetben, amikor
            egyenlőséget vizsgálunk.
            Főleg akkor
            érdemes használni, amikor a változókat nem változóval hasonlítjuk össze, hanem
            valamilyen konstanssal.
            <programlisting language = "java"><![CDATA[
Integer a = 5;
//Yoda használata nélkül
if (a == 6)
  //valamit csinál 

//Yoda használatával     
if (6 == a)
   //valamit csinál
            ]]></programlisting>
            Ahogy látható a Yoda conditions lényege, hogy felcseréljük a feltételben a 
            változót a konstanssal. Ez a technika megkönnyíti a hibakeresését például 
            ebben az esetben:
            <programlisting language= "java"><![CDATA[
if (6 = a)          if (a = 6)
            ]]></programlisting>
            Ha így írjuk a feltételt, akkor is működni fog a program, de az 
            <function>if</function>-be mindig be fog lépni a vezérlés, mivel 
            annak fejlécében csak értéket adunk át, és nem feltételt vizsgálunk.
            Ezzel az a probléma, hogy a programunk nem megfelelően működik, és
            ez a legrosszabb módja, mert nem is kapunk visszajelzést a hibáról.
            Viszont az első esetben sokkal egyszerűbb észrevenni, mint a 
            másodiknál.
        </para>
        <para>
            Most, hogy tudjuk, mi is az a Yoda conditions, lássuk a feladat 
            megoldását.
            <programlisting language="java"><![CDATA[
class Yoda{
    public static void main (String[] args){
        String a = null;

        if(a.equals("Yoda")){
//        if("Yoda".equals(a)){
            System.out.println("Yoda");
        }
    }
}  
            ]]></programlisting>
            Jelen álllapotában a program kivételt dob, pontosan azt , amit a 
            feladat előír, a java.lang.NullPointerEx-et. Ez annak köszönhető, hogy
            az <function>a</function> objektum refencia <function>null</function>
            értékű, és ennek a tagfüggvényét hívjuk meg. Mivel nem létező 
            objektumra mutat hivatkozik, ezért kapunk hibát. Viszont a 
            kikommentezett feltételt használva már nem kapunk hibát. Ez annak
            köszönhető, hogy a beírt szöveg egyből <function>String</function>-é
            konvertálódik, és el tudjuk érni annak tagfüggvényeit.
            <figure>
                <title>Yoda conditions alkalmazásával</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Yoda/yoda_on.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Yoda conditions alkalmazása nélül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Yoda/yoda_off.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Összegezve a láttotakat, kijelenthetjük, hogy bizonyos esetben igazán hasznos lehet
            a Yoda conditions használata. Több órás keresgéléstől kímélhetjük meg magunkat egyes
            hibák felderítése során.
        </para>
    </section>
    
    <section>
        <title>Kódolás from scratch</title>
        <para>
            Induljunk ki ebből a tudományos közleményből: <link xlink:href="http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbpalg.pdf">http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbpalg.pdf</link>
            és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
        </para>
        <para>
            Ha megakadsz, de csak végső esetben: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/
            javat-tanitokjavat/apbs02.html#pi_jegyei">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitokjavat/apbs02.html#pi_jegyei</link>
            (mert ha csak lemásolod, akkor pont az a fejlesztői élmény marad ki,
            melyet szeretném, ha átélnél).
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                
