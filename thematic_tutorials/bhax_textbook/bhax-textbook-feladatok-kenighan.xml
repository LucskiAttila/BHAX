<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Kernighan!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Pici könyv 11-27. oldal feldolgozása</title>
        <para>
            <emphasis role="strong">Alapfogalmak</emphasis>
        </para>
        <para>
            Ha a számítógépek programozási nyelveiről beszélünk, akkor
            fontos említést tenni róla, hogy milyen szintekre tudjuk őket
            osztani. Az első a gépi nyelv, mely lényegében 0-kból és 1-kből
            álló bináris kód. Ezt követi az assembly szintű nyelv, amely már egy
            kicsit közelebb van az emberi nyelvekhez, de még alacsony szintű
            programozási nyelvnek minősül. Legvégül pedig tegyünk említést a
            könyv fő témájáról a magas szintű programozási nyelvekről. Ezek
            már közel állnak az emberek által is értelmezhető nyelvekhez, főleg
            az angolra épülneké. 
        </para>
        <para>
            A magas szintű programozási nyelven írt programot forrásprogramnak
            nevezzük. Ennek az előállításához be kell tartani bizonyos az 
            adott nyelvre jellemző formai,szintaktikai szabályokat és a tartalmi,
            szemantikai szabályokat.
        </para>
        <para>
            A processzorok saját gépi nyelvvel rendelkeznek, és csak az ezen a
            nyelven írt programokat képesek végrehajtani. Tehát a forráskódokat
            át kell alakítani a gép által értelmezhető gépi kódra. Erre két
            analógia létezik, az egyik a fordítóprogramos megoldás, a másik
            az interpreteres.
        </para> 
        <para>
            A fordítóprogram egyetlen egységként kezeli a
            forrást, és lexikai, szintaktikai, szemantikai elemzést hajt
            végre, majd legenerálja a gépi kódot. Ez még nem futtatható, ebből
            a kapcsolatszerkesztő állít elé futtaható programot, melyet a betöltő
            behelyez a tárba, és a futtató rendszer felügyeli a futását. Bizonyos
            esetekben lehetőség van arra, hogy nem nyelvi elemeket használjunk
            egy forrásprogramban, de ilyenkor szükség van egy előfordítóra is.  
        </para>
        <para>
            Az interpreteres megoldás nem készít tárgykódot, viszont a fentebb
            említett 3 elemzést végrehajtja. Utasításonként sorra veszi a
            forrásprogramot, értelmezi, és végrehajtja. tehát rögtön kapjuk meg
            eredményt. Bizoynos nyelvek esetén mind az interpreteres, mind a
            fordítóprogramos megoldást alkalmazzák.
        </para>
        <para>
            Minden programozási nyelvhez tartozik egy hivatkozási nyelv, mely a
            szemantikai és szintaktikai szabályokat határozza meg. Emellett
            léteznek még implementációk. Az egyes rendszereken több fordítóprogram
            és iterpreter létezik, és ennek következtében az implementációk
            nem kompatiblisek egymással, ez pedig meggátolja a programok tökéletes
            hordozását a platformok között.
        </para>
        <para>
            A programozó dolgának megkönnyítése érdekében létrejöttek az 
            integrált grafikus felületek(IDE), melyek egy csomagban tartalmaznak
            minden szükséges eszközt a programok megírásához, és futtatásához.
        </para>
        <para>
            <emphasis role="strong">A programnyelvek osztályozása</emphasis>
        </para>
        <para>
            Összeségében 2 fő csoportra oszthatjuk a programozási nyelveket:az 
            imperatív nyelvekre és a deklaratív nyelvekre.
        </para>
        <para>
            Az imperatív nyelvek algoritmikus nyelvek, tehát a programozó maga 
            kódolja le az algoritmust, amit a processzor majd végrehajt. A program
            utasításokból épül fel. Legfőbb eszköz a változó, mely segítségével
            el tudunk érni tárterületet, és tudjuk módosítani annak tartalmát.
            Jelen esetben az algoritmusok teszik ezt. Az imperatív nyelveknek
            2 alcsoportja van: az Eljárásorientált nyelvek és az Objektumorientált
            nyelvek. 
        </para>
        <para>
            Ezzel szemben a deklaratív nyelvek nem algoritmikusak, a programozó
            csak felvázolja a problémát, és a nyelvi implementációkban be van 
            építve a megoldás megkeresésének módja. Memóriaműveltekre
            nincs lehetőség, vagy nagyon korlátozott módon. Ennek is 2 alcsoportja
            van: a Funkcionális nyelvek és a Logikai nyelvek.
        </para>
        <para>
            Léteznek olyan nyelvek is, amelyek nem sorolhatóak be egyik osztályba
            sem, nincs egységes jellemzőjük. Általában az imperatív nyelv valamelyik
            tulajdonságát tagadják.
        </para>
        <para>
            <emphasis role="strong">Karakterkészlet</emphasis>
        </para>
        <para>
            A programok legkisebb épitőelemei a karakterek. A forrásszöveg
            írásakor alapvető a karakterkészlet ismerete, mivel csak ezek
            jelenhetnek meg a kódban, és belőlük állítható elő összetett
            nyelvi elem. Az eljárásorientált nyelvek lexikális, szintaktikai 
            egységek, utasítások, programegységek, fordítási egységek
            és végül maga a program épül fel a nyelvi elemekből.
        </para>
        <para>
            Minden nyelv definiálja a saját karakterkészletét, de a lgetöbb
            programnyelv a karaktereket 3 kategóriába sorolja: betűk, számok,
            egyéb karakterek. A legtöbb nyelvben a betűk az angol ABC 26 betűjét
            tartalmazzák, viszont az már nyelv függő, hogy értelmezve van-e a nagy
            és kis betű, vagy különbséget tezs a kettő között. Egyes újabb nyelvek
            már nemzetisági betűket is tartalmaznak, ennek következtében
            "magyarul" is programozhatunk. A számokat nagyjából mindegyik
            nyelv hasonlóan kezeli, a decimális számjegyeket veszik számokjegy
            karakternek. Egyéb karakterek közé soroljuka műveleti jeleket(+,-,*,/),
            elhatároló jeleket([,],., {, },;), írásjeleket és speciális
            karaktereket. A hivatkozási nyelv és az implementáció karakterkészlete
            egyes esetekben eltérő lehet.
        </para>
        <para>
            <emphasis role="strong">Lexikális egységek</emphasis>
        </para>
        <para>
            A lexikális egységek azok, amelyeket a fordítóprogram felismer, és 
            tokenizál. Lehetnek többkarakteres szimbólumok, szimbolikus nevek,
            cimkék, megjegyzések, literálok.
        </para>
        <para>
            Többkarakteres szimbólumoknak a nyelv tulajdonít jelentést, gyakran
            operátorok vagy elhatárolók, mint C-ben a ++,--,<![CDATA[&&]]>.
        </para>
        <para>
            Szimbolikus neveket 3 csoportra bontjuk, az azonosítókra, a
            kulcsszóra és a standard azonosítóra.
            Az azonosító betűvel kezdődik és betűvel vagy számmal folytatódik, 
            segítségével programozói eszközöket nevezünk meg, és ezzel a névvel
            tudunk rájuk hivatkozni a programon belül.
            A kulcsszónak az adott nyelv tulajdonít jelentést, ez nem
            változtatható meg. C-ben iylenek az if, for, case, break.
            A standard azonosító pedi egy kicsit mind a kettő, mivel ezt is az 
            adott nyelv látja el jelentéssel, de a programozó megváltoztathatja.
            C-ben sztenderd azonisítónak számit a NULL.
        </para>
        <para>
            A címkéknek főleg az eljárásorientált nyelvekben van nagy jelentősége
            ,mivel a segítségével képesek vagyunk megjelölni a végrehajtó
            utasításokat, így tudunk rájuk hivatkozni a program más részein.
        </para>
        <para>
            A megjegyzések szerepe az évek során eléggé megkopott, de természetesen
            minden nyelv biztosít lehetőséget kommentek hozzáadásához. A komment
            lényegében egy karaktersorozat, amelyet a fordító ignorál. Több 
            implementáció létezik a kommentek alakalmazására, lehet teljes
            komment sorokat elhelyezni, vagy sor végi kommenteket, de lehetőség
            van több soros, egybefüggő kommentek elhelyezésére is. A C-ben mind
            a 3-ra van lehetőség. (Egysoros komment://, többsoros: /* */) 
        </para>
        <para>
            Végezetül tegyünk említést a literálokról is, mely programozási eszközök
            segítségével fix értékek építhetők be a programba. A literáloknak van
            típusuk és értékük. A literálrendszerek egyes programozási nyelvekben
            eltérő lehet.
        </para>
    </section>        
    <section>
        <title>A Pici könv 28-45. oldal feldolgozása</title>
        <para>
            <emphasis role="strong">Adattípusok</emphasis>
        </para>
        <para>
            Az adattípus egy absztrakt programozási eszköz,mely kronkrét eszközök
            komponenseként jelenik meg. Mindig rendelkezik egy névvel, ami azonosító.
            Nem minden nyelv ismeri ezt, azt eszközt, főleg az eljárásorientált
            nyelvekben van fontos szerepe. Az adattípust a tartomány, a műveletek
            és a reprezentáció határoz meg.
        </para>
        <para>
            A tartomány az adattípus által felvehető értékek halmazát adja meg.
            Mindegyikhez hozzátartoznak műveletek, amit az adott típussal végre
            tudunk hajtani. A reprezentáció pedig a beslő ábrázolást írja le,
            vagyis a tárban a típus hány bájtra képződik.
        </para>
        <para>
            Bizonyos nyelvek lehetőséget biztosítanak arra, hogy a programozó
            saját adattípusokat adjon meg, mindezt általában a beépített 
            típusok segítségével. Meg tudjuk adni a tartományt, a műveleteket, és
            a reprezentációt is. Viszont ezt nagyon kevés nyelv támogatja.
        </para>
        <para>
            Az adattípusokat 2 nagy csoportra osztjuk: skalár adattípus és
            összetett adattípus.
        </para>
        <para>
            A <emphasis role="strong">saklár</emphasis> típus tartománya atomi
            értékeket tartmaz. Skalár típus a 
            minden nyelvben létező egész, melynek belső ábrázolása fixpontos.
            Vannak még a valós típusok, ezek reprezentációja lebegőpontos,
            tartománya implementációfüggő. Ezt a két típust együtt numerikus
            típusoknak nevezzük, melyeken numerikus és összehasonlító műveletek
            hajthatók végre.
        </para>
        <para>
            A karakteres típus elemei karakterek, míg 
            karakterlánc típuséi karaktersorozatok. Ezeken szöveges és hasonlító
            műveleteket hajthatunk végre. Ábrázolásuk karakteres.
        </para>
        <para>
            Bizonyos nyelvek támogatják a logikia típusokat is, melyek értéke igaz
            vagy hamis lehet, logikai és hasonlító műveleteket tudunk velük
            végrehajtani.
        </para>
        <para>
            Érdekességként meg lehet említeni a felsorolás típust vagy a sorszámozott
            típust, de ezek kevésbé elterjedtek, csak néhány nyelvben fordulnak elő.
        </para>
        <para>
            Az <emphasis role="strong">összetett típusok</emphasis> közül a két
            legfontosabb a tömb és a rekord. A tömb homogén, statikus összett típus,
            meghatározzák a dimenzóinak száma, az indexkészletének típusa és tartománya,
            és az eleminek a típusa. Léteznek több dimenziós tömbök, melyeket
            lehet oszlopfolytonosan vagy sorfolytonosan ábrázolni. A tömb elemeit
            indexek segítségével tudjuk bejárni.
        </para>
        <para>
            A rekord típus heterogén, tartományában különböző típusok szereplehetnek.
            Az egyes elemeket mezőknek nevezzük, melyeknek van saját neve és típusa.
            A mezőneveket minősített nevekkel tudjuk ellátni, ezzel segítve az azonos 
            nevű mezők megkülönböztetését.
        </para>
        <para>
            A <emphasis role = "strong">mutató típus</emphasis> egyszerű típus,
            de érdekessége az, hogy tartomány tárcímekből áll. Segítségével indirekt
            módon el tudjuk érni a mutatott elem értékét. Fontos a szerepe az
            absztrakt adatszerkezetek szétszórt reprezentációjában.
        </para>
        <para>
            <emphasis role="strong">Nevesített konstans</emphasis>
        </para>
        <para>
            3 komponensből áll: név, típus, érték.
            Mindig deklarálni kell, mely során megkapja az értékét, és azt 
            nem lehet módosítani a futás folyamán. A nevével tudunk hivatkozni az
            értékkomponensére. Ennek köszönhetően, elég a deklarációnál
            ,módosítani az értéket, és nem kell minden egyes előfordulásnál.
            C-ben ezt a következőképpen használjuk:
            <programlisting language="c"># define név literál</programlisting>
            Ez az előfordítónak szól, és a név minden előfordulását helyettesíti
            a literállal.
        </para>
        <para>
            <emphasis role="strong">Változó</emphasis>
        </para>
        <para>
            4 komponensből áll: név, attríbútum, cím, érték. A név egy azonosító, a
            programban a változó mindig a nevével jelenik meg. Attribútumnak olyan
            jellemzőket nevezünk, amik befolyásolják a változó viselkedést. Attribútum
            például a változó típusa, mely a deklaráció során rendelődik a változóhoz.
        </para>
        <para>
            Létezik explicit deklaráció, implicit deklaráció és automatikus deklaráció.
            Az explicit deklaráció a véltozó nevéhez rendel attribútumot, míg az implicit
            betűkhöz. Pl. megoldható, hogy az azonos kezdőbetűvel rendelkező 
            változók azonos attribútumúak lesznek. Az automatikus pedig azt jelenti,
            hogy a fordítóprogram rendel attribútumot a változóhoz, ha az még nem volt
            deklarálva.
        </para>
        <para>
            A változó címkomponense határozza meg a változó helyét a tárban. Egy változó
            élettartamának a futási idő zon részét nevezzük, ameddig a változó rendelkezik
            címkomponenssel. A címet lehet statikus vagy dinamikus tárkiosztással rendelni
            változóhoz. Létezik még programozó által vezérelt tárkiosztás is, a futási
            időben a programozó rendel címkomponenst a változóhoz.
        </para>
        <para>
            A változó értékkomponense bitkombinációként jelenik meg a címen, melynek
            felépítését a típus határozza meg. A változónak értéket értékadó utasítással
            tudunk adni, mely a C-ben így néz ki:
            <programlisting language="c">változónév = kifejezés;</programlisting>
        </para>
        <para>
            <emphasis role="strong">Alapelemek C-ben</emphasis>
        </para>
        <para>
            A C tipusrendszere 3 részre bontható, vannak az aritmetikai típusok,
            a származtatott típusok és a void típus. Az aritmetikai típusok közé tartoznak az
            egészek, a karakter, a felsorolás, a valósok. A származtatott típusok a tömb, a függvény
            mutató, struktúra, union.
        </para>
        <para>
            <emphasis role="strong">Az aritmetikai típusok egyszerű, mig a származtatottak
            összetett típusok.</emphasis>. Az előbbivel aritmetikai műveletek végezhetőek.
            Logikai típus nincs, az <function>int 0</function> felel meg hamisnak, az összes
            többi érték igaz értékkel rendelkezik. A logikai műveletek <function>int 1</function>-et
            adnak  vissza igaz esetén. A egsészek és karakterek előtt használható 
            <function>unsigned/signed</function> típusminősítők segítségével
            tudjuk beállítani vagy letiltani az előjeles ábrázolást. A struktúra fix
            szerkezetű rekord, ezzel szemben a union, csak változó részt tartalmazó rekord.
            A void típus tartomány üres, tehát nincs reprezentációja, sem műveletei.    
        </para>
    </section>        
    <section>
        <title></title>
        <para>
            
        </para>
        
                
    </section>        
    <section>
        <title>BME C++ könyv 1-16. oldal feldolgozás</title>
        <para>
            <emphasis role="strong">C++ nem objektum-orientált újdonságai</emphasis>
        </para>
        <para>
            A C++ lényegében a C programozási nyelv objektum-orientált változata, melynek első változata 1983-ban jelent meg. A nyelv atyjának
            Bjarne Stroustrup-ot tekintjük, aki <![CDATA[AT&T Bell]]> Laboratories-nak dolgozott. Első verzió neve C with class, ezzel utalva
            az objektum-orientáltságra. A C++ 1998-ban lett szabványosítva, azóta szabványt is kiadtak, a 2003-ast és a 2011-est. A C++ programok
            érdekessége, hogy többségük lefordul a C frodítókkal, sőt kezdetben az első C++ fordítók C kódot generáltak. Tehát minden C program C++ program, de
            nem minden C++ program C program.   
        </para>
        <para>
            Ebben a fejezetben pont azokat a különbségeket fogjuk sorra venni, amik C++-ban használhatóak, de a C-ben nem. Itt olyan funkciókra kell gondolni, amik
            segítettek kijavítani a C nyelv esetleges gyengeségeit.  
        </para>
        <para>
            Az első lényegi különbség a függvényparaméterekben és  a visszatérési értékben rejlik. A C-ben, ha nem írtunk paramétert, akkor korlátlan számú
            paramétert használhattunk, ezzel szemben a C++-ban ez annyit jelent, hogy nincs paraméter, vagyis mintha a paraméternek void típust adtunk volna meg.
            Ahhoz, hogy a korlátlan számú paramétermegadást engedélyezzük C++-ban, a paraméterlistéba <function>...</function>-t kell beírni.
            <programlisting language="c">
                //C-ben
                void f()
                {
                }
                
                //C++-ban
                void f(...)
            </programlisting>
            Egy másik különbség, hogy a C nyelvben kihagyhatjuk a visszatérési érték típusának meghatározását, azt int-nek értelmezi. Ezzel szemben C++-ban fordítási hibát
            kapunk, nem szabad kihagyni a visszatérési érték típusának meghatározását.
            <programlisting language="c++">
                void f(void); //nincs hiba
                g(void); //fordítási hiba
            </programlisting>
        </para>
        <para>
            A másik különbség a main függvényben keresendő. Az argmentum listát hagyhatjuk üresen, vagy használhatjuk az argc, argv[] argumentumokat, mellyel a parancssori argumentumok számát
            és tömbjét adja át a main-nek. Ez eddig hasióonló a C-hez, de a main végére nem szükséges oda írni a <function>return</function>-t, azt a fordító automatikusan hozzáilleszti a kódhoz.
        </para>
        <para>
            Sokáig a C++ nyelv sajátja volt a <function>bool</function> típus, mellyel logikai változókat deklarálhatunk, értéke <function>true</function>
            és <function>false</function> lehet. Ez mát a C-ben is elérhető, de előtte csak az int vagy az enum típusokkal fejezhettük ezt ki. Int esetén 0 számít 
            hamisnak és minden más érték igaz.  
        </para>
        <para>
            A C++-ban megjelet  a <function>wchar_t</function>, mint beépített típus, mely segítségével Unicode karakter stringeket tudunk reprezentálni. Ez a C-ben
            is használható, viszont ehhez #include-olni kellett a bizonyos header fájlokat.  Az iylen típusú változókat a következőképpen definiálhatjuk:
            <programlisting language="c++">
                wchar_t = L 's';
                wchar_t* = L "sss";
            </programlisting>
        </para>
        <para>
            C++-ban a változókat olyan helyeken is deklarálhatjuk, ahova utasításokat is írhatunk. Ilyen például, hogy a <function>for</function> ciklus-ban tudjuk definiálni az indexet, nem kell
            azt előtte deklarálni. Ettől függetlenül elmondható, hogy a változókat érdemes pont ott deklarálni, ahol a szeretnénk használni, ezzel áttekinthetőbb kódot kapunk. A változó csak a 
            deklarációja után érhető el. A <function>for</function> cilus fejlécében deklarált változókat nem tudjuk használni a cikluson kívül.
        </para>
        <para>
            A C nyelvben nem tudunk azonos nevű függvényket megadni, mivel azonosításként a linker csak a függvény nevét használta. Ennek következtében a programpzóknak rengetegszer kellett
            erőltett függvényneveket kitalálni. Ezt a problémát oldja meg  a C++ függvény túlterhelés funkciója, mely annyit tesz, hogy a linker a  függvényt a neve és az argumentum listája alapján
            azonosítja. Tehát létre tudunk hozni azonos nevű függvényeket, ha azok argumentumlistája eltér. Ezt a technikát név felderítésnek nevezzük. Mivel ez a C-ben nem értelmezett ez a funkció,
            kitaláltak egy módszert arra, hogy a C és C++ közötti kompataiblitást megoldjuk, ehhez a függvény deklaráció elé kell írni, hogy <function>extern int</function>. Ezzel letiltjuk a 
            név felderítő mechanizmust. 
        </para>
        <para>
            A függvényekkel kapcsolatos másik különbség, hogy a C++ kódban lehetőségünk van alapértelmezett értéket adni az argumentumoknak. Ezzel ki tudjuk küszöbölni azt, hogyha 
            nem adunk meg elég argumentumot a függvényhívásnál.
            <programlisting language="c++">
                int f( int a, int b = 100, int c = 200){
                    return a*b-c;
                }
                int main()
                {
                    int egyik = 10;
                    int masik = 20;
                    int harmadik = 30;
                    f(egyik, masik, harmadik); //érték = 10*20*30
                    f(egyik) // érték = 10*100*200
                    f() // hiba: nincs elég argumentum
                }
            </programlisting>
        </para>
        <para>
            A C++ egyik legnyagobb újdonsága pedig a referencia típus bevezetése. A C-ből tudjuk, hogy ha egy függvénynek paraméterül adunk egy változót, akkor a azt lemásolja a függvény, és nem 
            módosítja a változó értékét. Ha azt szeretnénk, hogy a függvény módosítson az értéken, ahhoz kell használni a pointert, ami a változó memóriacímére mutat. Ennek segítségével 
            közvetlenül tudjuk átadni a függvénynek a változót, nem másoljuk az  értékét. Ennek használata elég nehezen érthetővé teszi a kódot, és rengeteg hibázási lehetőséget rejt  magában.
            Hogy ezt orvosolják, bevezették a referencia típust.
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
