<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/V%C3%A9gtelen%20ciklus">itt</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Végtelen ciklusnak olyan ciklusokat hívunk, melyek soha nem érnek véget, általában valamilyen logikai hiba miatt.
            Pl:
            <programlisting language="c"><![CDATA[Program pelda
                {
                int main()
                {
                    int i = 0;
                    while (i<=0)
                    {
                        i = i-1;
                    }
                }
                }]]>
            </programlisting>
            Ebben jól láthatod, hogy a while cilusban lévő feltétel folyamatosan teljesül, theát a program végtelen ciklusba kerül.
            Viszont, ha kifejezetten végtelen ciklust szeretnél írni, ennek a legelegánsabb módja a következő:
            <programlisting language="c"><![CDATA[Program vegtelen.c
                {
                int main()
                {
                    for(;;);
                }
                }
                ]]>
            </programlisting>
            Ez a végtelen ciklus csak egy magot dolgoztat, de azt 100%. A lényege annyi, hogy a for ciklus nem kap semmilyen argumentumot,
            ennek következtében a ciklus előtti teszt folyamatosan igazat fog adni, tehát a ciklus nem fejeződik be.
        </para>
        <para>    
            De nem elégszünk meg az egy maggal, hiszen ma már a legtöbb számítógép legalább 4 maggal rendelkezik. Tehát találni kell egy 
            megoldást, hogy az összes mag dolgozzon 100%-on. Ezt oldja meg az OpenMP.(Bővebben <link xlink:href="https://en.wikipedia.org/wiki/OpenMP">itt</link> olvashatsz erről.)
            A lényege annyi, hogy program több szálon dolgozhat, így kihasználva a rendelkezésre álló erőforrásokat. Ráadásul ez könnyen implementálható az előző kódunkba:
            <programlisting language="c"><![CDATA[Program vegtelen_all.c
                {
                int main()
                {
                    #pragma omp parallel
                    for(;;);
                }
                }
                ]]>
            </programlisting>
            Amint látod, csak a #pragma omp paralellel sort kellett hozzáadni. Természetesen ezt bármelyik programodnál használhatod, sőt javasolt is, köszönthetően a hardverek gyors fejlődésének.
        </para>
        <para>
            Még egy dologgal adós vagyok. Már láttad, hogy hogyan lehet megoldani, hogy egy végtelen ciklus 100%-ban használjon egy magot, majd azt is, hogyan használjon 100%-ban a processzort.
            Itt az idő megnézni, hogyan lehet elérni, hogy egy végtelen ciklus egyáltalán ne használjon (vagyis nagyon keveset) a CPU által biztosított erőforrásból. Ehhez a sleep függvényre lesz szükségünk.
            A kód a következő:
            <programlisting language="c"><![CDATA[Program vegtelen_s.c
                {
                    int main()
                    {
                        for(;;)
                        {
                            sleep(1);
                        }
                    }
                }
                ]]>
            </programlisting>
            A sleep függvény lényegében minden meghívásánál "aludni" küldi azt a szálat, amit program használna, jelen esetben 1 másodpercig altatja.
        </para>
    </section>
                     
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne végtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/V%C3%A1ltoz%C3%B3%20felcser%C3%A9l%C3%A9se">itt</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ha valaki két változónak az értékét fel akarja cserélni, akkor a legegyszerűbb megoldásnak egy segédváltozó bevezetése tűnhet. De természetesen ennél sokkal kifinomultabb eszközök is vannak
            erre a célra. Az egyik ilyen megoldás, hogy valamilyen matematikai műveletet használunk. Egyik megoldás az, hogy a két változó értékét összeadjuk, majd ebből az összegből kivonjuk a változók régi értékét
            úgy, hogy a értékük felcserélődjön.
            Tehát:
            <programlisting language = "c"><![CDATA[
                int a = 4;
                int b = 5;
                a = a+b;
                b = a-b;
                a = a-b;
            ]]></programlisting>
            Ez szín tiszta matematika, viszont ennél egy sokkal érdekesebb dolog ugyan ennek a feladatnak EXOR-ral való megvalósítása. A lényeg annyi, hogy a számítógép a változó értékét 2-es számrendszerben tárolja
            ennek következtében a szám 0-kból és 1-kből áll. A XOR (kizáró vagy) minden esetben 1-et ad vissza kivéve, azaz igaz értéket, kivéve ha a művelet jobb és bal oldalán azonos érték van,
            mert ilyenkor 0-t ad vissza. Ezt használjuk most ki a következő példában:
            <programlisting language = "c"><![CDATA[
                int a = 4; //2-es számrendszerben: 0100
                int b = 5; //2-es számrendszerben: 0101
                a = a^b; // 0100 ^ 0101 = 0001
                b = a^b; //0001 ^ 0101 = 0100
                a = a^b //0001 ^ 0100 = 0101
            ]]></programlisting>
            A komment szekcióban láthatjátok, hogy mi is történik a háttérben.
        </para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/Labdapattog%C3%A1s">itt</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ahogy a videóban láthattátok, a labdapattogás annyiból áll, hogy a terminálon belül egy karakter pattog a az ablak teljes méretében. Fontos, hogy az ablak méretét állíthatjuk, és a program ezt érzékeli.
            <programlisting language="c"><![CDATA[
                WINDOW *ablak;
                ablak = initscr ();
            ]]>
            </programlisting>
            Az initscr() beolvassa az ablak adatait, melynek segítségével megtudjuk az ablak méretét.
            Ezután létrehozunk változókat, melyekben a lépésközt, a pozíciót, és az ablak méretét fogjuk eltárolni.
            <programlisting language="c"><![CDATA[
                int x = 0; //aktuális pozíció x-tengelyen
                int y = 0; //aktuális pozíció y-tengelyen

                int xnov = 1; //lépésköz az x-tengelyen
                int ynov = 1; //lépésköz az y-tengelyen

                int mx; //ebben lesz eltárolva az ablak szélessége
                int my; //ebben pedig az ablak magassága
            ]]>
            </programlisting>
            Ezután létrehozunk egy végtelen ciklust a már megszokott módon:
            <programlisting language="c"><![CDATA[
                for (;;)
                {
                }
            ]]>
            </programlisting>
            És ebbe a végtelen ciklusba fogjuk "pattogtatni" a labdát. Ehhez elsőnek meghívjuk a getmaxyx() függvényt melynek átadjuk paraméterként a az ablakban eltárolt értékeket, és azt, hogy meylik
            változóba tárolja el az ablak hosszúságát és szélességét. És az mvprintw() függvény fogja az általunk megadott koordinátákba a karaktert "mozgatni".
            <programlisting language="c"><![CDATA[
                getmaxyx ( ablak, my , mx );
                mvprintw ( y, x, "O" );
            ]]>
            </programlisting>
            Mostmár tudjuk az ablak méretét. Az x és az y változót folyamatosan 1-el növelve a karakter el kezd mozogni a terminálban. Azt, hogy ez milyen gyorsan történjen, azt a usleep() függvénnyel
            tudjuk beállítani. A usleep mikroszekundumba számol, tehát az másodperc egymiliomod részében. Ha azt akarjuk, hogy a labda másodpercenként menjen 1-et, akkor 1000000-et kell beírnunk a usleep-be.
            Így:
            <programlisting language="c"><![CDATA[
                usleep(1000000);
            ]]>
            </programlisting>
            Most, hogy a labda már mozog, már csak meg kéne állnia az ablak határainál.
            Ezt pedig if-el fogjuk elsősorban megoldani.
            <programlisting language="c"><![CDATA[
                if ( x>=mx-1 ) { // elerte-e a jobb oldalt?
                xnov = xnov * -1;
                }
                if ( x<=0 ) { // elerte-e a bal oldalt?
                        xnov = xnov * -1;
                }
                if ( y<=0 ) { // elerte-e a tetejet?
                        ynov = ynov * -1;
                }
                if ( y>=my-1 ) { // elerte-e a aljat?
                        ynov = ynov * -1;
                }
            ]]>
            </programlisting>
            Tehát, ha a labda eléri valamelyik szélét az ablaknak, akkor a lépésközt megszorozzuk -1-el, így elérve, hogy visszapattanjon.
        </para>
        <para>
            Egy másik megoldás is létezik ehhez, mégpedig az, ahol nem használunk if-et. Ennél a for-cikluson belül a következőt írjuk:
            <programlisting language="c"><![CDATA[
                getmaxyx(ablak, my, mx);
                xj = (xj - 1) % mx;
                xk = (xk + 1) % mx;

                yj = (yj - 1) % my;
                yk = (yk + 1) % my;

                //clear ();

                mvprintw (abs (yj + (my - yk)),
                  abs (xj + (mx - xk)), "X");

                refresh ();
                usleep (150000);
            ]]>
            </programlisting>
            Jelenleg ehhez további magyarázatot nem tudok fűzni, mivel nem igazán értem, de majd pótlom ezt a hiányosságot.
        </para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... 
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A Monty HAll probléma lényege a következő. Van 3 ajtó, az egyik mögött van a nyeremény, a többi mögött semmi. A játékos választ egyet a 3 ajtó közül, majd a játékmester kinyit egy olyan
            ajtót, amit a játékos nem választott, és nincs mögötte semmi. Ezután megkérdezi a játékost, hogy szeretne-e változtatni a döntésén, vagy marad az általa elsőnek kiszemelt ajtónál. Kérdés az, hogy megéri-e váltania?
            Ahogy a belinkelt videóban is láthattad ez még a legjobb matematikusoknak is fejfájést okozott. Tehát a válsz, a mindenkit foglalkoztató kérdésre az, hogy igen, megéri váltani.
        </para>
        <para>
            Ennek oka nagyon egyszerű. Az első tippednél 1/3 az esélye annak, hogy eltaláltad a helyes ajtót. Ekkor ha váltasz, akkor buksz, ha maradsz a döntésednél, akkor viszont nyersz. De tegyük
            fel, hogy nem találtad el a megfelelő ajtót. Ebben az esetben te rámutatsz egy üres ajtóra, a játékmester kinyitja neked a másik üres ajtót. Tehát, ha ebben az esetben váltasz, akkor nyersz.
            Ennek az esély pedig 2/3-hoz. Hiszen 2/3 eséllyel tippelsz rosszul az elején. 
            Egy szemléltető ábra, a fent linkelt oldalról: <link xlink:href="https://m.blog.hu/bh/bhaxor/image/montyhall2.png">https://m.blog.hu/bh/bhaxor/image/montyhall2.png</link>.
        </para>
        <para>
            Ezt próbáljuk szimulálni egy R programban.
            <programlisting language= "R"><![CDATA[
                kiserletek_szama=10000000
                kiserlet = sample(1:3, kiserletek_szama, replace=T)
                jatekos = sample(1:3, kiserletek_szama, replace=T)
                musorvezeto=vector(length = kiserletek_szama)
            ]]>
            </programlisting>
            Első lépésben megadjuk, hogy mennyi legyen a kíssérletek száma. Ha ez meg volt, akkor véletlenszerűséget szimuláljuk a sample() függvénnyel. Ahogy látjátok ennek 3 argumentuma van, az első
            megadja, hogy mettől-meddig generáljon random számokat. Majd megadjuk, hogy háynszor tegye meg ezt, és a replace=T(rue) pedig azt engedi meg, hogy lehessen ismétlődés a számok között. Lényegében itt
            egy tömböt adunk a sample()-nek át, amit átrendez.
            Tehát a kísérletek tömbben tároljuk, hogy az egyes esetekben hol van a nyeremény, a jatekos tömbben a játékos tippjeit. A műsorvezető változó pedig szintén egy tömb/vektor, melynek jelenleg csak a méretét adjuk meg, mivel
            az ő döntése függ a játékosétól és a nyeremény helyétől is.   
            <programlisting language="R"><![CDATA[
                for (i in 1:kiserletek_szama) {

                    if(kiserlet[i]==jatekos[i]){
    
                        mibol=setdiff(c(1,2,3), kiserlet[i])
    
                    }else{
    
                        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
                    }

                    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

                }]]>   
            </programlisting>
            A for ciklusban az i változót futtajuk 1-től a kísérletek számáig. Két esetet kell szétbontani itt, a játékos elatlálta a megfelelő ajtót, vagy sem. Ezt vizsgáljuk az if-ben. Tehát, ha az
            a kiserlet tömb első elem és a jatekos tömb első elem megegyezik, akkor a játékvezető csak azt az egy ajtót nem választhatja. A mibol tömbben, pont ezt tároljuk el. Ehhez a setdiff() függvényt használjuk
            ,mely a megadott tömbből kiveszi a kiserlet tömb első elemével megegyző értéket. Ugyen ez történik az else ágon is, csak ott mind a kiserlet, mind a jatekos tömb első elemét ki kell vonni a meagdott 
            tömbből. Ez alapján pedig fel tudjuk tölteni a musorvezeto vektort a megfelelő értékekkel, ehhez megint a sample() függyvényt használjuk.
            <programlisting language="R"><![CDATA[
                nemvaltoztatesnyer= which(kiserlet==jatekos)
                valtoztat=vector(length = kiserletek_szama)
             ]]>
            </programlisting>
            A nemvaltozatesnyer vektorba a which() függvénnyel betöltjük azon elemek indexét melyek a a kiserlet és a jatekos tömben azonos pozícióban vannak, és megegyeznek. Ezután létrehozzuk a
            valtoztat vektort, melynek mérete megyegyezik a kísérletek számával.
            <programlisting language="R"><![CDATA[
                for (i in 1:kiserletek_szama) {

                    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
                    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
                }
                valtoztatesnyer = which(kiserlet==valtoztat)             
            ]]>
            </programlisting>
            A for cikkluson belül feltöltjük a valtoztat vektort minden esetben azzal az ajtóval amire a játékos muatat, ha újra választ. Ezutána a vvaltoztatesnyer vektorbe betöltjük azonak az elemeknek
            az indexét, melyeknek az értéke megegyezik mind a kiserlet, mind a valtoztat tömbben. Ha ezzel megvagyunk, már csak ki kell print-elni a valtoztatesnyer és a nemvaltoztatesnyer vektorok hosszát, és
            ezzel megtudjuk, hogy melyik lesz a nagyobb. Természetesen az előbbi, ahogy már azt említettem.
            <programlisting language="R"><![CDATA[
                
            ]]>
            </programlisting>
        </para>
    </section>

</chapter>                
