<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Kernighan!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Pici könyv</title>
        <para>
            <emphasis role="strong">Alapfogalmak</emphasis>
        </para>
        <para>
            Ha a számítógépek programozási nyelveiről beszélünk, akkor
            fontos említést tenni róla, hogy milyen szintekre tudjuk őket
            osztani. Az első a gépi nyelv, mely lényegében 0-kból és 1-kből
            álló bináris kód. Ezt követi az assembly szintű nyelv, amely már egy
            kicsit közelebb van az emberi nyelvekhez, de még alacsony szintű
            programozási nyelvnek minősül. Legvégül pedig tegyünk említést a
            könyv fő témájáról a magas szintű programozási nyelvekről. Ezek
            már közel állnak az emberek által is értelmezhető nyelvekhez, főleg
            az angolra épülneké. 
        </para>
        <para>
            A magas szintű programozási nyelven írt programot forrásprogramnak
            nevezzük. Ennek az előállításához be kell tartani bizonyos az 
            adott nyelvre jellemző formai,szintaktikai szabályokat és a tartalmi,
            szemantikai szabályokat.
        </para>
        <para>
            A processzorok saját gépi nyelvvel rendelkeznek, és csak az ezen a
            nyelven írt programokat képesek végrehajtani. Tehát a forráskódokat
            át kell alakítani a gép által értelmezhető gépi kódra. Erre két
            analógia létezik, az egyik a fordítóprogramos megoldás, a másik
            az interpreteres.
        </para> 
        <para>
            A fordítóprogram egyetlen egységként kezeli a
            forrást, és lexikai, szintaktikai, szemantikai elemzést hajt
            végre, majd legenerálja a gépi kódot. Ez még nem futtatható, ebből
            a kapcsolatszerkesztő állít elé futtaható programot, melyet a betöltő
            behelyez a tárba, és a futtató rendszer felügyeli a futását. Bizonyos
            esetekben lehetőség van arra, hogy nem nyelvi elemeket használjunk
            egy forrásprogramban, de ilyenkor szükség van egy előfordítóra is.  
        </para>
        <para>
            Az interpreteres megoldás nem készít tárgykódot, viszont a fentebb
            említett 3 elemzést végrehajtja. Utasításonként sorra veszi a
            forrásprogramot, értelmezi, és végrehajtja. tehát rögtön kapjuk meg
            eredményt. Bizoynos nyelvek esetén mind az interpreteres, mind a
            fordítóprogramos megoldást alkalmazzák.
        </para>
        <para>
            Minden programozási nyelvhez tartozik egy hivatkozási nyelv, mely a
            szemantikai és szintaktikai szabályokat határozza meg. Emellett
            léteznek még implementációk. Az egyes rendszereken több fordítóprogram
            és iterpreter létezik, és ennek következtében az implementációk
            nem kompatiblisek egymással, ez pedig meggátolja a programok tökéletes
            hordozását a platformok között.
        </para>
        <para>
            A programozó dolgának megkönnyítése érdekében létrejöttek az 
            integrált grafikus felületek(IDE), melyek egy csomagban tartalmaznak
            minden szükséges eszközt a programok megírásához, és futtatásához.
        </para>
        <para>
            <emphasis role="strong">A programnyelvek osztályozása</emphasis>
        </para>
        <para>
            Összeségében 2 fő csoportra oszthatjuk a programozási nyelveket:az 
            imperatív nyelvekre és a deklaratív nyelvekre.
        </para>
        <para>
            Az imperatív nyelvek algoritmikus nyelvek, tehát a programozó maga 
            kódolja le az algoritmust, amit a processzor majd végrehajt. A program
            utasításokból épül fel. Legfőbb eszköz a változó, mely segítségével
            el tudunk érni tárterületet, és tudjuk módosítani annak tartalmát.
            Jelen esetben az algoritmusok teszik ezt. Az imperatív nyelveknek
            2 alcsoportja van: az Eljárásorientált nyelvek és az Objektumorientált
            nyelvek. 
        </para>
        <para>
            Ezzel szemben a deklaratív nyelvek nem algoritmikusak, a programozó
            csak felvázolja a problémát, és a nyelvi implementációkban be van 
            építve a megoldás megkeresésének módja. Memóriaműveltekre
            nincs lehetőség, vagy nagyon korlátozott módon. Ennek is 2 alcsoportja
            van: a Funkcionális nyelvek és a Logikai nyelvek.
        </para>
        <para>
            Léteznek olyan nyelvek is, amelyek nem sorolhatóak be egyik osztályba
            sem, nincs egységes jellemzőjük. Általában az imperatív nyelv valamelyik
            tulajdonságát tagadják.
        </para>
        <para>
            <emphasis role="strong">Karakterkészlet</emphasis>
        </para>
        <para>
            A programok legkisebb épitőelemei a karakterek. A forrásszöveg
            írásakor alapvető a karakterkészlet ismerete, mivel csak ezek
            jelenhetnek meg a kódban, és belőlük állítható elő összetett
            nyelvi elem. Az eljárásorientált nyelvek lexikális, szintaktikai 
            egységek, utasítások, programegységek, fordítási egységek
            és végül maga a program épül fel a nyelvi elemekből.
        </para>
        <para>
            Minden nyelv definiálja a saját karakterkészletét, de a lgetöbb
            programnyelv a karaktereket 3 kategóriába sorolja: betűk, számok,
            egyéb karakterek. A legtöbb nyelvben a betűk az angol ABC 26 betűjét
            tartalmazzák, viszont az már nyelv függő, hogy értelmezve van-e a nagy
            és kis betű, vagy különbséget tezs a kettő között. Egyes újabb nyelvek
            már nemzetisági betűket is tartalmaznak, ennek következtében
            "magyarul" is programozhatunk. A számokat nagyjából mindegyik
            nyelv hasonlóan kezeli, a decimális számjegyeket veszik számokjegy
            karakternek. Egyéb karakterek közé soroljuka műveleti jeleket(+,-,*,/),
            elhatároló jeleket([,],., {, },;), írásjeleket és speciális
            karaktereket. A hivatkozási nyelv és az implementáció karakterkészlete
            egyes esetekben eltérő lehet.
        </para>
        <para>
            <emphasis role="strong">Lexikális egységek</emphasis>
        </para>
        <para>
            A lexikális egységek azok, amelyeket a fordítóprogram felismer, és 
            tokenizál. Lehetnek többkarakteres szimbólumok, szimbolikus nevek,
            cimkék, megjegyzések, literálok.
        </para>
        <para>
            Többkarakteres szimbólumoknak a nyelv tulajdonít jelentést, gyakran
            operátorok vagy elhatárolók, mint C-ben a ++,--,<![CDATA[&&]]>.
        </para>
        <para>
            Szimbolikus neveket 3 csoportra bontjuk, az azonosítókra, a
            kulcsszóra és a standard azonosítóra.
            Az azonosító betűvel kezdődik és betűvel vagy számmal folytatódik, 
            segítségével programozói eszközöket nevezünk meg, és ezzel a névvel
            tudunk rájuk hivatkozni a programon belül.
            A kulcsszónak az adott nyelv tulajdonít jelentést, ez nem
            változtatható meg. C-ben iylenek az if, for, case, break.
            A standard azonosító pedi egy kicsit mind a kettő, mivel ezt is az 
            adott nyelv látja el jelentéssel, de a programozó megváltoztathatja.
            C-ben sztenderd azonisítónak számit a NULL.
        </para>
        <para>
            A címkéknek főleg az eljárásorientált nyelvekben van nagy jelentősége
            ,mivel a segítségével képesek vagyunk megjelölni a végrehajtó
            utasításokat, így tudunk rájuk hivatkozni a program más részein.
        </para>
        <para>
            A megjegyzések szerepe az évek során eléggé megkopott, de természetesen
            minden nyelv biztosít lehetőséget kommentek hozzáadásához. A komment
            lényegében egy karaktersorozat, amelyet a fordító ignorál. Több 
            implementáció létezik a kommentek alakalmazására, lehet teljes
            komment sorokat elhelyezni, vagy sor végi kommenteket, de lehetőség
            van több soros, egybefüggő kommentek elhelyezésére is. A C-ben mind
            a 3-ra van lehetőség. (Egysoros komment://, többsoros: /* */) 
        </para>
        <para>
            Végezetül tegyünk említést a literálokról is, mely programozási eszközök
            segítségével fix értékek építhetők be a programba. A literáloknak van
            típusuk és értékük. A literálrendszerek egyes programozási nyelvekben
            eltérő lehet.
        </para>
        <para>
            <emphasis role="strong">Adattípusok</emphasis>
        </para>
        <para>
            Az adattípus egy absztrakt programozási eszköz,mely kronkrét eszközök
            komponenseként jelenik meg. Mindig rendelkezik egy névvel, ami azonosító.
            Nem minden nyelv ismeri ezt, azt eszközt, főleg az eljárásorientált
            nyelvekben van fontos szerepe. Az adattípust a tartomány, a műveletek
            és a reprezentáció határoz meg.
        </para>
        <para>
            A tartomány az adattípus által felvehető értékek halmazát adja meg.
            Mindegyikhez hozzátartoznak műveletek, amit az adott típussal végre
            tudunk hajtani. A reprezentáció pedig a beslő ábrázolást írja le,
            vagyis a tárban a típus hány bájtra képződik.
        </para>
        <para>
            Bizonyos nyelvek lehetőséget biztosítanak arra, hogy a programozó
            saját adattípusokat adjon meg, mindezt általában a beépített 
            típusok segítségével. Meg tudjuk adni a tartományt, a műveleteket, és
            a reprezentációt is. Viszont ezt nagyon kevés nyelv támogatja.
        </para>
        <para>
            Az adattípusokat 2 nagy csoportra osztjuk: skalár adattípus és
            összetett adattípus.
        </para>
        <para>
            A <emphasis role="strong">saklár</emphasis> típus tartománya atomi
            értékeket tartmaz. Skalár típus a 
            minden nyelvben létező egész, melynek belső ábrázolása fixpontos.
            Vannak még a valós típusok, ezek reprezentációja lebegőpontos,
            tartománya implementációfüggő. Ezt a két típust együtt numerikus
            típusoknak nevezzük, melyeken numerikus és összehasonlító műveletek
            hajthatók végre.
        </para>
        <para>
            A karakteres típus elemei karakterek, míg 
            karakterlánc típuséi karaktersorozatok. Ezeken szöveges és hasonlító
            műveleteket hajthatunk végre. Ábrázolásuk karakteres.
        </para>
        <para>
            Bizonyos nyelvek támogatják a logikia típusokat is, melyek értéke igaz
            vagy hamis lehet, logikai és hasonlító műveleteket tudunk velük
            végrehajtani.
        </para>
        <para>
            Érdekességként meg lehet említeni a felsorolás típust vagy a sorszámozott
            típust, de ezek kevésbé elterjedtek, csak néhány nyelvben fordulnak elő.
        </para>
        <para>
            Az <emphasis role="strong">összetett típusok</emphasis> közül a két
            legfontosabb a tömb és a rekord. A tömb homogén, statikus összett típus,
            meghatározzák a dimenzóinak száma, az indexkészletének típusa és tartománya,
            és az eleminek a típusa. Léteznek több dimenziós tömbök, melyeket
            lehet oszlopfolytonosan vagy sorfolytonosan ábrázolni. A tömb elemeit
            indexek segítségével tudjuk bejárni.
        </para>
        <para>
            A rekord típus heterogén, tartományában különböző típusok szereplehetnek.
            Az egyes elemeket mezőknek nevezzük, melyeknek van saját neve és típusa.
            A mezőneveket minősített nevekkel tudjuk ellátni, ezzel segítve az azonos 
            nevű mezők megkülönböztetését.
        </para>
        <para>
            A <emphasis role = "strong">mutató típus</emphasis> egyszerű típus,
            de érdekessége az, hogy tartomány tárcímekből áll. Segítségével indirekt
            módon el tudjuk érni a mutatott elem értékét. Fontos a szerepe az
            absztrakt adatszerkezetek szétszórt reprezentációjában.
        </para>
        <para>
            <emphasis role="strong">Nevesített konstans</emphasis>
        </para>
        <para>
            3 komponensből áll: név, típus, érték.
            Mindig deklarálni kell, mely során megkapja az értékét, és azt 
            nem lehet módosítani a futás folyamán. A nevével tudunk hivatkozni az
            értékkomponensére. Ennek köszönhetően, elég a deklarációnál
            ,módosítani az értéket, és nem kell minden egyes előfordulásnál.
            C-ben ezt a következőképpen használjuk:
            <programlisting language="c"># define név literál</programlisting>
            Ez az előfordítónak szól, és a név minden előfordulását helyettesíti
            a literállal.
        </para>
        <para>
            <emphasis role="strong">Változó</emphasis>
        </para>
        <para>
            4 komponensből áll: név, attríbútum, cím, érték. A név egy azonosító, a
            programban a változó mindig a nevével jelenik meg. Attribútumnak olyan
            jellemzőket nevezünk, amik befolyásolják a változó viselkedést. Attribútum
            például a változó típusa, mely a deklaráció során rendelődik a változóhoz.
        </para>
        <para>
            Létezik explicit deklaráció, implicit deklaráció és automatikus deklaráció.
            Az explicit deklaráció a véltozó nevéhez rendel attribútumot, míg az implicit
            betűkhöz. Pl. megoldható, hogy az azonos kezdőbetűvel rendelkező 
            változók azonos attribútumúak lesznek. Az automatikus pedig azt jelenti,
            hogy a fordítóprogram rendel attribútumot a változóhoz, ha az még nem volt
            deklarálva.
        </para>
        <para>
            A változó címkomponense határozza meg a változó helyét a tárban. Egy változó
            élettartamának a futási idő zon részét nevezzük, ameddig a változó rendelkezik
            címkomponenssel. A címet lehet statikus vagy dinamikus tárkiosztással rendelni
            változóhoz. Létezik még programozó által vezérelt tárkiosztás is, a futási
            időben a programozó rendel címkomponenst a változóhoz.
        </para>
        <para>
            A változó értékkomponense bitkombinációként jelenik meg a címen, melynek
            felépítését a típus határozza meg. A változónak értéket értékadó utasítással
            tudunk adni, mely a C-ben így néz ki:
            <programlisting language="c">változónév = kifejezés;</programlisting>
        </para>
        <para>
            <emphasis role="strong">Alapelemek C-ben</emphasis>
        </para>
        <para>
            A C tipusrendszere 3 részre bontható, vannak az aritmetikai típusok,
            a származtatott típusok és a void típus. Az aritmetikai típusok közé tartoznak az
            egészek, a karakter, a felsorolás, a valósok. A származtatott típusok a tömb, a függvény
            mutató, struktúra, union.
        </para>
        <para>
            <emphasis role="strong">Az aritmetikai típusok egyszerű, mig a származtatottak
            összetett típusok.</emphasis>. Az előbbivel aritmetikai műveletek végezhetőek.
            Logikai típus nincs, az <function>int 0</function> felel meg hamisnak, az összes
            többi érték igaz értékkel rendelkezik. A logikai műveletek <function>int 1</function>-et
            adnak  vissza igaz esetén. A egsészek és karakterek előtt használható 
            <function>unsigned/signed</function> típusminősítők segítségével
            tudjuk beállítani vagy letiltani az előjeles ábrázolást. A struktúra fix
            szerkezetű rekord, ezzel szemben a union, csak változó részt tartalmazó rekord.
            A void típus tartomány üres, tehát nincs reprezentációja, sem műveletei.    
        </para>
        <para>
            <emphasis role="strong">Utasítások</emphasis>
        </para>
        <para>
            Az utasítások segítségével tudjuk megadni az algoritmusok egyes lépéseit,
            és a fordítóprogramok ezek segítségével hozzák létre a tárgykódot.
            2 csoportra oszthatjuk őket: deklarációs és végrehajtó utasítások.
            A deklarációs utasítások kifejezetten a fordítóprogramnak szólnak,
            mögöttük nem áll tárgykód. Összességében a tárgykódot befolyásolják, de
            nem fordulnak le. A végrehajtó utasítások összességéből áll
            Ezekből többféle létezik, melyeket most sorraveszünk.
        </para>
        <para>
            Az <emphasis role="strong">értékadó</emphasis> utasítások beállítják
            vagy módosítják az egyes változók értkét.
        </para>
        <para>
            Az <emphasis role="strong">üres</emphasis> utasítások az eljárásorientált
            nyelvekre jellemzőek. De vannak olyan nyelvek, ahol hasunálatuk nélkülözhetetlen.
            Hatására a processzor egy üres gépi utasítást hajt végre.  
        </para>
        <para>
            Régebbi programnyelvek előszeretettel alkazmaták az <emphasis role="strong">
                                                                    ugró
            </emphasis> utasítást. De ezt manapság már nem használják, mivel
            felelőtlen alkalmazása értelmezhetetlen kódot eredeményez. 
            Alakja: <function> GOTO címke</function>. Lényegében
            az adott címkével ellátott utasításra/utasítás csoportra 
            adhatjuk át a vezérlést. 
        </para>
        <para>
            Az <emphasis role="strong">elágaztató</emphasis> utasítások 
            két csoportra oszthatjuk, a kétirányú és a többirányú
            elágaztatásra. A kétirányú alatt igaz/hamis feltételt kell érteni.
            Van egy fejrész, abban tároljuk a feltételt, ami teljesülése
            esetén végrehajtjuk hozzá tartozó utasításokat. Lehet még 
            else ágat is használni, ahova akkor igrik a vezérlés, ha a 
            feltétel nem teljesül. Ha egyszerre több utasítást kakrunk végrehajtani,
            akkor a kapcsos zárójellel tudjuk összekapcsolni őket, mely így egy utasításnak
            számít. Alakja: <function>if feltetel then tevekenyseg [else tevekenyseg]</function>
            Ha van else ág is, akkor hosszú IF-utasításról beszélünk, ellenkező
            esetben rövidről. Lehetőségünk van egymásba ágyazni több IF-utasítást
            , de ekkor értelmezésbeli problémák adódhatnak, mivel nem egyértelmű, hogy
            az else ág, melyik if-hez tartozik. Általában a belülről kifelé haladó
            kiértékelés az elterjedt, szóval mindig az else-hez "legközelebbi"
            if-hez tartozik.
        </para>
        <para>
            Ezzel szemben a többirányú utasítás esetén több egymást kizáró
            tevékenység közül egyet választunk ki, ha a fejrészben lévő
            kifejezés megegyezik az konsatnsok valamelyikével. A konstansokhoz
            rendelünk tevékenységeket, melyeket végrehajtuk az előbb említett esetben.
            Ez C-ben általában a következő alakú:
            <function>switch kifejezés case1: tevékenység default: tevekenyseg</function>
            Több <function>case</function>-t is használhatunk, és a végére, ha egyik
            case se teljesülne, akkor használhatunk default tevékenységet, amit
            végrehajtunk ilyenkor.
        </para>
        <para>
            Vannak még <emphasis role="strong">ciklusvezérlő</emphasis>
            utasítások, melyek segítségével utasításokat tudunk megismételni.
            Általános felépítése fejből, meagból és végből áll. A mag tartalmazza
            a végrehajtandó utasításokat, a fej vagy a vég pedig a ismétlést
            meghatározó információk helye. Két véglet az üres ciklus és a
            végtelen ciklus. Míg az előbbi nem hajt végre semmit, addig az
            utóbbi végtelenségig ismétlődik. Ezektől eltekintve létezik feltételes,
            előírt lépésszámú és felsorolásos.
        </para>
        <para>
            A feltételes ciklus a feltétel igaz/hamis volta alapján
            hajt végre utasításokat. A feltétel lehet a fejrészben, vagy a végrészben.
            Az előbbi eset C-ben a <function>while</function>, mely esetén addig oismétlődik a cilus,
            ameddig a feltétel igaz, utána befejeződik. Utóbbi eset a <function>do while</function>, mely
            egyszer mindenképpen végrahajtja a ciklusmagot, és utána teszteli a
            feltételt, ha hamis, akkor kilépünk a cilusból.
        </para>
        <para>
            Az előírt lépésszámú ciklus, lényegében a ciklus fejrészében megadott
            számban ismétli az utasításokat. Ehhez szükség van egy ciklus változóra,
            melyet addig léptetünk, ameddig a feltétel igaz, majd kilépünk. Egyes
            nyelvek engedélyezik a cilusváltozó deklarálásáét a fejben, másoknál
            (C-ben), a ciklus előtt kell deklarálni. A lépésközt is tudjuk állítnai,
            illetve azt is, hogy csökkenően, vagy növekvően haladjunk a ciklusban.
            Ezt a ciklusfajtát nevezzük <function>for</function> ciklusnak.
        </para>
        <para>
            Felsorolásos ciklus az előbbi ciklus egy általánosítása. A ciklusváltozó
            és az értékek megadása a fejben törrténik. A cilus minden egyes értékre lefut.
            A ciklusváltozó típusa szabadon válaztható, viszont ez a ciklus fajta nem lehet
            se üres, se végtelen.
        </para>
        <para>
            Végtelenb ciklus esetén sem a fej, sem a vég nem tartalmaz információkat
            arról, hogy mikor kéne befejeződnie a cilusnak. Ezeknél általában a magban
            adunk meg valamilyen utasítást, amely kiugratja a vezérlést a ciklusból.
            Használata eseményvezérelt alkalmazásoknál jön jól.
        </para>
        <para>
            Az összetett ciklusok pedig az eddig felsorolt cilusokból épülnek fel.
            A cilusfejükben tetszőleges mennyíségű információt tárolhatunk el
            az ismétlődésre vonatkozóan.
        </para>
        <para>
            Ahogy már a végtelen ciklusnál említettem, vannak utasítások, amik segítségével
            a cilusok működését befolyásolhatjuk. Ezeket nevezzük
            <emphasis role="strong">cilusszervező</emphasis> utasításoknak.
        </para>
        <para>
            <emphasis role="strong">Programok szerkezete</emphasis>
        </para>
        <para>
            A program forrását programegységekre tudjuk osztani. Vannak nyelvek,
            ahol ezek teljesen függetlenek egymástól, másoknál egyetlen egységként
            kell lefordítani az egészet, de léteznek olyanok is, amelyek ezt a kettőt
            kombinálják. Tehát bizonyos programegységek öszetettek, bizonyosak pedig szimplák.
            Az eljárásorientált nyelvek 4 programegységből állnak. Van egy alprogram, egy blokk
            egy csomag és egy taszk. Az alprogramnak az a lényege, hogyha egy 
            programrész többször ismétlődik, akkor ezt külön megírjuk, és csak 
            hivatkozunk rá. Két fő típusa van az alprogramoknak: eljárás és függvény.
            Az eljárás a paraméterként átadott elemekkel végrahajt valmilyen utasítást, viszont
            nem tér vissza semmilyen értékkel, ellentétben a függvénnyel. A függvénynél
            a visszatérési érték típusát a függvény nevével együtt adjuk meg, ha nem 
            adunk meg visszatérési értéket a függvény végén, akkor szintajktiai hibát kapunk. 
            Ha az egyes programegységek újabb és újabb programegységet hívnak
            meg, akkor alakul ki a hívási lánc. Bizonyos esetekben egy programegység önmagát
            is hívhatja, ezt nevezzük rekurzív hívásnak. Bizoynos nyelvek támogatják a
            törzsben szereplő alprogramokat is, ezeket másodlagos belépési ponttal oldja meg. 
            A blokk egy programegység, mely önállóan nem állhat, csak egy másik
            programegység belsejében. Fromálisan 3 részből áll: kezdet, törzs, vég. 
            A kezdetet és véget C-ben kapcsoszárójellel jelöljük, nem tartozik hozzá név. 
            A törzsben szerepelhet bármilyen utasítás. A vezérlés vagy szekvenciálisan kerül
            a blokkra, vagy egy GOTO utasítással mi ugratjuk rá.  
        </para>
        <para>
            <emphasis role="strong">Paraméterkiértékelés, paraméterátadás</emphasis>
        </para>
        <para>
            A paraméterkiértékelés az alprogram híváskor egymáshoz rendeli a formális és
            aktuális paraméter listát. Formális paraméter listából mindig csak egy van, melyet
            az alprogram specifikációja tartalmaz, viszont aktuálisból annyi létezik, ahány
            függvényhívás. Mindig a formálishoz rendeljük az aktuálist, de ennek megvalósítása
            többféleképpen lehetséges. Lehet sorrend szerint, tehát elsőt az elsővel és így tovább,
            vagy név szerint is. Ezt úgy kell elképzelni, hogy az aktuális paraméter listában
            meg tudjuk adni, hogy a formális paraméter lista melyik eleméhez mit rendelünk. 
            Az is eltérő lehet, hogy hány paramétert kell megadni. Ezt mindig a formális paraméter
            lista határozza meg, vagyis ha fix számú, akkor az aktuálisnak is annyit kell tartalmaznia,
            vagy lehet kevesebb is, de ez kizárólag érték szerinti paraméterátadás esetén lehetséges.
            Ha a formális paraméter lista tetszőleges  méretű, akkor az aktuális is. Nyelvenként eltérő
            annak a kezelése, ha az aktuális paraméter lista elemei nem egyeznek meg a 
            formálisban lévő paraméterek típusával. Ilyenkor vagy hibát kapunk, vagy egyes nyelveknél
            a típuskényszerítést alkalmazzák.  A paraméterátadásának 6 módja van. Az első, a már
            említett érték szerinti paraméterátadás. Ebben az esetben a formális paramétereknek
            van címkomponensük az alprogram területén. Az átadot érték lemásolódik, ezzel 
            dolgozik tovább az alprogram. Ennek a gyengesége a másolás, mely bizonyos adatszerkezetek
            esetén sok időbe telhet, és sok helyet foglal. A cím szerinti paraméterátadás 
            esetén a formális paramétereknek nincs külön címkomponense, hanem az alprogram a 
            hívó területén dolgozik. Ebben az esetben az alprogram olvashat és írhat is értékeket
            a hívó területén. Az eredmény szerinti paraméterátadás abban tér el ettől, hogy
            az alprogram a saját területén dolgozik, míg be nem fejezi a feladatát, ezután pedig a 
            hívó területére kiírja az eredményt. Az érték-eredmény szerinti átadás ezt gondolja tovább.
            Itt már azv értéket is átadjuk a cím mellett, az alprogram az átadott értékkel végrahajtódik
            a saját területén, majd pedig az eredményt kiírja a hívó memóriaterületére. Létezik még 
            név szerinti átadás is, ahol a paramáter egy szimbólum. Ekkor az alprogram
            formális paraméterének minden előfordulása átíródik a megadott szimbólumra, és az 
            alprogram végrehajtódik. A szöveg szerinti abban különbözik, hogy az átírás csak az 
            alprogram futásának megkezdése után, az első előfordulástól kezdve hajtódik végre.
        </para>
        <para>
            <emphasis role="strong">Hatáskör</emphasis>
        </para>
        <para>
            A hátáskör, vagy láthatóság a programban előforduló nevekhez kapcsolódó
            fogalom. Egy név hatókörének azt programrészt nevezzük, ahol ugyan azt 
            a programozási eszközt hivatkozza. A programegységekben deklarált nevek
            lokális nevek, azokon kívül deklaráltak pedig szabad nevek. A 
            hatókörkezelésnek két ismert megvalósítása van, az egyik a statikus, 
            a másik a dinamikus. Az eljáráorientált nnyelvek a statikus verziót
            használják. A statikus megoldás lényege, hogy minden név hatóköre
            az adott programegységig terjed, ahol deklarálták. Ebbe beletartoznak
            a beágyazott programegységek is. Fontos kikötés, hogyha az egyik 
            beágyazott programegység úradeklarálja a nevet, akkor már nem érhető
            el ott. A dinamikus hatókörkezelés is hasonló ehhez, azzal a különbséggel,
            hogy a név hatóköre kiterjed azokra a programegységekre amik a 
            saját programegysége után vannak a hívási láncban, hacsak ott nem
            deklarálják újra. 
        </para>
    </section>        
    <section>
        <title><![CDATA[K&R könyv]]></title>
        <para>
            <emphasis role="strong">Vezérlési szerkezetek</emphasis>
        </para>
        <para>
            A C nyelvben létező vezérlésátadó utasítások segítségével vagyunk képesek
            meghatározni a számítások sorrendjét. Lássuk a C leggyakoribb vezérlésátadó
            utasításait.
        </para>
        <para>
            Elsőként említsük a <emphasis role="strong">utasításokat és blokkokat</emphasis>.
            Az egyes kifejezések akkor válnak utasítássá, ha utánuk rakunk egy pontosvesszőt,
            ezzel jelezzük az utasítás végét. Képesek vagyunk az utasításokat blokkba foglalni,
            melyet a <function>{}</function>-jel segítségével tudjuk megtenni. Ezt a 
            jelülést használjuk a függvénye definíciójánál, a <function>for</function>,
            <function>while</function>, <function>if</function> utasítás által
            végrehajtott utasítsákok csoportosításra. Fontos, hogy ha kapcsoszárójelet
            használunk, akkor utána tilos pontovesszőt rakni.
            <programlisting><![CDATA[
                int a;
                for (a = 0; a < 5; a++)
                {
                    /*utasítások*/
                 }]]>
            </programlisting>
        </para>
        <para>
            Ha valamit el szeretnénk dönteni a programunkban, akkor jön nagyon jól
            az <emphasis role = "strong">if-else</emphasis> utasítás. A fejlécben 
            mindig megadunk egy kifejezést, mely alapján eldöntjük, hogy egy utasítás végre
            legyen-e hajtva, vagy sem. Az else ágra nem feltétlenül van szükség, az akkor
            hajtódik végre, ha nem teljesül az if feltétele. Az if numerikus értéket viszgál
            ezért lehetőségünk van rövídíteni a kifejezést. Pl.:
            <programlisting>
                if (kifejezés)
                if (kifejezés != 0)
            </programlisting>
            A két leírás ekvivalens egymással, az első használata viszont néha nehezen
            érthetővé teszi a kódot. Az else ággal is lehetnek értelmezésbeli
            nehézségek, mivel nem mindig könnyű az egymásba skatulyázott if-ek közül
            eldönteni, hogy melyikhez tartozik az else ág. C nyelben ez úgy van megoldva, hogy
            mindig a hozzá legközelebbi if-hez tartozik. Az esetleges kétértelműségek
            elkerülése érdekében érdemes használnoi a kapcsos zárójeleket, melyel egyértelműen
            meghatározható az utasítás vége. De ha az if/else csak egy utasítást hajt végre, akkor
            nincs szükség a kapcsos zárójelre, elég a ; használta.
            <programlisting>
                if (kifejezés)
                {
                    /*több utasítás*/
                }
                if (kifejezés)
                    utasítás;
            </programlisting>
        </para>
        <para>
            Az if-else utasítás szorosan összefügg az 
            <emphasis role="strong">else-if utasítás</emphasis> haszbnálatával.
            Ennek a segítségével több elágazásos if utasítássorozatot hozhatunk
            létre. Ha az egyik if teljesül a sorozat többi tagja már nem, ha egyik
            se teljeül, akkor itt is az else ágra kerül a vezérlés, ami akár
            el is hagyható, ha a maradék esetben semmit sem kell csinálni.
            <programlisting>
                if (1.kifejezés)
                    1. utasítás;
                else if (2.kifejezés)
                    2. utasítás;
                else
                    3. utasítás;
            </programlisting>
        </para>
        <para>
            Az else-if utasítás kiváló arra, hogy pár esetet elkülönítsünk, de
            mi van akkor, ha több tíz darab eset van. Erre találták ki a
            <emphasis role = "strong">switch</emphasis> utzasítást, amely
            megvizsgálja, hogy a kifejezés megegyezik-e valamelyik esettel, és
            ahhoz az esethez továbbítja a vezérlést.
            <programlisting>
                switch(kifejezés){
                case '1.lehetőség':
                case '2.lehetőség':
                        1. utasítás;
                case '3.lehetőség':
                case '4.lehetőség':
                case '5.lehetőség':
                        2. utasítás;
                }
            </programlisting>
            Amint látod, nem muszály mindegyik esethez külön megadni az
            utasítást, lehet őket csoportosan megadni, ezzel megkönnyítve a 
            programozó dolgát. A switch magját pedig {} jellel határoljuk.
            A <function>case</function>-en kívül használhatunk
            <function>default</function> címkét is, amivel egy alapértelmezett
            utasítást adhatunk meg, arra az esetre ha egyik eset se teljesülne.
            Fontos a <function>case</function>-ek között nem fordulhat elő azonos.
            Ha egy <function>case</function> utasítása végrehajtódik
            akkor a vezérlés a következőre ugrik. Ez viszont nem mindig szerencsés,
            ezért <function>break</function>-et kell használni mindegyikesetén, de
            ha nem is rakunk mindegyikhez, akkor is az utolsó eset után érdemes 
            rakni egy <function>break</function>-et, ezzel biztosítva, hogy a
            vezérlés nem fog szétesni.  
        </para>
        <para>
            Ha a programozási nyelvek ciklusairól beszélünk van 2 alapvető,
            amelyik mindegyikben megjelenik, így C-ben is, ezek a
            <emphasis role = "strong">for és a while</emphasis> utasítások.
            Arra használjuk őket, hogy bizonyos utasításokat ismételjünk, egészen
            addig, ameddig a fejrészükben lévő kifejezés teljesül.
            <programlisting>
                while(kifejezés)
                    utasítás
            </programlisting>
            A while így néz ki zsintaktikailag, egészen addig hajtja végre az
            utasítást, ameddig a kifejezés nem nulla. Itt egy kifejezés van,
            ezzel szemben a for ciklus nyelvtanilag 3 kifejezésből áll.
            <programlisting>
                for(kif1;kif2;kif3)
                    utsítás
                
                /*ennek a while átírata*/
                
                kif1;
                while (kif2)
                    utasítás
                    kif3
            </programlisting>
            Amint látod, a két fajta ciklus átírható egymásba, de bizonyos esetkben
            az egyik könyebben használható mint a másik. A for ciklusnál nem muszály
            mindegyik kifejezést kiírni, sőt el is hahatóak, ekkor végtelen ciklushoz
            jutunk, amelyből vagy <function>break</function>, vagy
            <function>return</function> utsítással tudunk kiugrani. A fentebbi pédában
            láthattad, hogy a for kifejezései közé ; kellett rakni, de ez nem feltétlenül
            kötelező, csak akkor más értelemmel rendelkezik.
            <programlisting>
                int i, j;
                for (i = 0, j = 10; i!=j; ++i, --j)
                    pritnf("Még nem egyenlő");
            </programlisting>
            Ilyen esetben az i-t és az j-t is léptejük egyszerre. Az i és a j
            definiálása és az értékük változtatása is egy-egy kifejéznek
            felel meg.
        </para>
        <para>
            A for és a while cilusok a kiugrási feltétel teljesülését a 
            cilus elején viszgálja, de bizsinyis esetkben jól jöhet a 
            <emphasis role="strong">do-while</emphasis> utasítás. Lényege
            az, hogy legalább 1-szer biztos, hogy belépünk a ciklusba, ezután pedig
            a gép kiértékeli a kifejezést.
            <programlisting>
                do
                    utasítás
                while (kifejezés)
            </programlisting>
        </para>
        <para>
            Már többször szó esett a ciklusokból való kilépés módjáról, ezt 
            valósítja meg a <emphasis role ="strong">break</emphasis> utasítás.
            Az utasítás hatására a vezérlés kiugrik a legbelsőbb ciklusból 
            még az előtt, hogy a kifejezést kiértékeltük volna
            az újabb iterációban. 
        </para>
        <para>
            Ha van olyan utasítás, ami megállítja a ciklust, akkor lennie kell
            olaynnak a folytatja azt. Na nem pont ilyen értelemben, de hasonlót
            csinál a <emphasis role="strong">continue</emphasis> utasítás. Ez 
            azt jelenti, hogy a vezérélés visszatér a ciklus fejéhez, tehát 
            abban az iterációbn nem csinálunk semmit, csak továbblépünk. Ezt 
            általában valamilyen feltételhez szokták kötni.
            <programlisting><![CDATA[
                int i
                for (i = 0; i < 20; ++i)
                {
                    if (i%2 != 0) continue;
                    printf("%d", i);
                }]]>
            </programlisting>
            Ebben az esetben csak a páros számokat írjuk ki, a többi számot kihagyjuk.
        </para>
        <para>
            A függvények esetén a break-hez hasonló a <emphasis role="strong">
                return</emphasis> utasítás. Ez a függvény hívójához tér vissza,
                áltatlában valmilyen értékkel, de előfordulhat, például void
                típusú függvények esetén, hogy nem ad vissza semmilyen értéket.
                <programlisting>
                    return;
                    return kifejezés;
                </programlisting>
        </para>
        <para>
            Ahogy említettem a break utasítással mindig csak a legbelső 
            ciklusból tudunk kilépni, de mi van akkor, ha mi az egymásba
            skatulyázott ciklusokból, ekkor kerül előtérbe a
            <emphasis role="strong">goto</emphasis> utasítás.
            Szintaxisát tekintve:
            <programlisting>
                for (...)
                    for (...)
                        if (kifejezés)
                            goto megoldás;
                
                megoldás:
                    tedd hamissá a kifejezést
            </programlisting>
            Tehát egy címkére ugrunk, amit a goto utasítás után megnevezünk, és
            a címkének megadjuk, hogy milyen utasítást hajtson végre. A goto
            használata viszont abszolút nélkülözhető, és használata nem is javasolt.
        </para>
        <para>
            Az előző paragrafusban látott <function>megoldás</function> egy
            <emphasis role = "strong">címkézett utasítás</emphasis>, mely a goto
            célpontja. Érvényessége arra a függvényre szól, amelyben előfordul.
        </para>
        <para>
            A létezik még a <emphasis role="strong">nulla</emphasis> utasítás.
            Ezt a használhatjuk címkék hordozására öszzetett utasításokat 
            lezáró } előtt, vagy jelölhet üres ciklusmagot is.
        </para>
    </section>        
    <section>
        <title>BME C++ könyv</title>
        <para>
            <emphasis role="strong">C++ nem objektum-orientált újdonságai</emphasis>
        </para>
        <para>
            A C++ lényegében a C programozási nyelv objektum-orientált változata, melynek első változata 1983-ban jelent meg. A nyelv atyjának
            Bjarne Stroustrup-ot tekintjük, aki <![CDATA[AT&T Bell]]> Laboratories-nak dolgozott. Első verzió neve C with class, ezzel utalva
            az objektum-orientáltságra. A C++ 1998-ban lett szabványosítva, azóta szabványt is kiadtak, a 2003-ast és a 2011-est. A C++ programok
            érdekessége, hogy többségük lefordul a C frodítókkal, sőt kezdetben az első C++ fordítók C kódot generáltak. Tehát minden C program C++ program, de
            nem minden C++ program C program.   
        </para>
        <para>
            Ebben a fejezetben pont azokat a különbségeket fogjuk sorra venni, amik C++-ban használhatóak, de a C-ben nem. Itt olyan funkciókra kell gondolni, amik
            segítettek kijavítani a C nyelv esetleges gyengeségeit.  
        </para>
        <para>
            Az első lényegi különbség a függvényparaméterekben és  a visszatérési értékben rejlik. A C-ben, ha nem írtunk paramétert, akkor korlátlan számú
            paramétert használhattunk, ezzel szemben a C++-ban ez annyit jelent, hogy nincs paraméter, vagyis mintha a paraméternek void típust adtunk volna meg.
            Ahhoz, hogy a korlátlan számú paramétermegadást engedélyezzük C++-ban, a paraméterlistéba <function>...</function>-t kell beírni.
            <programlisting language="c">
                //C-ben
                void f()
                {
                }
                
                //C++-ban
                void f(...)
            </programlisting>
            Egy másik különbség, hogy a C nyelvben kihagyhatjuk a visszatérési érték típusának meghatározását, azt int-nek értelmezi. Ezzel szemben C++-ban fordítási hibát
            kapunk, nem szabad kihagyni a visszatérési érték típusának meghatározását.
            <programlisting language="c++">
                void f(void); //nincs hiba
                g(void); //fordítási hiba
            </programlisting>
        </para>
        <para>
            A másik különbség a main függvényben keresendő. Az argmentum listát hagyhatjuk üresen, vagy használhatjuk az argc, argv[] argumentumokat, mellyel a parancssori argumentumok számát
            és tömbjét adja át a main-nek. Ez eddig hasióonló a C-hez, de a main végére nem szükséges oda írni a <function>return</function>-t, azt a fordító automatikusan hozzáilleszti a kódhoz.
        </para>
        <para>
            Sokáig a C++ nyelv sajátja volt a <function>bool</function> típus, mellyel logikai változókat deklarálhatunk, értéke <function>true</function>
            és <function>false</function> lehet. Ez mát a C-ben is elérhető, de előtte csak az int vagy az enum típusokkal fejezhettük ezt ki. Int esetén 0 számít 
            hamisnak és minden más érték igaz.  
        </para>
        <para>
            A C++-ban megjelet  a <function>wchar_t</function>, mint beépített típus, mely segítségével Unicode karakter stringeket tudunk reprezentálni. Ez a C-ben
            is használható, viszont ehhez #include-olni kellett a bizonyos header fájlokat.  Az iylen típusú változókat a következőképpen definiálhatjuk:
            <programlisting language="c++">
                wchar_t = L 's';
                wchar_t* = L "sss";
            </programlisting>
        </para>
        <para>
            C++-ban a változókat olyan helyeken is deklarálhatjuk, ahova utasításokat is írhatunk. Ilyen például, hogy a <function>for</function> ciklus-ban tudjuk definiálni az indexet, nem kell
            azt előtte deklarálni. Ettől függetlenül elmondható, hogy a változókat érdemes pont ott deklarálni, ahol a szeretnénk használni, ezzel áttekinthetőbb kódot kapunk. A változó csak a 
            deklarációja után érhető el. A <function>for</function> cilus fejlécében deklarált változókat nem tudjuk használni a cikluson kívül.
        </para>
        <para>
            A C nyelvben nem tudunk azonos nevű függvényket megadni, mivel azonosításként a linker csak a függvény nevét használta. Ennek következtében a programpzóknak rengetegszer kellett
            erőltett függvényneveket kitalálni. Ezt a problémát oldja meg  a C++ függvény túlterhelés funkciója, mely annyit tesz, hogy a linker a  függvényt a neve és az argumentum listája alapján
            azonosítja. Tehát létre tudunk hozni azonos nevű függvényeket, ha azok argumentumlistája eltér. Ezt a technikát név felderítésnek nevezzük. Mivel ez a C-ben nem értelmezett ez a funkció,
            kitaláltak egy módszert arra, hogy a C és C++ közötti kompataiblitást megoldjuk, ehhez a függvény deklaráció elé kell írni, hogy <function>extern int</function>. Ezzel letiltjuk a 
            név felderítő mechanizmust. 
        </para>
        <para>
            A függvényekkel kapcsolatos másik különbség, hogy a C++ kódban lehetőségünk van alapértelmezett értéket adni az argumentumoknak. Ezzel ki tudjuk küszöbölni azt, hogyha 
            nem adunk meg elég argumentumot a függvényhívásnál.
            <programlisting language="c++">
                int f( int a, int b = 100, int c = 200){
                    return a*b-c;
                }
                int main()
                {
                    int egyik = 10;
                    int masik = 20;
                    int harmadik = 30;
                    f(egyik, masik, harmadik); //érték = 10*20*30
                    f(egyik) // érték = 10*100*200
                    f() // hiba: nincs elég argumentum
                }
            </programlisting>
        </para>
        <para>
            A C++ egyik legnyagobb újdonsága pedig a referencia típus bevezetése. A C-ből tudjuk, hogy ha egy függvénynek paraméterül adunk egy változót, akkor a azt lemásolja a függvény, és nem 
            módosítja a változó értékét. Ha azt szeretnénk, hogy a függvény módosítson az értéken, ahhoz kell használni a pointert, ami a változó memóriacímére mutat. Ennek segítségével 
            közvetlenül tudjuk átadni a függvénynek a változót, nem másoljuk az  értékét. Ennek használata elég nehezen érthetővé teszi a kódot, és rengeteg hibázási lehetőséget rejt  magában.
            Hogy ezt orvosolják, bevezették a referencia típust. A referncia típusú változót <![CDATA[&]]> jellel jelöljük. Ez a jel a C-ben egyoperandusú operátor, ami a változó memóriacímét
            adja vissza. A pointer és a referencia közötti különbség:
            <programlisting><![CDATA[
                int x = 5;
                int* a = &x;
                int& b = x;
                ]]>
            </programlisting>
            Míg a pointernek egy memóriacímet kell értékül adni, addig a refernciánál csak meg kell adni, hogy melyik változóra referáljon. Ezután mindegy, hogy a b-t vagy az x-et módosítjuk,
            mind a kettőn végrehajtódik a változtatás. Érdekesség még, hogy a referencia és a változó memóriacíme megyegyezik, tehát a referencia nem foglal a memóriában területet, ellentétben
            a mutatóval.  A programokban nagyon ritkán használjuk a referenciákat a fentebb látott módon, mivel nehéz lenne olvasni egy olyan kódot, ahol uygan arra 2 változó is hivatkozik. Ezért
            ennek a fő használati értéke a cím szerinti paraméterátadásban rejlik, ezt szokták referencia szerinti paraméterátadás. A cím szerinti paraméterátadást általában akkor szoktuk 
            használni, ha változtatni akarunk az értéken, ezért a refenciának csak olyan változót adhatunk értékül, ami módosítható.(Létezik konstans típusú referncia is, de ez speciális.)
            Egy fontos dolog még ebben a témakörben az, hogy lehet-e egy függvény visszatérési értéke pointer vagy referncia. A válasz igen, lehet, de csak korlátozott esetekben, főleg cím szerinti
            paraméterátadás esetén. Összességében elmondható, hogy nem szabad visszaadni pointert és refernciát lokális változókra, vagy érték szerinti paraméterekre, mivel előfordulhat, hogy érvénytelen
            memóriacímre fognak hivatkozni.
        </para>
        <para>
            <emphasis role = "strong">Objektumok és osztályok</emphasis>
        </para>
        <para>
            Az objektumorientáltságnak 3 alapelve van. Az egyik az egységbezárás,
            mely egységet nevezzük osztályoknak. Ezek olyan struktúrák, melyek
            az adatokat és a velük végrehajtható műveleteket is tárolják. Minden osztálynak
            lehet olyan eleme, amire öneálló egyedként tekinthetünk, ezeket objeltumoknak
            nevezzük. Egy másik fontos alapelv az adatrejtés, tehát nem szabad hagyni,
            hogy az osztályon kívülről olyan múűveleteket hajthassunk végre, mely inkonzisztenssé
            teszi az osztályt. Ennek fontos szerepe van a komplexitás szempontjából is, 
            mivel ha elrejtünk bizonyos elemeket, akkor csak elég az elérhető elemeket
            ismerni az osztály használatához. Az objektum orientált programozásban 
            lényeges tényező még az öröklés, mely lehetővé teszi, hogy egy speciálisabb
            osztály örökölje az általánosabb osztáy tulajdonságait.Fontos említést tenni
            az ezzel összefüggő behelyettesítésről is, mely lehetőve teszi, hogy ahol
            speciálisabb osztályt használjunk ott ahol amúgy általánosabb osztályt
            használtunk.
        </para>
        <para>
            Az <emphasis role="strong">egységbezárás</emphasis> C++-ban a struktúrák
            már nem csak a tagváltozókat tartalmazhatnak, hanem tagfüggvényeket is.
            Egy másik különbség, hogy a C-ben a struktúra szerinti változót akartunk
            létrehozni, akkor muszáj volt kiírni elé a <function>struct</function>
            kulcsszót, vagy meg kellett adni egy alias-t amivel tudunk rá hivatkozni.
            C++-ban viszont már erre nincs szükség, szimplán a struktúra nevével létrehozhatunk
            változót. A tagváltozókat a "." és a <![CDATA["->"]]> operátorokkal tudjuk elérni.
            A tagfüggvényeket struktúrán belül kell deklarálni, viszont a definiálásukra 2
            módszer is létezik. Az egyik az, hogy struktúrán belül definiáljuk is, vagy
            a kívül, de ebben az esetben szükség van a "::" hatókör operátorra, mivel
            előfordulhat, hogy több struktúrának is ugyan olyan nevű taggfüggvénye van.
            Minden tagfüggvénynek van egy láthatatlan paramétere, ami módosítandó
            struktúrára mutat. Ezt a láthatatlan pointert a <function>this</function>
            szóval tudjuk elérni. A struktúrával egy nagy baj van, minden tagja publikus,
            tehát a programozónak nincs eszköze ahhoz, hogy szabályozza a struktúra
            elemeinek a hozzáférését. Ezt hivatott megoldani az osztály, mely minden tagja
            alaértelmezetten private, de megadhatunk oylan elemeket is, amik elérhetők az
            osztályon kívülről. De ezt implicit módon is kiírhatjuk, <function>private:</function>
            és <function>public:</function> címkékkel. Az adott osztály használatához egy 
            változót kell deklarálnunk, ezt az osztály példányosításának nevezzük, 
            a változót pedig objektumnak. 
        </para>
        <para>
            Az objektumok létrehozásánál felmerül egy kis probléma, mégpedig az, hogy a
            tagváltozók értékét alapból nem adjuk meg, így az azokkal számoló függvények
            véletle értéket adnak. Ezt küszöböli ki a konstruktor használata, amivel
            képesek vagyunk kezdőértéket adni a változóknak, azaz inicializálni őket.
            Ha nem írunk konstruktort, akkor az alapértelmezett konstruktor hívódik meg,
            ami nem csinál semmit. Lehetőségünk van több konstruktort is megadni, annak
            függvényében, hoygan szeretnénk példányosítani. A konstruktor arról ismerszik meg,
            hogy neve megyegyezik az osztály nevével, és csak egyszer hajtódik végre, amikor
            létrehozzuk az objektumot. Ennek az ellentéte a destruktor, ami az egyes elemek
            által lefoglalt erőforrásokat szabadítja fel a program futásának végeztével. 
            Szerepe főleg a dinamikus adattagokat tartalmazó osztályokban jelentős.
        </para>
        <para>
            A <emphasis role="strong">dinamikus adattagok</emphasis> memóriakezelését C-ben a 
            <function>malloc</function> és <function>free</function> függvényekkel
            oldottuk meg. A <function>malloc</function> függvény hátránya, hogy csak a 
            legoglalandó terület méretét tudja, magáról a típusról nem tud semmit, azaz
            nem tudunk vele objektumot inicializálni. Ehhez a C++ új operátorát kell használni,
            a <function>new</function>-t, ennek az ellentéte a <function>delete</function>,
            mely a <function>free</function> megfelelője. A <function>new</function> segítségvel
            példányosíthatunk osztályokat, paraméterket adhatunk át, eredményként egy pointerrel
            tér vissza. Ha tömbnek szeretnénk helyet foglalni, ahhoz a <function>new []</function>
            operátorra lesz szükség. Ennek a használata esetén fontos odafigyelni arra, hogy a 
            felszabadítást a <function>delete []</function> operátorral tegyük.
        </para>
        <para>
            Ha egy objektum tartalmát másolni szeretnénk, akkor van szükségünk a
            <emphasis role="strong">másoló konstruktorra</emphasis>. Lényegében
            egy új objektumot inicializálunk egy már létező objektum alapján. A
            C++ nyelvben van beépített másoló függvény, ami kiválóan átmásolja
            az egyik változó tartalmát a másikba, de ez a mi esetünkben hibához vezetne.
            A probléma lényege az, hogyha pointert másoltatunk vele, akkor csak szimplán
            lemásolja az értékét, vagyis lesz 2 azonos helyre mutató mutatónk. Ezért
            nekünk kell létrehozni az másolást végző függvényt. A neve, mint a többi
            konstruktornak, ennek megegyezik az osztály nevével, paraméterként pedig
            egy objektum refernciát kap. 
        </para>
        <para>
            Ahogy egy korábbi paragrafusban már megbeszéltük, az adatrejtés nagyon fontos 
            tulajdonsága az objektumorientált programozási nyelveknek. Természetesen vannak
            speciális megoldások a rejtett tagok kinyerésére, ezzel kapcsolatban kerül elő
            a <function>friend</function> kulcsszó. A <emphasis role ="strong">friend függvények</emphasis>
            ugyanolyan jogokkal rendelkeznek, mint az osztály tagfüggvényei, viszont nem 
            kell az osztályhoz tartozniuk. Lehetőleg érdemes ketülni a használatát, de vannak
            esetek amikor szükség lehet rájuk. A <function>friend függvéynek</function> mellett
            fontos szót ejteni még a <emphasis role="strong">friend osztályok</emphasis>-ról
            is. Ezen osztályok tagfüggvényei teljes hozzáférést kapnak a barát osztály 
            tagváltozóihoz. 
        </para>
        <para>
            A konstruktorok és destruktorok kapcsán szó volt a <emphasis role="strong">tagváltozók
                inicializálásáról</emphasis>, most ezt tisztázzuk egy kicsit. Amikor egy objektumot
            létrehozunk, akkor a konstruktor hívódik meg, ekkor történik meg az 
            inicializálás. Ha utólag értéket adunk, akkor viszont "=" operátor 
            hívódik meg, nem a kontrsuktor. A tagváltozókat az inicializáslási 
            listában tudjuk incializálni, ezt a konstruktor fejléce után írjuk ":"
            elválasztva. A incializálandó tagokat pedig vesszővel választjuk el. 
        </para>
        <para>
            Az osztályoknak lehetnek <emphasis role="strong">statikus tagjai</emphasis>.
            Az osztály statikus tagváltozói nem objektumhoz tartoznak, hanem magához az 
            osztályhoz. Tehát ezek minden objektumnál azonosak, nem foglalódik a memóriában
            új terület. Ezeket a tagokat az osztályon kívülről a hatókör operátorral lehet
            elérni, már azelőtt, hogy bármilyen példányosítást végrehajtottunk volna. A
            statikus tagváltozók mellett létezik még <emphasis role="strong">statikus tagfüggvény</emphasis>.
            Ezek kizárólag a staikus tagváltozókkal tudnak "dolgozni", főleg olyan esetekben használjuk,
            amikor a statikus tagváltozó privátban van, és szeretnénk elérni osztályon kívülről.
        </para>
        <para>
            A C++ nyelvben lehetőség van beágyazott definiciókat alkalmazni, ezalatt azt értjük,
            hogy osztályokat, struktúrákat, típusdefiníciókat lehetőségünk van osztályon
            belül definiálni. A beágyazott osztályok függvényeit a hatókör operátor
            többszöri alkalmazásával tudjuk elérni, lényegéban a teljes elérésé utat kell megadni
            a vezérlésnek. Ezekre is érvényes, hogy ha <function>private</function> részben
            definiáljuk őket, akkor csak a publikus tagfüggvények segítségével tudjuk elérni 
            a fő osztályon kívülről. Fontos megjegyezni, hogy attól, hogy egy osztály egy másiknak
            a része, nem ad jogokat a fő osztálynak, és ez fordítva is igaz. Ez úgy oldható meg, ha 
            az osztályok egymást <function>friend</function>-nek deklarálják.
        </para>
        <para>
            <emphasis role="strong">Operátorok és túlterhelésük</emphasis>
        </para>
        <para>
            A beépitett típusokkal rengeteg művelet végrehajtható, de ha olyanokra
            is szeretnénk ezeket értelmezni, ami nem része a nyelvnek, akkor kell
            operátor túlterheléshez fordulnunk. Az operátorok az argumentumaikon
            hajtanak végre műveleteket, némelyik még az értéküket is
            megváltoztatja, ezt hívjuk az operátor <function>mellékhatásának</function>.
            Az operátorok kiértékelésének sorrendjét a C++ nyelv precedencia
            táblázata határozza meg. A C nyelvben a függvényeknek nincs mellékhatása,
            kivéva akkor, ha pointerként adjuk át a paramétert. A C++-ban létező referenciának
            köszönhetően ez a problma nem áll fent. Tehát az operátotok felfoghatók
            speciális függvényekként, azzal a különbséggel, hogy a kiértékelés 
            szabályrendszer alapján történik.  
        </para>
        <para>
            <emphasis role="strong">C++ sablonok</emphasis>
        </para>
        <para>
            A C++ nyelv egy érdekes  megoldása a sablonok használata. Ezekre
            azért van szükésg, hogy az osztályokat vagy a függvényeket 
            általánosabb módon tudjuk definiálni. Például van egy függvényünk,
            amit szeretnénk, hogy működjön <fucntion>int</fucntion>, és 
            <function>double</function> típussal is. Ebben az esetben választhatnánk
            azt a megoldást, hogy szimplán lemásoljuk, és ahol eddig <function>int</function> volt, oda
            <function>double</function> írunk. Ez nem túl hatékony, ezért helyette 
            készítünk egy sémát, és az éppen használni kívánt típust sablonparaméterként
            adjuk át. Ugyanez érvényes az osztályokra is, ott is megoldható, hogy 
            különböző típusokat használjunk, az átadott paraméter alapján. A 
            fordítónak a <function>template</function> kulcszsóval jelezzük, hogy 
            ez egy sablon, a sablonparamétereket pedig <![CDATA[<>]]> jelek közé írjuk, 
            vesszővel elválasztva. PL.:
            <programlisting language="c++"><![CDATA[
                template <class valami> valami novelo (valami nev)
                {
                    return nev+1;
                } ]]>
            </programlisting>
            A <function>class</function> kulcsszóval jelezzük, hogy egy típust
            szeretnénk átadni paraméterként. A példányosítást megtehetjük 
            implicit és explicit módon is.
            <programlisting language="c++"><![CDATA[
                int a = novelo(5); //implicit
                int b = novelo(6.3) //hiba
                int c = novelo<double>(6.3); //explicit, nincs hiba]]>
            </programlisting>
            Ahogy látható, az implicit megadás lestisztultabb, viszont bizonyos
            esetkeben hibához vezet, mert csak egy típust tud kezelni. Viszont 
            az explicit megoldásnál már nincs ezzel gond, mivel megadjuk, hogy
            milyen típust szeretnénk használni, tehát az automatikus konverzió
            segítségével az <function>double</function>-t <function>int</function>-é
            tudjuk alakítani.  
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
