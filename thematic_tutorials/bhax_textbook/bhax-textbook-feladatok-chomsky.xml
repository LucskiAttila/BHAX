<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/blob/master/attention_raising/Source/Decim%C3%A1lisb%C3%B3l%20Un%C3%A1risba/unaris.cpp">itt</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            <figure>
                <title>Decimálisból unárisba</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Decimálisból Unárisba/turing_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A unáris számrendszer a létező legegyszerűbb az összes számrendszer közül. Lényegében megfelel annak, amikor az ujjaink segítségével számolunk, tehát a
            számokat vonalakkal reprezentáljuk. A szám ábrázolása pont annyi vonalból áll, amennyi a szám. A könnyebb olvashatóság éredekében minden ötödik után rakhatunk
            helyközt, vagy az ötödik vonalat lényegében rakhatjuk keresztbe az őt megelőző 4-re.
        </para>
        <para>
            Az ábrán látható Turing gép az egyes számrendszerbe való átváltást végzi, de itt a | helyett 1-eseket írunk. A gép működése abból áll, hogy beolvassa a szalag celláiban tárolt számokat,
            ha a talál egyenlőség jelet, akkor az előtte lévő számból kivon 1-et. Ezt egészen addig teszi, ameddig az előtte lévő szám le nem nullázódik. Jelen esetben ez pont 0, de mivel előtte áll
            egy 1-es, ezért itt a 0-ból 9 lesz, és az 1-esből 0. Miközben folyamatosan vonja ki a egyeseket a számból, a kivont egyeseket kiírja a tárolóra. Így a végén egy 1-esekból álló sorozatot kapunk,
            melyek száma megyegyezik a kiindulási szám értékével.
        </para>
        <para>
            A forrásként megadott program lényegében egy átváltó, mely függőleges vonalakat ír ki a bemenettől függően. Mivel ez egy C++ program, ezért ennek a fordításához a g++-t
            érdemes használni, a szintaxisa teljesen megegyezik a gcc-nél megszokottakkal.
            Ha lefuttatod, akkor a következőt fogod látni:
            <programlisting>
                $ g++ unaris.cpp -o unaris
                $ ./unaris
                Adj meg egy számot decimálisan!
                10
                Unárisan:
                ||||| |||||
            </programlisting>
        </para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
           Generatív nyelvtan jelsorozatok átalakítási szabályait tartalmazza. A nyelvnek
           megfelelő szavak létrehozásához szükség van egy kezdő értékre, és ezután már
            csak a szabályokat kell alkalmazni az átalakítások elvégzéshez. Tehát a kezdő
            szimbólumot más szimbólumokkal helyettesítjük a nyelvtani szabályok
            figyelembevételével. 
        </para>
        <para>
            Noam Chomsky, XX. századi amerikai nyelvész volt az, aki elsőnek javasolta a generatív
            nyelvtanok formalizálását. Az 1950-es években publikálta munkásságát, mely alapján egy
            nyelvtannak a következő elemekből kell állnia:
            <orderedlist numeration="lowerroman">
                <listitem>
                    <para>nem-terminális szimbólumokból</para>
                </listitem>
                <listitem>
                    <para>terminális szimbólumokból</para>
                </listitem>
                <listitem>
                    <para>produkciós szabályokból</para>
                </listitem>
                <listitem>
                    <para>előállítási szabályokból</para>
                </listitem>
                <listitem>
                    <para>kezdő szimbólumból</para>
                </listitem>
            </orderedlist>
            Chomsky nevéhez fűződik még a generatív nyelvtanok csoportosítása. Négy osztályba sorolta őket
            ezek a következők:
            <itemizedlist>
                <listitem>
                    <para>0. típus (rekurzíve felsorolható nyelvtanok)</para>
                </listitem>
                <listitem>
                    <para>1. típus (környezetfüggő nyelvtanok)</para>
                </listitem>
                <listitem>
                    <para>2. típus (környezetfüggetlen nyelvtanok)</para>
                </listitem>
                <listitem>
                    <para>3. típus (reguláris nyelvtanok)</para>
                </listitem>
            </itemizedlist>
            Ebben a feladatban az 1. típussal foglalkozunk. Az környezetfüggő nyelvtanok
            szabályait kétféle képpen lehet felírni. Itt a képzési szabály mind a két oldalán
            szerepelhetnek terminális szimbólumok, ellentétben a környezetfüggetlen nyelvtanokkal
            ahol a produkciós szabályok bal oldalán csak nemterminális szimbólum állhat.
        </para>
        <para>
            Most hogy tudjuk, miből épül fel egy generatív nyelvtan lássuk a feladat megoldását.
        </para>
        <para>
            <programlisting>
S, X, Y „változók” - nemterminálisok
a, b, c „konstansok” -terminálisok
S → abc, S → aXbc, Xb → bX, Xc → Ybcc, bY → Yb, aY -> aaX, aY → aa -képzési szabályok
Jelen esetben a kezdő szimbólumunk az S lesz.
A képzési szabáylokat alkalmazva a következőket kapjuk:
                S (S → aXbc)
                aXbc (Xb → bX)
                abXc (Xc → Ybcc)
                abYbcc (bY → Yb)
                aYbbcc (aY -> aaX)
                aaXbbcc (Xb → bX)
                aabXbcc (Xb → bX)
                aabbXcc (Xc → Ybcc)
                aabbYbccc (bY → Yb)
                aabYbbccc (bY → Yb)
                aaYbbbccc (aY → aa)
                aaabbbccc 
            </programlisting>
            Tehát meg kell határozni változókat, terminálisokat és szabályokat. Amint látod
            a képzési szabályt formailag a nyíl operátorral jelöljük, tehát miből mi lesz.
            Ugyanennek a nyelvnek egy rövidebb reprezentációja a következő:
            <programlisting>
S (S → aXbc)
aXbc (Xb → bX)
abXc (Xc → Ybcc)
abYbcc (bY → Yb)
aYbbcc (aY → aa)
aabbcc 
            </programlisting>
            Fentebb említettem, hogy mi is teszi környezetfüggővé a nyelvtant, erre kiváló példa
            több is a képzési szabályokból. Például <function>bY → Yb</function>, ahol
            tisztán látszik, hogy a nyíl bal oldalán is van terminális szimbólum, ez egy
            környezetfüggetlen nyelvben nem lenne lehetséges.
        </para>
        <para>
            Egy másik nyelvtan, amely a feladatban szereplő nyelvet generálja a következőképpen néz ki:
            <programlisting>
A, B, C „változók”
a, b, c „konstansok”
A → aAB, A → aC, CB → bCc, cB → Bc, C → bc
A-ból indulunk ki, ez lesz a kezdőszimbólum.
A szabályokat követve:
                A (A → aAB)
                aAB ( A → aAB)
                aaABB ( A → aAB)
                aaaABBB ( A → aC)
                aaaaCBBB (CB → bCc)
                aaaabCcBB (cB → Bc)
                aaaabCBcB (cB → Bc)
                aaaabCBBc (CB → bCc)
                aaaabbCcBc (cB → Bc)
                aaaabbCBcc (CB → bCc)
                aaaabbbCccc (C → bc)
                aaaabbbbcccc 
            </programlisting>
            Amint láthatod nem sokat változtattunk, elég volt csak a változókat átírni, és a szabályokat,
            ezzel meg is kaptunk egy másik generatív nyelvtant, mely szintén az 
            a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelvet
            generálja.
        </para>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/BNF">itt</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A Backus-Naur-forma(vagyis BNF) segítségével környezetfüggetlen grammatikákat
            tudunk leírni. Széleskörben alkalmazzák a programozási nyelvek szintaxisának
            leírására. Ahogy a neve is mutatja, a jelölés rendszer John Backus nevéhez fűződik,
            aki 1959-ben a párizsi WCC-n mutatta be. Majd Peter Naur egyszerűsített a jelöléseken,
            csökkentette a felhasznált karakterek számát. Tevékenységéért kiérdemelte, hogy az ő
            neve is szerepeljen a forma nevében.
        </para>
        <para>
            Ahhoz, hogy lássuk hogyan is néz ki egy BNF leírás, vegyünk egy egyszerű példát:
            <programlisting><![CDATA[
<postai_cím> ::= <név_rész> "," <irányítószám_rész> " " <cím_rész>
<név_rész> ::= <személyi_rész> <keresztnév> | <név_rész> <keresztnév>
<személyi_rész> ::= <titulus> "."" "<vezetéknév>|<vezetéknév>" "
<cím_rész> ::= <kerület> <elnevezés> <közterület_tipus> <szám> <EOL>
<közterület_tipus> ::= "utca"|"tér"|"körút"|"lépcső"|"u."|"krt."
<irányítószám_rész> ::= <ország_kód>"-"<irányítószám_belső>| <irányítószám_belső>
<irányítószám_belső> ::= <irányítószám>" "<városnév> ","
]]>
            </programlisting>
        </para>
        <para>
            Forrás: <link xlink:href="https://hu.wikipedia.org/wiki/Backus%E2%80%93Naur-forma">wiki</link>.
        </para>
        <para>
            Nézzük például az első sort. Itt a postai címet határozzuk meg, ami áll egy név részből,
            irányítószámból és címből. Közéjük vesszőt rakunk, vagy csak szóközt.
            A második rész már egy kicsit érdekesebb, mert ebből kiderül, hogy a BNF jelölések rekurzívak is lehetnek. 
            A név_részben hivatkozunk a személyi_részre, és önmagára is. A | jel vagy-ot fejez ki, az értékadás pedig a ::= operátorral történik.
        </para>
        <para>
            Mostmár van fogalmunk arról, mi is az a BNF, hát akkor próbáljuk meg átültetni ezt a tudást a C utasítás leírására. Mielőtt tovább haladnál a könyv olvasásával
            érdemes elolvasni a feladatban említett részletet a <function><![CDATA[K&R]]></function> könyvből.
            <programlisting><![CDATA[
<utasítás> ::= <kifejezés_utasítás>|<öszetett_utasítás>|
                <feltételes_utasítás>|<while_utasítás>|
                <do_utasítás>|<for_utasítás>|<switch_utasítás>|
                <break_utasítás>|<continue_utasítás>|<return_utasítás>|
                <goto_utasítás>|<címkézett_utasítás>|<nulla_utasítás>
<kifejezés_utasítás> ::= <kifejezés>;
<összetett_utasítás> ::={<deklarációlistaopc> <utasításlistaopc>}
<feltételes_utasítás> ::= if (<kifejezés>)<utasítás>|<feltételes_utasítás> else <utasítás>
<while_utasítás> ::= while (<kifejezés>) <utasítás>
<do_utasítás> ::= do <utasítás> while (<kifejezés>)
<for_utasítás> ::= for (<1._kifejopc>;<2._kifejopc>;<3._kifejopc>) <utasítás>
<switch_utasitas> ::= switch (<kifejezés>) <utasítás>| <switch_utasítás> case
                <állandó_kifejezés>:|<switch_utasítás> default:
<break_utasítás> ::= break;
<continue_utasítás> ::= continue;
<return_utasítás> ::= return; | <return_utasítás> <kifejezés>
<goto_utasítás> ::= goto <azonosító>;
<címkézett_utasítás> ::= <azonosító>:
<nulla_utasítás> ::=";" 
                

         ]]></programlisting>
        </para>
        <para>
            A C programnyelvet az 1970-es években alkották meg, mely azóta 3 főbb verziót
            ért meg. Az első volt a C89, ez a klasszikus C nyelv, amit a <![CDATA[K&R]]>
            könyvből ismerhetünk meg. Ezután jött a C99, mely újdonságai között szerepelt
            többek között az inline függvéynek támogatása, új adattípusok jelentek meg, mint
            a long long int, vagy a complex. Egészen eddig nem volt támogatott az egysoros komment
            // jelölése, és a dinamikus tömb sem. Egy újabb verziója pedig 2011-ben jelent meg C11
            néven, mind a mai napig ez a legfrissebb sztenderd. Ez főleg a C99-es sztenderd
            továbbfejlesztésének tekinthető.
        </para>
        <para>
            Fontos megjegyezni, hogy a gcc lap esetben a C89-es szabváynt használja, tehát, ha
            ezen módosítanál, akkor a -std=c99 kapcsolót kell használnod.
            <programlisting language="C"><![CDATA[
                    int main()
                    {
                        int a = 10; //C99-ben ezt szabad
                        return 0;
                    }
]]></programlisting>
            Ránézésre semmi probléma nem lehetne vele, de a gcc-t a -std=c89 kapcsolóval használva hibát fog kiírni.
            <figure>
                <title>1. Splint kép</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/BNF/kód.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Igen, jól látod, az egysoros komment jelölésére használt // a C99 előtt, csak a C++ támogatta. Ennek a támogatásának bevezetése a C nyelvbe, a C99-es sztenderd
            egy nagy újdonsága volt.
            Ha C89-es szabvány szerint szeretnél kommentelni, akkor az előző példa, így módosul:
            <programlisting language="c"><![CDATA[
                int main()
                {
                    int a = 10 /*ez már lefordul -std=c89-el*/
                    return 0;
                }
]]></programlisting>
            Ennek a kommentelésnek az előnye, hogy lehetőséget biztosít a többsoros komment létrehozására. 
        </para>
        
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/Lexer">itt</link>  
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ehhez a feladathoz a lex programot kell használni, melyel egy lexikális lemezőt lehet készíteni.
            Szövegfájlokból olvassa be a lexikális szabályokat, és egy C forráskódot készít, melyet a gcc-vel
            tudunk fordítani. A lex forráskód 3 részből áll, az első a definíciós rész, amely lényegében bármilyen
            C forrást tartalmazhat, itt lehet include-álni a header fájlokat. A második rész a szabályoknak van
            fennttartva. Ez 2 részből áll, reguláris kifejezésekből, és az azokhoz tartozó C utasításokból.
            Tehát, ha a program futása során a bemenetként kapott string illeszkedik valamelyik reguláris kifejezésre,
            akkor végrehajtja a hozzá tartozó utasítást. A harmadik rész pedig egy C-kód, amely lényegében a
            a lexikális elemzőt hívja meg. Ez a rész, és az első, teljes mértékben átmásolódik a lex által generált
            C forrásba. A részeket %%-jellel különítjük el.
        </para>
        <para>
            Most hogy már tudod mi is az a lexer, itt az idő végig futni a belinkelt forráson.
            Az első rész a következő:
            <programlisting language = "c"><![CDATA[
 %{
  #include <stdio.h>
  int realnumbers = 0;
 %}]]>
            </programlisting>
            Ahogy említettem, itt importáljuk a header fájlokat, és a szükésges változókat is itt
            deklaráljuk. Ezután következik a második rész:
            <programlisting language="c"><![CDATA[
{digit}*(\.{digit}+)?	{++realnumbers; 
        printf("[realnum=%s %f]", yytext, atof(yytext));}
                ]]>
            </programlisting>
            Itt a bal oldalon vannak a reguláris kifejezések, jobb oldalon pedig az, amit a C program
            végrehajt. Ez a regex azokra a bemenetekre illeszkedik, amelyek számmal kezdődnek, és a * jelöli, hogy többször is előfordulhat.
            Majd a zárójelben lévő csoportból valamelyik tag 0-szor, vagy 1-szer fordul elő. Ezt jelöli a ?-jel. Az <function>atof()</function> függvény pedig az argumentumként kapott stringet double-lé
            alakítja.
            Vessünk egy pillantást a harmadik részre:
            <programlisting language="c"><![CDATA[
int
main ()
{
    yylex ();
    printf("The number of real numbers is %d\n", realnumbers);
    return 0;
}
            ]]>    
            </programlisting>
            Ez tartalmazza a <function>yylex()</function> lexikálsi elemző függvény hívását, és itt íratjuk ki
            az eredményt is.
        </para>
        <para>
            Most, hogy láttad, hogyan épül fel a lexer, akkor már csak ki kéne próbálni.
            <programlisting>
                $ lex -o lexikalis.c lexikalis.l
                $ gcc lexikalis.c -o lexikalis
                $ ./lexikalis
                12 34 54 12
                The number of real numbers is 4
            </programlisting>
            A bevitelt a Ctrl+D paranccsal lehet megállítani. Szöveges fájlt beleirányítani
            pedig a <programlisting><![CDATA[./lexikalis <fajl_nev]]></programlisting> paranccsal lehet.
        </para>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/06C_PqDpD_k">itt</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/L33t">itt</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Elsőnek nézzük meg, hogy mi is az a leet nyelv. Ennek a nyelvnek az a lényege, hogy a 
            szavakban lévő bizonyos betűket, számokkal, vagy egyéb más karakterekkel helyettesítjük. Az egyes
            betűket közmegállapodás szerinti karakterekre cserélhetjük. Erről a teljes listát <link xlink:href=
            "https://qntm.org/l33t">itt</link> találod. Természetesen a linkelt programunk is ebből indul ki, de
            nem minden opciót vettünk bele.
        </para>
        <para>
           Az előző feladatban már ismertettem veled a lexer felépítését, és ugyan ezt használjuk
            itt is. Természetesen az első részben most is importálva vannak különböző header fájlok, de ami
            érdekesebb az utána jön.
            <programlisting language="c"><![CDATA[
  #define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } l337d1c7 [] = {

  {'a', {"4", "4", "@", "/-\\"}},
  {'b', {"b", "8", "|3", "|}"}},
  {'c', {"c", "(", "<", "{"}},
                ...
  };
]]>                
            </programlisting>
            A <function>#define</function> segítségével lényegében egy makróhelyettesítést
            hajtunk végre, ezt úgy kell elképzelni, hogy ha a programban valahol hivatkozunk az
            <function>L337SIZE</function>-ra akkor a mellette található értékkel fogja helyettesíteni.
            Ezután létrehozzuk a <function>cipher</function> struktúrát, mely egy <function>char c</function>-ből, és
            egy 4 elemű karakterekből álló tömbre mutató <function>char *</function> típusú mutatóból áll.
            Ez alapján a struktúra alapján létrehozzuk az <function>l337d1c7 []</function> tömböt. Ez a tömb
            tartalmazza az egyes betűket, és a hozzájuk tartozó lehetséges helyettesítő karaktereket. Tehát a 
            a tömb minden eleme áll egy <function>char c</function>-ből, és egy <function>char *leet[4]</function>-ből.
        </para>
        <para>
            A második részben ezúttal nem használunk különféle regex-eket, tehát minden karakter esetén
            végrehajtjuk a C utasítást.
            <programlisting language = "c"><![CDATA[
      .	{
	  
	  int found = 0;
	  for(int i=0; i<L337SIZE; ++i)
	  {
	  
	    if(l337d1c7[i].c == tolower(*yytext))
	    {
	    
	      int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0)); //random szám generálás
	    
                if(r<91)
                    printf("%s", l337d1c7[i].leet[0]);
                else if(r<95)
                    printf("%s", l337d1c7[i].leet[1]);
	        else if(r<98)
                    printf("%s", l337d1c7[i].leet[2]);
                else 
                    printf("%s", l337d1c7[i].leet[3]);

	      found = 1;
	      break;
	    }
	    
	  }
	  
	  if(!found)
	     printf("%c", *yytext);	  
	  
	}
]]>                
            </programlisting>
        Tehát a .-t használjuk, ami minden karakterre illeszkedik. A <function>for</function> ciklus fejében lekérjük a L337SIZE konstans értékét,
        ami a l337d1c7[] tömbnek és a cipher struktúra méretének a hányadosa. Mivel a l337d1c7[] egy struktúrált tömb, ezért a <function>l337d1c7[i].c</function> tudunk
        hivatkozni a tömb i-dik elemének a <function>char c</function> részére. A <function>tolower()</function> függvény segítségével az esetleges nagybetűket
        kicsivé változtatjuk. Majd ezután képzünk egy random számot 1-100 között. Ha 91-nél kisebb számot "dob" a gép, akkor a <function>char *leet[4]</function> tömb első
        elemét printeljük, és így tovább, ahogy a forrásban látod. A <function>int found</function> változót azért vezettük be, hogy jelezzük, benne van-e tömbünkbe a beolvasott karakter.
        Ha nincs, akkor visszadjuk az eredeti karaktert, módosítás nélkül.
        </para>
        <para>
            Ezután megint a C forrás jön, melyben elindítjuk a lexelést.
            <programlisting language = "c">
int 
main()
{
  srand(time(NULL)+getpid());
  yylex();
  return 0;
}
            </programlisting>
            Itt található egy érdekesség, az <function>srand()</function> függvény adja meg a kiindulási értéket a <function>rand()</function> függvény számára. Jelen esetben az aktuális időt és 
            a szülő folyamat PID-jának összegét adja át.
        </para>
        
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            </listitem>
        </orderedlist>
        <para>
            Megoldás forrása:  
        </para>

        <para>
            Megoldás videó: 
        </para>

        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Programozó pályafutásunk során rengetegszer kell mások kódjában tájékozódni, ez a feladat ebben nyújt segítséget, hogyan
            értelmezzükk helyesen a kódokat.
            Lássuk is az elsőt. A bevezetőben már láthattad, hogy melyik manuál oldalakat kell átnézni ehhez a kódcsipethez, szóval ezzel most
            nem rabolnám az időt.
            <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting> Ez azt jelenti, hogyha eddig nem volt figyelmen kívül hagyva a SIGINT jel, akkor a jelkezelő
            függvény kezelje. Ellenkező esetben hagyjuk fiygelmen kívül.
            <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting> Ez egy for ciklus, amelynél az első iterációban az i nulla, majd
            megnézzük, hogy kisebb-e, mint 5, és minden iterációban növeljük 1-el.
            <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting> Ez ebben az esetben megegyezik az előzővel, ugyan úgy 0,1,2,3 majd 4
            lesz az i étéke. Viszont ez nem mindig van így.
            <programlisting language="c"><![CDATA[
    int a = 5;
    int b = a++; //itt a b értéke 5 lesz, majd növeljük az a étékét 1-el
    int c = ++a; //c értéke már nem 6 lesz, hanem 7, mivel itt előbb növelünk
            ]]></programlisting>
            <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting> Ez már viszont egy bugos program, mivel egyszerre inkrementáljuk
            az i-t, és hivatkozunk a tomb i. elemére. Az a baj, hogy nem ismerjük a végrahajtás sorrendjét, emiatt nem kiszámítható az eredmény.
            <figure>
                <title>1. Splint kép</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Bugok/splint.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting> Ez a kódcsipet szintén bugos, a probléma az, hogy az
            értékadó operátort használjuk, az összehasonlító operátor helyett, ennek következtében a <function><![CDATA[&&]]></function> operátor
            jobb oldalán nem egy logikai operandus áll.
            <figure>
                <title>2. Splint kép</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Bugok/splint2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting> Ez is hibás kód, mivel az f függvény két int-et kap, de azok
            kiértékelésének sorrendje nincs meghatározva.
            <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting> Ennél a kódcsipetnél nincs probléma, kiírjuk az
            <function>a</function> értékét és az <function>a</function> függvény által módosított értékét.
            <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>  Ennek a kódnak szintén a kiértékelés sorrendjével van baja,
            mivel az f() függvény módosítja az <function>a</function> értékét, emiatt nem tudhatjuk, hogy az önmagában kiprintelt <function>a</function>
            az eredeti értékét, vagy a módosított értékét fogja kiírni.
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az aritmetika nyelve a logikai nyelvek közül az elsörendűek közé tartozik. A legalapabb logikai nyelv a nulladrendű logika, ez csak ítéletváltozókat tartalmaz, és 3 műveletet: a konjunkciót,
            diszjunkciót és implikációt. Erre épül rá az elsőrendű logika, kiegészülve függvényszimbólumokkal, változókkal, kvantorokkal. Ha részletesebb tájékozódnál, akkor a forrásban több könyv is meg
            van nevzeve, ami a feladathoz szükséges ismereteket tartalmazza.  
        </para>
        <para>
            Akkor térjünk rá a feladatra. Elsőnek elmondom, hogy melyik kifejezés mit jelent. A <function>foreall</function> fogja jelölni az univerzális kvantort, és az <function>exist</function> pedig
            az egzisztenciális kvantort. A <function>wedge</function> alatt az implikációt értjük, és a <function>supset</function> pedig a konjunkciót. Ehhez a feladathoz érdemes még ismerni az Ar nyelv
            rákövetkező függvényét, amit <function>S</function>-el jelölünk.
            Most, hogy ezeket tudjuk, már csak le kell fordítani a emberi nyelvre a fentebb látható formulákat.
            <programlisting>
1. Minden x-hez létezik olyan y, amelynél ha x kisebb, akkor y prím.
2. Minden x-hez létezik olyan y, amelynél ha x kisebb, akkor y prím, és ha y prím, akkor annak második rákövetkezője is prím.
3. Létezik olyan y, amelyhez minden x esetén az x prím ,és x kisebb, mint y.
4. Létezik olyan y, amelyhez minden x esetén az x nagyobb, és x nem prím.
            </programlisting>   
        </para>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b);]]></programlisting>            
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>            
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/Deklar%C3%A1ci%C3%B3">itt</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A feladat első részében készíteni kell egy programot, ami tartalmazza a fentebb felsorolt 
            elemeket. Menjünk végig a forráson. Maga a forrás C++ nyelven íródott mivel a referenciákat
            a sima C nem támogatja.
            <programlisting language="c++"><![CDATA[
int* fakt(int szam){
    static int a = 1;
    if (szam < 2)
        return &a;
    while (szam>1){
        a = a*szam;
        --szam;
    }
    return &a;
}]]>
            </programlisting>
            Az első függvény egy számnak a faktoriálisát számolja ki, és visszaad
            egy erre az értékre mutató mutatót. Mivel a függvényen belül deklarált 
            változók lokálisak, és törlődnek a függvény lefutása után, ezért nem
            tudunk visszatérni annak a memóriacímével. Ezért kellett használni a 
            <function>static</function> kulcszsót, mely lehetővé teszi, hogy a 
            lokális változó benne maradjon a memóriában, akkor is ha vezérlés már
            továbblépett a függvényen.
            <programlisting language="c++"><![CDATA[
int* sum(int egyik, int masik){
    static int sum = egyik + masik;
    return &sum;
}

int szorzat(int egyik, int masik){
    return egyik*masik;
}

int osztas(int egyik, int masik){
        return egyik/masik;
}]]>
            </programlisting>
            Ezek a függvények lényegében segítségként jöttek létre, hogy a 
            függvényre mutató mutatókat használni tudjuk a programban. Ebben a 
            dologban a legnagyobb problémát a <function>fakt</function> függvényben 
            lévő statikus változó okozta. Csinálni kell egy egészre mutató mutatót visszadó
            függvényre mutató mutatót. Ez a pointer mutathatna a <function>fakt</function>-ra, csak
            az a probléma, hogyha a pointeren keresztül meghívja a program a függvényt, akkor a <function>sum</function>
            értéke megváltozik. Ezért definiáljuk a <function>sum</function> függvényt, ami szintén 
            a egészre mutató mutatót ad vissza. A <function>szorzat</function> és
            <function>osztas</function> függvények pedig, ahogy említettem, csak segéd
            függvéynek.
            <programlisting language="c++"><![CDATA[
int (*pfgv (int a)) (int,int){
    if (a){
        return &szorzat;
    }
    else
        return &osztas;
}]]>
            </programlisting>
            A <function>pfgv</function> egy olyan függvény, ami függvényre mutató pointert ad vissza, egy olyan függvényre 
            mutató pointert, ami két egészt kér paraméteréül. A <function>pfgv</function> egy egészet kér 
            paraméteréül, és ennek függvényében ad vissza egy pointert, vagy a <function>szorzat</function> vagy a 
            <function>osztas</function> függvényekre.
            <programlisting language="c++"><![CDATA[
int main()
{
    int a = 10;
    int b = 5;
    int* pa = &a;
    int& ra = a;
    int tomb[a];
    int(& rtomb)[a] = tomb;
    int* ptomb[2];
    ptomb[0] = &a;
    ptomb[1] = &b;
    int* fakt_a = fakt(a);
    int*(*psum)(int,int) = &sum;
    int (*(*p_pfgv) (int valami))(int, int) = &pfgv;
    std::cout<<"a és b szorzata "<<(pfgv(1))(a,b)<<std::endl;
    std::cout<<"a és b hányadosa "<<(pfgv(0))(a,b)<<std::endl;
    std::cout<<"a és b hányadosa "<<(p_pfgv(0))(a,b)<<std::endl;
    std::cout<<"a értéke "<<a<<'\t'<<"a! értéke "<<*fakt_a<<std::endl;
    std::cout<<"a és b összege "<<*psum(a,b)<<std::endl;
}]]> 
            </programlisting>
            Az <function>main</function> függvény tartalmazza a feladat további megoldásait. 
            A <function>a</function> és <function>b</function> változók egészek. A <function>pa</function>
            egy egész számra mutató pointer. A pointer egy memóriacímre mutat, emiatt az <function>a</function>
            változó címét kell képeznünk, amit a <function><![CDATA[&]]></function> operátorral tehetünk meg.
            A referncia nagyon hasonlít a pointerre, ez is egy változóra hivatkozik. Lényegében az érékéül 
            adott változó aliasa. Előnye a pointerrel szemben, hogy nem foglal külön helyet, hanem a 
            változó memóriacímét használja. Ilyen referncia a <function>ra</function>. Itt a 
            <function><![CDATA[&]]></function> nem címképző operátor, hanem ezzel jelezzük a fordítónak, hogy 
            egy refernciát deklaráltunk. Az <function>tomb</function> egy egészeket tartalmazó tömb, aminek az 
            elemszáma megegyezik az <function>a</function> változó értékével. A <function>rtomb</function>
            pedig a <function>tomb</function> tömbnek a refernciája, nem csak az első elemé, hanem az egész
            tömbbé. A <function>ptomb</function> tömb egészekre mutató mutatók tömbje. Ahogy látható
            az elemeihez hozzá tudjuk rendelni a változók memóriacímét. A <function>fakt_a</function>
            pointer pedig a <function>fakt</function> függvény által visszaadott <function>sum</function>
            változóra mutat. A <function>psum</function> szintén egy pointer, de nem egy változóra mutat, vagy 
            egy tömbre, hanem egy függvényre. Jelen esetben egy olyan függvényre tud mutatni, ami <function>int*</function>
            ad vissza, azaz egészre mutató pointert, és paraméteréül két egészt kér. Ennek a leírásnak pont megfelel a 
            <function>sum</function> függvény. A <function>p_pfgv</function> szintén egy függvénymutató, ahogy a nevéből 
            látszik a <function>pfgv</function> függvényé. Vagyis ez a pointer egy olyan függvényre mutat, ami 
            paraméteréül kér egy egészt, és egy olyan függvényre mutató pointert ad vissza, ami két egészet kér be, és
            egy egészet ad vissza. A <function>cout</function> segítségével pedig kiírjuk a képernyőre a következő sorokat. Érdekesség, hogy a 
            pointere keresztüli függvényhívásoknál nincs szükség a <function>*</function> használatára, ellentétben a 
            változókkra mutató pointerekkel. Például a <function>fakt_a</function> értékét csak a * operátor segítségével kaphatjuk meg, ha 
            ellenkező esetben a memóriacímet adja vissza. Viszont a <function>psum</function> pointeren keresztüli függvényhívásnál már
            használtunk * operátort, mivel a <function>sum</function> függvény egy egészre muató pointert ad vissza. 
        </para>
        <para>
            Mostpedig lássuk a feladat másik részét, ahol le kell írni, hogy mit vezetnek be a programba az alábbi kifejezések. Az feladat első részében
            már minegyikkel kellett dolgoznunk, szóval könnyű dolgunk lesz.
            <programlisting><![CDATA[int a;]]></programlisting> egy egész vezet be a programba.
            <programlisting><![CDATA[int *b = &a;]]></programlisting> egy egészre mutató mutatót vezet be. A mutató, vagy elterjedtebb nevén pointer lényegében egy olyan változó, ami egy változó, 
            egy tömbre esetleg egy függvényre
            memóriacímére mutat. Érdemes megfigyelni, hogy a <function><![CDATA[&a]]></function> vagyunk
            képesek átadni az <function>a</function> változó memóriacímét.
            <programlisting><![CDATA[int &r = a;]]></programlisting> egy egésznek a referenciáját vezeti be. Láthatod, hogy a mutatót a <function>*</function> operátor segítségével deklarálunk, míg a referenciát
            a <function><![CDATA[&]]></function> jellel. A kettő közti különbség az, a referencia, lényegében egy alias egy másik változóhoz. Nem foglal külön helyet a memóriában, mint a pointer, hanem
            osztozik a területen a referált változóval.
            <programlisting><![CDATA[int c[5];]]></programlisting> egy egészekből álló, 5 elemű tömböt deklarál.
            <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>  az egészek tömbjének referenciáját vezeti be a programba. Fontos látni, hogy ez nem az első elemnek a referenciája, hanem az
            összes elemnek.
            <programlisting><![CDATA[<int *d[5];]]></programlisting> egészre mutató mutatók tömbje.
            <programlisting><![CDATA[int *h ();]]></programlisting> egészre mutató mutatót visszadó függvény.
            <programlisting><![CDATA[int *(*l) ();]]></programlisting> egészre mutató mutatót visszaadó függvényre mutató mutató.
            <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting> egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény
            <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre
        </para>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
