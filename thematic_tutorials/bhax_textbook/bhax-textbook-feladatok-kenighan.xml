<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Kernighan!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Pici könyv</title>
        <para>
            <emphasis role="strong">Alapfogalmak</emphasis>
        </para>
        <para>
            Ha a számítógépek programozási nyelveiről beszélünk, akkor
            fontos említést tenni róla, hogy milyen szintekre tudjuk őket
            osztani. Az első a gépi nyelv, mely lényegében 0-kból és 1-kből
            álló bináris kód. Ezt követi az assembly szintű nyelv, amely már egy
            kicsit közelebb van az emberi nyelvekhez, de még alacsony szintű
            programozási nyelvnek minősül. Legvégül pedig tegyünk említést a
            könyv fő témájáról a magas szintű programozási nyelvekről. Ezek
            már közel állnak az emberek által is értelmezhető nyelvekhez, főleg
            az angolra épülneké. 
        </para>
        <para>
            A magas szintű programozási nyelven írt programot forrásprogramnak
            nevezzük. Ennek az előállításához be kell tartani bizonyos az 
            adott nyelvre jellemző formai,szintaktikai szabályokat és a tartalmi,
            szemantikai szabályokat.
        </para>
        <para>
            A processzorok saját gépi nyelvvel rendelkeznek, és csak az ezen a
            nyelven írt programokat képesek végrehajtani. Tehát a forráskódokat
            át kell alakítani a gép által értelmezhető gépi kódra. Erre két
            analógia létezik, az egyik a fordítóprogramos megoldás, a másik
            az interpreteres.
        </para> 
        <para>
            A fordítóprogram egyetlen egységként kezeli a
            forrást, és lexikai, szintaktikai, szemantikai elemzést hajt
            végre, majd legenerálja a gépi kódot. Ez még nem futtatható, ebből
            a kapcsolatszerkesztő állít elé futtaható programot, melyet a betöltő
            behelyez a tárba, és a futtató rendszer felügyeli a futását. Bizonyos
            esetekben lehetőség van arra, hogy nem nyelvi elemeket használjunk
            egy forrásprogramban, de ilyenkor szükség van egy előfordítóra is.  
        </para>
        <para>
            Az interpreteres megoldás nem készít tárgykódot, viszont a fentebb
            említett 3 elemzést végrehajtja. Utasításonként sorra veszi a
            forrásprogramot, értelmezi, és végrehajtja. tehát rögtön kapjuk meg
            eredményt. Bizoynos nyelvek esetén mind az interpreteres, mind a
            fordítóprogramos megoldást alkalmazzák.
        </para>
        <para>
            Minden programozási nyelvhez tartozik egy hivatkozási nyelv, mely a
            szemantikai és szintaktikai szabályokat határozza meg. Emellett
            léteznek még implementációk. Az egyes rendszereken több fordítóprogram
            és iterpreter létezik, és ennek következtében az implementációk
            nem kompatiblisek egymással, ez pedig meggátolja a programok tökéletes
            hordozását a platformok között.
        </para>
        <para>
            A programozó dolgának megkönnyítése érdekében létrejöttek az 
            integrált grafikus felületek(IDE), melyek egy csomagban tartalmaznak
            minden szükséges eszközt a programok megírásához, és futtatásához.
        </para>
        <para>
            <emphasis role="strong">A programnyelvek osztályozása</emphasis>
        </para>
        <para>
            Összeségében 2 fő csoportra oszthatjuk a programozási nyelveket:az 
            imperatív nyelvekre és a deklaratív nyelvekre.
        </para>
        <para>
            Az imperatív nyelvek algoritmikus nyelvek, tehát a programozó maga 
            kódolja le az algoritmust, amit a processzor majd végrehajt. A program
            utasításokból épül fel. Legfőbb eszköz a változó, mely segítségével
            el tudunk érni tárterületet, és tudjuk módosítani annak tartalmát.
            Jelen esetben az algoritmusok teszik ezt. Az imperatív nyelveknek
            2 alcsoportja van: az Eljárásorientált nyelvek és az Objektumorientált
            nyelvek. 
        </para>
        <para>
            Ezzel szemben a deklaratív nyelvek nem algoritmikusak, a programozó
            csak felvázolja a problémát, és a nyelvi implementációkban be van 
            építve a megoldás megkeresésének módja. Memóriaműveltekre
            nincs lehetőség, vagy nagyon korlátozott módon. Ennek is 2 alcsoportja
            van: a Funkcionális nyelvek és a Logikai nyelvek.
        </para>
        <para>
            Léteznek olyan nyelvek is, amelyek nem sorolhatóak be egyik osztályba
            sem, nincs egységes jellemzőjük. Általában az imperatív nyelv valamelyik
            tulajdonságát tagadják.
        </para>
        <para>
            <emphasis role="strong">Karakterkészlet</emphasis>
        </para>
        <para>
            A programok legkisebb épitőelemei a karakterek. A forrásszöveg
            írásakor alapvető a karakterkészlet ismerete, mivel csak ezek
            jelenhetnek meg a kódban, és belőlük állítható elő összetett
            nyelvi elem. Az eljárásorientált nyelvek lexikális, szintaktikai 
            egységek, utasítások, programegységek, fordítási egységek
            és végül maga a program épül fel a nyelvi elemekből.
        </para>
        <para>
            Minden nyelv definiálja a saját karakterkészletét, de a lgetöbb
            programnyelv a karaktereket 3 kategóriába sorolja: betűk, számok,
            egyéb karakterek. A legtöbb nyelvben a betűk az angol ABC 26 betűjét
            tartalmazzák, viszont az már nyelv függő, hogy értelmezve van-e a nagy
            és kis betű, vagy különbséget tezs a kettő között. Egyes újabb nyelvek
            már nemzetisági betűket is tartalmaznak, ennek következtében
            "magyarul" is programozhatunk. A számokat nagyjából mindegyik
            nyelv hasonlóan kezeli, a decimális számjegyeket veszik számokjegy
            karakternek. Egyéb karakterek közé soroljuka műveleti jeleket(+,-,*,/),
            elhatároló jeleket([,],., {, },;), írásjeleket és speciális
            karaktereket. A hivatkozási nyelv és az implementáció karakterkészlete
            egyes esetekben eltérő lehet.
        </para>
        <para>
            <emphasis role="strong">Lexikális egységek</emphasis>
        </para>
        <para>
            A lexikális egységek azok, amelyeket a fordítóprogram felismer, és 
            tokenizál. Lehetnek többkarakteres szimbólumok, szimbolikus nevek,
            cimkék, megjegyzések, literálok.
        </para>
        <para>
            Többkarakteres szimbólumoknak a nyelv tulajdonít jelentést, gyakran
            operátorok vagy elhatárolók, mint C-ben a ++,--,<![CDATA[&&]]>.
        </para>
        <para>
            Szimbolikus neveket 3 csoportra bontjuk, az azonosítókra, a
            kulcsszóra és a standard azonosítóra.
            Az azonosító betűvel kezdődik és betűvel vagy számmal folytatódik, 
            segítségével programozói eszközöket nevezünk meg, és ezzel a névvel
            tudunk rájuk hivatkozni a programon belül.
            A kulcsszónak az adott nyelv tulajdonít jelentést, ez nem
            változtatható meg. C-ben iylenek az if, for, case, break.
            A standard azonosító pedi egy kicsit mind a kettő, mivel ezt is az 
            adott nyelv látja el jelentéssel, de a programozó megváltoztathatja.
            C-ben sztenderd azonisítónak számit a NULL.
        </para>
        <para>
            A címkéknek főleg az eljárásorientált nyelvekben van nagy jelentősége
            ,mivel a segítségével képesek vagyunk megjelölni a végrehajtó
            utasításokat, így tudunk rájuk hivatkozni a program más részein.
        </para>
        <para>
            A megjegyzések szerepe az évek során eléggé megkopott, de természetesen
            minden nyelv biztosít lehetőséget kommentek hozzáadásához. A komment
            lényegében egy karaktersorozat, amelyet a fordító ignorál. Több 
            implementáció létezik a kommentek alakalmazására, lehet teljes
            komment sorokat elhelyezni, vagy sor végi kommenteket, de lehetőség
            van több soros, egybefüggő kommentek elhelyezésére is. A C-ben mind
            a 3-ra van lehetőség. (Egysoros komment://, többsoros: /* */) 
        </para>
        <para>
            Végezetül tegyünk említést a literálokról is, mely programozási eszközök
            segítségével fix értékek építhetők be a programba. A literáloknak van
            típusuk és értékük. A literálrendszerek egyes programozási nyelvekben
            eltérő lehet.
        </para>
        <para>
            <emphasis role="strong">Adattípusok</emphasis>
        </para>
        <para>
            Az adattípus egy absztrakt programozási eszköz,mely kronkrét eszközök
            komponenseként jelenik meg. Mindig rendelkezik egy névvel, ami azonosító.
            Nem minden nyelv ismeri ezt, azt eszközt, főleg az eljárásorientált
            nyelvekben van fontos szerepe. Az adattípust a tartomány, a műveletek
            és a reprezentáció határoz meg.
        </para>
        <para>
            A tartomány az adattípus által felvehető értékek halmazát adja meg.
            Mindegyikhez hozzátartoznak műveletek, amit az adott típussal végre
            tudunk hajtani. A reprezentáció pedig a beslő ábrázolást írja le,
            vagyis a tárban a típus hány bájtra képződik.
        </para>
        <para>
            Bizonyos nyelvek lehetőséget biztosítanak arra, hogy a programozó
            saját adattípusokat adjon meg, mindezt általában a beépített 
            típusok segítségével. Meg tudjuk adni a tartományt, a műveleteket, és
            a reprezentációt is. Viszont ezt nagyon kevés nyelv támogatja.
        </para>
        <para>
            Az adattípusokat 2 nagy csoportra osztjuk: skalár adattípus és
            összetett adattípus.
        </para>
        <para>
            A <emphasis role="strong">saklár</emphasis> típus tartománya atomi
            értékeket tartmaz. Skalár típus a 
            minden nyelvben létező egész, melynek belső ábrázolása fixpontos.
            Vannak még a valós típusok, ezek reprezentációja lebegőpontos,
            tartománya implementációfüggő. Ezt a két típust együtt numerikus
            típusoknak nevezzük, melyeken numerikus és összehasonlító műveletek
            hajthatók végre.
        </para>
        <para>
            A karakteres típus elemei karakterek, míg 
            karakterlánc típuséi karaktersorozatok. Ezeken szöveges és hasonlító
            műveleteket hajthatunk végre. Ábrázolásuk karakteres.
        </para>
        <para>
            Bizonyos nyelvek támogatják a logikia típusokat is, melyek értéke igaz
            vagy hamis lehet, logikai és hasonlító műveleteket tudunk velük
            végrehajtani.
        </para>
        <para>
            Érdekességként meg lehet említeni a felsorolás típust vagy a sorszámozott
            típust, de ezek kevésbé elterjedtek, csak néhány nyelvben fordulnak elő.
        </para>
        <para>
            Az <emphasis role="strong">összetett típusok</emphasis> közül a két
            legfontosabb a tömb és a rekord. A tömb homogén, statikus összett típus,
            meghatározzák a dimenzóinak száma, az indexkészletének típusa és tartománya,
            és az eleminek a típusa. Léteznek több dimenziós tömbök, melyeket
            lehet oszlopfolytonosan vagy sorfolytonosan ábrázolni. A tömb elemeit
            indexek segítségével tudjuk bejárni.
        </para>
        <para>
            A rekord típus heterogén, tartományában különböző típusok szereplehetnek.
            Az egyes elemeket mezőknek nevezzük, melyeknek van saját neve és típusa.
            A mezőneveket minősített nevekkel tudjuk ellátni, ezzel segítve az azonos 
            nevű mezők megkülönböztetését.
        </para>
        <para>
            A <emphasis role = "strong">mutató típus</emphasis> egyszerű típus,
            de érdekessége az, hogy tartomány tárcímekből áll. Segítségével indirekt
            módon el tudjuk érni a mutatott elem értékét. Fontos a szerepe az
            absztrakt adatszerkezetek szétszórt reprezentációjában.
        </para>
        <para>
            <emphasis role="strong">Nevesített konstans</emphasis>
        </para>
        <para>
            3 komponensből áll: név, típus, érték.
            Mindig deklarálni kell, mely során megkapja az értékét, és azt 
            nem lehet módosítani a futás folyamán. A nevével tudunk hivatkozni az
            értékkomponensére. Ennek köszönhetően, elég a deklarációnál
            ,módosítani az értéket, és nem kell minden egyes előfordulásnál.
            C-ben ezt a következőképpen használjuk:
            <programlisting language="c"># define név literál</programlisting>
            Ez az előfordítónak szól, és a név minden előfordulását helyettesíti
            a literállal.
        </para>
        <para>
            <emphasis role="strong">Változó</emphasis>
        </para>
        <para>
            4 komponensből áll: név, attríbútum, cím, érték. A név egy azonosító, a
            programban a változó mindig a nevével jelenik meg. Attribútumnak olyan
            jellemzőket nevezünk, amik befolyásolják a változó viselkedést. Attribútum
            például a változó típusa, mely a deklaráció során rendelődik a változóhoz.
        </para>
        <para>
            Létezik explicit deklaráció, implicit deklaráció és automatikus deklaráció.
            Az explicit deklaráció a véltozó nevéhez rendel attribútumot, míg az implicit
            betűkhöz. Pl. megoldható, hogy az azonos kezdőbetűvel rendelkező 
            változók azonos attribútumúak lesznek. Az automatikus pedig azt jelenti,
            hogy a fordítóprogram rendel attribútumot a változóhoz, ha az még nem volt
            deklarálva.
        </para>
        <para>
            A változó címkomponense határozza meg a változó helyét a tárban. Egy változó
            élettartamának a futási idő zon részét nevezzük, ameddig a változó rendelkezik
            címkomponenssel. A címet lehet statikus vagy dinamikus tárkiosztással rendelni
            változóhoz. Létezik még programozó által vezérelt tárkiosztás is, a futási
            időben a programozó rendel címkomponenst a változóhoz.
        </para>
        <para>
            A változó értékkomponense bitkombinációként jelenik meg a címen, melynek
            felépítését a típus határozza meg. A változónak értéket értékadó utasítással
            tudunk adni, mely a C-ben így néz ki:
            <programlisting language="c">változónév = kifejezés;</programlisting>
        </para>
        <para>
            <emphasis role="strong">Alapelemek C-ben</emphasis>
        </para>
        <para>
            A C tipusrendszere 3 részre bontható, vannak az aritmetikai típusok,
            a származtatott típusok és a void típus. Az aritmetikai típusok közé tartoznak az
            egészek, a karakter, a felsorolás, a valósok. A származtatott típusok a tömb, a függvény
            mutató, struktúra, union.
        </para>
        <para>
            <emphasis role="strong">Az aritmetikai típusok egyszerű, mig a származtatottak
            összetett típusok.</emphasis>. Az előbbivel aritmetikai műveletek végezhetőek.
            Logikai típus nincs, az <function>int 0</function> felel meg hamisnak, az összes
            többi érték igaz értékkel rendelkezik. A logikai műveletek <function>int 1</function>-et
            adnak  vissza igaz esetén. A egsészek és karakterek előtt használható 
            <function>unsigned/signed</function> típusminősítők segítségével
            tudjuk beállítani vagy letiltani az előjeles ábrázolást. A struktúra fix
            szerkezetű rekord, ezzel szemben a union, csak változó részt tartalmazó rekord.
            A void típus tartomány üres, tehát nincs reprezentációja, sem műveletei.    
        </para>
    </section>        
    <section>
        <title><![CDATA[K&R könyv]]></title>
        <para>
            <emphasis role="strong">Vezérlési szerkezetek</emphasis>
        </para>
        <para>
            A C nyelvben létező vezérlésátadó utasítások segítségével vagyunk képesek
            meghatározni a számítások sorrendjét. Lássuk a C leggyakoribb vezérlésátadó
            utasításait.
        </para>
        <para>
            Elsőként említsük a <emphasis role="strong">utasításokat és blokkokat</emphasis>.
            Az egyes kifejezések akkor válnak utasítássá, ha utánuk rakunk egy pontosvesszőt,
            ezzel jelezzük az utasítás végét. Képesek vagyunk az utasításokat blokkba foglalni,
            melyet a <function>{}</function>-jel segítségével tudjuk megtenni. Ezt a 
            jelülést használjuk a függvénye definíciójánál, a <function>for</function>,
            <function>while</function>, <function>if</function> utasítás által
            végrehajtott utasítsákok csoportosításra. Fontos, hogy ha kapcsoszárójelet
            használunk, akkor utána tilos pontovesszőt rakni.
            <programlisting><![CDATA[
                int a;
                for (a = 0; a < 5; a++)
                {
                    /*utasítások*/
                 }]]>
            </programlisting>
        </para>
        <para>
            Ha valamit el szeretnénk dönteni a programunkban, akkor jön nagyon jól
            az <emphasis role = "strong">if-else</emphasis> utasítás. A fejlécben 
            mindig megadunk egy kifejezést, mely alapján eldöntjük, hogy egy utasítás végre
            legyen-e hajtva, vagy sem. Az else ágra nem feltétlenül van szükség, az akkor
            hajtódik végre, ha nem teljesül az if feltétele. Az if numerikus értéket viszgál
            ezért lehetőségünk van rövídíteni a kifejezést. Pl.:
            <programlisting>
                if (kifejezés)
                if (kifejezés != 0)
            </programlisting>
            A két leírás ekvivalens egymással, az első használata viszont néha nehezen
            érthetővé teszi a kódot. Az else ággal is lehetnek értelmezésbeli
            nehézségek, mivel nem mindig könnyű az egymásba skatulyázott if-ek közül
            eldönteni, hogy melyikhez tartozik az else ág. C nyelben ez úgy van megoldva, hogy
            mindig a hozzá legközelebbi if-hez tartozik. Az esetleges kétértelműségek
            elkerülése érdekében érdemes használnoi a kapcsos zárójeleket, melyel egyértelműen
            meghatározható az utasítás vége. De ha az if/else csak egy utasítást hajt végre, akkor
            nincs szükség a kapcsos zárójelre, elég a ; használta.
            <programlisting>
                if (kifejezés)
                {
                    /*több utasítás*/
                }
                if (kifejezés)
                    utasítás;
            </programlisting>
        </para>
        <para>
            Az if-else utasítás szorosan összefügg az 
            <emphasis role="strong">else-if utasítás</emphasis> haszbnálatával.
            Ennek a segítségével több elágazásos if utasítássorozatot hozhatunk
            létre. Ha az egyik if teljesül a sorozat többi tagja már nem, ha egyik
            se teljeül, akkor itt is az else ágra kerül a vezérlés, ami akár
            el is hagyható, ha a maradék esetben semmit sem kell csinálni.
            <programlisting>
                if (1.kifejezés)
                    1. utasítás;
                else if (2.kifejezés)
                    2. utasítás;
                else
                    3. utasítás;
            </programlisting>
        </para>
        <para>
            Az else-if utasítás kiváló arra, hogy pár esetet elkülönítsünk, de
            mi van akkor, ha több tíz darab eset van. Erre találták ki a
            <emphasis role = "strong">switch</emphasis> utzasítást, amely
            megvizsgálja, hogy a kifejezés megegyezik-e valamelyik esettel, és
            ahhoz az esethez továbbítja a vezérlést.
            <programlisting>
                switch(kifejezés){
                case '1.lehetőség':
                case '2.lehetőség':
                        1. utasítás;
                case '3.lehetőség':
                case '4.lehetőség':
                case '5.lehetőség':
                        2. utasítás;
                }
            </programlisting>
            Amint látod, nem muszály mindegyik esethez külön megadni az
            utasítást, lehet őket csoportosan megadni, ezzel megkönnyítve a 
            programozó dolgát. A switch magját pedig {} jellel határoljuk.
            A <function>case</function>-en kívül használhatunk
            <function>default</function> címkét is, amivel egy alapértelmezett
            utasítást adhatunk meg, arra az esetre ha egyik eset se teljesülne.
            Fontos a <function>case</function>-ek között nem fordulhat elő azonos.
            Ha egy <function>case</function> utasítása végrehajtódik
            akkor a vezérlés a következőre ugrik. Ez viszont nem mindig szerencsés,
            ezért <function>break</function>-et kell használni mindegyikesetén, de
            ha nem is rakunk mindegyikhez, akkor is az utolsó eset után érdemes 
            rakni egy <function>break</function>-et, ezzel biztosítva, hogy a
            vezérlés nem fog szétesni.  
        </para>
        <para>
            Ha a programozási nyelvek ciklusairól beszélünk van 2 alapvető,
            amelyik mindegyikben megjelenik, így C-ben is, ezek a
            <emphasis role = "strong">for és a while</emphasis> utasítások.
            Arra használjuk őket, hogy bizonyos utasításokat ismételjünk, egészen
            addig, ameddig a fejrészükben lévő kifejezés teljesül.
            <programlisting>
                while(kifejezés)
                    utasítás
            </programlisting>
            A while így néz ki zsintaktikailag, egészen addig hajtja végre az
            utasítást, ameddig a kifejezés nem nulla. Itt egy kifejezés van,
            ezzel szemben a for ciklus nyelvtanilag 3 kifejezésből áll.
            <programlisting>
                for(kif1;kif2;kif3)
                    utsítás
                
                /*ennek a while átírata*/
                
                kif1;
                while (kif2)
                    utasítás
                    kif3
            </programlisting>
            Amint látod, a két fajta ciklus átírható egymásba, de bizonyos esetkben
            az egyik könyebben használható mint a másik. A for ciklusnál nem muszály
            mindegyik kifejezést kiírni, sőt el is hahatóak, ekkor végtelen ciklushoz
            jutunk, amelyből vagy <function>break</function>, vagy
            <function>return</function> utsítással tudunk kiugrani. A fentebbi pédában
            láthattad, hogy a for kifejezései közé ; kellett rakni, de ez nem feltétlenül
            kötelező, csak akkor más értelemmel rendelkezik.
            <programlisting>
                int i, j;
                for (i = 0, j = 10; i!=j; ++i, --j)
                    pritnf("Még nem egyenlő");
            </programlisting>
            Ilyen esetben az i-t és az j-t is léptejük egyszerre. Az i és a j
            definiálása és az értékük változtatása is egy-egy kifejéznek
            felel meg.
        </para>
        <para>
            A for és a while cilusok a kiugrási feltétel teljesülését a 
            cilus elején viszgálja, de bizsinyis esetkben jól jöhet a 
            <emphasis role="strong">do-while</emphasis> utasítás. Lényege
            az, hogy legalább 1-szer biztos, hogy belépünk a ciklusba, ezután pedig
            a gép kiértékeli a kifejezést.
            <programlisting>
                do
                    utasítás
                while (kifejezés)
            </programlisting>
        </para>
        <para>
            Már többször szó esett a ciklusokból való kilépés módjáról, ezt 
            valósítja meg a <emphasis role ="strong">break</emphasis> utasítás.
            Az utasítás hatására a vezérlés kiugrik a legbelsőbb ciklusból 
            még az előtt, hogy a kifejezést kiértékeltük volna
            az újabb iterációban. 
        </para>
        <para>
            Ha van olyan utasítás, ami megállítja a ciklust, akkor lennie kell
            olaynnak a folytatja azt. Na nem pont ilyen értelemben, de hasonlót
            csinál a <emphasis role="strong">continue</emphasis> utasítás. Ez 
            azt jelenti, hogy a vezérélés visszatér a ciklus fejéhez, tehát 
            abban az iterációbn nem csinálunk semmit, csak továbblépünk. Ezt 
            általában valamilyen feltételhez szokták kötni.
            <programlisting><![CDATA[
                int i
                for (i = 0; i < 20; ++i)
                {
                    if (i%2 != 0) continue;
                    printf("%d", i);
                }]]>
            </programlisting>
            Ebben az esetben csak a páros számokat írjuk ki, a többi számot kihagyjuk.
        </para>
        <para>
            A függvények esetén a break-hez hasonló a <emphasis role="strong">
                return</emphasis> utasítás. Ez a függvény hívójához tér vissza,
                áltatlában valmilyen értékkel, de előfordulhat, például void
                típusú függvények esetén, hogy nem ad vissza semmilyen értéket.
                <programlisting>
                    return;
                    return kifejezés;
                </programlisting>
        </para>
        <para>
            Ahogy említettem a break utasítással mindig csak a legbelső 
            ciklusból tudunk kilépni, de mi van akkor, ha mi az egymásba
            skatulyázott ciklusokból, ekkor kerül előtérbe a
            <emphasis role="strong">goto</emphasis> utasítás.
            Szintaxisát tekintve:
            <programlisting>
                for (...)
                    for (...)
                        if (kifejezés)
                            goto megoldás;
                
                megoldás:
                    tedd hamissá a kifejezést
            </programlisting>
            Tehát egy címkére ugrunk, amit a goto utasítás után megnevezünk, és
            a címkének megadjuk, hogy milyen utasítást hajtson végre. A goto
            használata viszont abszolút nélkülözhető, és használata nem is javasolt.
        </para>
        <para>
            Az előző paragrafusban látott <function>megoldás</function> egy
            <emphasis role = "strong>címkézett utasítás</emphasis>, mely a goto
            célpontja. Érvényessége arra a függvényre szól, amelyben előfordul.
        </para>
        <para>
            A létezik még a <emphasis role="strong">nulla</emphasis> utasítás.
            Ezt a használhatjuk címkék hordozására öszzetett utasításokat 
            lezáró } előtt, vagy jelölhet üres ciklusmagot is.
        </para>
    </section>        
    <section>
        <title>BME C++ könyv 1-16. oldal feldolgozás</title>
        <para>
            <emphasis role="strong">C++ nem objektum-orientált újdonságai</emphasis>
        </para>
        <para>
            A C++ lényegében a C programozási nyelv objektum-orientált változata, melynek első változata 1983-ban jelent meg. A nyelv atyjának
            Bjarne Stroustrup-ot tekintjük, aki <![CDATA[AT&T Bell]]> Laboratories-nak dolgozott. Első verzió neve C with class, ezzel utalva
            az objektum-orientáltságra. A C++ 1998-ban lett szabványosítva, azóta szabványt is kiadtak, a 2003-ast és a 2011-est. A C++ programok
            érdekessége, hogy többségük lefordul a C frodítókkal, sőt kezdetben az első C++ fordítók C kódot generáltak. Tehát minden C program C++ program, de
            nem minden C++ program C program.   
        </para>
        <para>
            Ebben a fejezetben pont azokat a különbségeket fogjuk sorra venni, amik C++-ban használhatóak, de a C-ben nem. Itt olyan funkciókra kell gondolni, amik
            segítettek kijavítani a C nyelv esetleges gyengeségeit.  
        </para>
        <para>
            Az első lényegi különbség a függvényparaméterekben és  a visszatérési értékben rejlik. A C-ben, ha nem írtunk paramétert, akkor korlátlan számú
            paramétert használhattunk, ezzel szemben a C++-ban ez annyit jelent, hogy nincs paraméter, vagyis mintha a paraméternek void típust adtunk volna meg.
            Ahhoz, hogy a korlátlan számú paramétermegadást engedélyezzük C++-ban, a paraméterlistéba <function>...</function>-t kell beírni.
            <programlisting language="c">
                //C-ben
                void f()
                {
                }
                
                //C++-ban
                void f(...)
            </programlisting>
            Egy másik különbség, hogy a C nyelvben kihagyhatjuk a visszatérési érték típusának meghatározását, azt int-nek értelmezi. Ezzel szemben C++-ban fordítási hibát
            kapunk, nem szabad kihagyni a visszatérési érték típusának meghatározását.
            <programlisting language="c++">
                void f(void); //nincs hiba
                g(void); //fordítási hiba
            </programlisting>
        </para>
        <para>
            A másik különbség a main függvényben keresendő. Az argmentum listát hagyhatjuk üresen, vagy használhatjuk az argc, argv[] argumentumokat, mellyel a parancssori argumentumok számát
            és tömbjét adja át a main-nek. Ez eddig hasióonló a C-hez, de a main végére nem szükséges oda írni a <function>return</function>-t, azt a fordító automatikusan hozzáilleszti a kódhoz.
        </para>
        <para>
            Sokáig a C++ nyelv sajátja volt a <function>bool</function> típus, mellyel logikai változókat deklarálhatunk, értéke <function>true</function>
            és <function>false</function> lehet. Ez mát a C-ben is elérhető, de előtte csak az int vagy az enum típusokkal fejezhettük ezt ki. Int esetén 0 számít 
            hamisnak és minden más érték igaz.  
        </para>
        <para>
            A C++-ban megjelet  a <function>wchar_t</function>, mint beépített típus, mely segítségével Unicode karakter stringeket tudunk reprezentálni. Ez a C-ben
            is használható, viszont ehhez #include-olni kellett a bizonyos header fájlokat.  Az iylen típusú változókat a következőképpen definiálhatjuk:
            <programlisting language="c++">
                wchar_t = L 's';
                wchar_t* = L "sss";
            </programlisting>
        </para>
        <para>
            C++-ban a változókat olyan helyeken is deklarálhatjuk, ahova utasításokat is írhatunk. Ilyen például, hogy a <function>for</function> ciklus-ban tudjuk definiálni az indexet, nem kell
            azt előtte deklarálni. Ettől függetlenül elmondható, hogy a változókat érdemes pont ott deklarálni, ahol a szeretnénk használni, ezzel áttekinthetőbb kódot kapunk. A változó csak a 
            deklarációja után érhető el. A <function>for</function> cilus fejlécében deklarált változókat nem tudjuk használni a cikluson kívül.
        </para>
        <para>
            A C nyelvben nem tudunk azonos nevű függvényket megadni, mivel azonosításként a linker csak a függvény nevét használta. Ennek következtében a programpzóknak rengetegszer kellett
            erőltett függvényneveket kitalálni. Ezt a problémát oldja meg  a C++ függvény túlterhelés funkciója, mely annyit tesz, hogy a linker a  függvényt a neve és az argumentum listája alapján
            azonosítja. Tehát létre tudunk hozni azonos nevű függvényeket, ha azok argumentumlistája eltér. Ezt a technikát név felderítésnek nevezzük. Mivel ez a C-ben nem értelmezett ez a funkció,
            kitaláltak egy módszert arra, hogy a C és C++ közötti kompataiblitást megoldjuk, ehhez a függvény deklaráció elé kell írni, hogy <function>extern int</function>. Ezzel letiltjuk a 
            név felderítő mechanizmust. 
        </para>
        <para>
            A függvényekkel kapcsolatos másik különbség, hogy a C++ kódban lehetőségünk van alapértelmezett értéket adni az argumentumoknak. Ezzel ki tudjuk küszöbölni azt, hogyha 
            nem adunk meg elég argumentumot a függvényhívásnál.
            <programlisting language="c++">
                int f( int a, int b = 100, int c = 200){
                    return a*b-c;
                }
                int main()
                {
                    int egyik = 10;
                    int masik = 20;
                    int harmadik = 30;
                    f(egyik, masik, harmadik); //érték = 10*20*30
                    f(egyik) // érték = 10*100*200
                    f() // hiba: nincs elég argumentum
                }
            </programlisting>
        </para>
        <para>
            A C++ egyik legnyagobb újdonsága pedig a referencia típus bevezetése. A C-ből tudjuk, hogy ha egy függvénynek paraméterül adunk egy változót, akkor a azt lemásolja a függvény, és nem 
            módosítja a változó értékét. Ha azt szeretnénk, hogy a függvény módosítson az értéken, ahhoz kell használni a pointert, ami a változó memóriacímére mutat. Ennek segítségével 
            közvetlenül tudjuk átadni a függvénynek a változót, nem másoljuk az  értékét. Ennek használata elég nehezen érthetővé teszi a kódot, és rengeteg hibázási lehetőséget rejt  magában.
            Hogy ezt orvosolják, bevezették a referencia típust. A referncia típusú változót <![CDATA[&]]> jellel jelöljük. Ez a jel a C-ben egyoperandusú operátor, ami a változó memóriacímét
            adja vissza. A pointer és a referencia közötti különbség:
            <programlisting><![CDATA[
                int x = 5;
                int* a = &x;
                int& b = x;
                ]]>
            </programlisting>
            Míg a pointernek egy memóriacímet kell értékül adni, addig a refernciánál csak meg kell adni, hogy melyik változóra referáljon. Ezután mindegy, hogy a b-t vagy az x-et módosítjuk,
            mind a kettőn végrehajtódik a változtatás. Érdekesség még, hogy a referencia és a változó memóriacíme megyegyezik, tehát a referencia nem foglal a memóriában területet, ellentétben
            a mutatóval.  A programokban nagyon ritkán használjuk a referenciákat a fentebb látott módon, mivel nehéz lenne olvasni egy olyan kódot, ahol uygan arra 2 változó is hivatkozik. Ezért
            ennek a fő használati értéke a cím szerinti paraméterátadásban rejlik, ezt szokták referencia szerinti paraméterátadás. A cím szerinti paraméterátadást általában akkor szoktuk 
            használni, ha változtatni akarunk az értéken, ezért a refenciának csak olyan változót adhatunk értékül, ami módosítható.(Létezik konstans típusú referncia is, de ez speciális.)
            Egy fontos dolog még ebben a témakörben az, hogy lehet-e egy függvény visszatérési értéke pointer vagy referncia. A válasz igen, lehet, de csak korlátozott esetekben, főleg cím szerinti
            paraméterátadás esetén. Összességében elmondható, hogy nem szabad visszaadni pointert és refernciát lokális változókra, vagy érték szerinti paraméterekre, mivel előfordulhat, hogy érvénytelen
            memóriacímre fognak hivatkozni.
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
