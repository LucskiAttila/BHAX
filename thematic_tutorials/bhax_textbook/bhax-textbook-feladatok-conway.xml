<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Myrmecologist">itt</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Használat előtt</title>
            <para>
                sudo apt-get install qtbase5-dev
            </para>
        </caution>
        <para>
            A program lényegében a hanygák feromonokkal történő
            kommunkiációját szimulálja. A képernyőt cellákra
            osztjuk, és a cellákban lévő hangyák megkeresik azt
            a szomszédjukat, akinek a legerősebb a feromonja, és
            arra lép tovább. A cellák fermonon értékei folyamatosan
            csökkennek, viszont ha valamelyik hangya bele lép az egyikbe, 
            akkor ott megnő a fermomon szint. Ezeket az értékeket mind 
            parancssori argumentumok formájában tudjuk megadni.
        </para>
        <para>
            A <filename>main.cpp</filename>-ben megtalálható futtatási javaslat a következő:
            <programlisting>
                ./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
            </programlisting>
            A <function>w</function> kapcsolóval állítjuk be, hogy egy cella
            hány oszlopból álljon, vagyis, milyen széles legyen, a 
            <function>m</function>-el pedig a cellák magasságát. Az
            <function>n</function> kapcsoló a hangyák számát állítja be, a 
            <function>t</function>-vel pedig a lépéseik gyakoriságát állítjuk,
            melyet miliszekundumba adunk meg. A <function>p</function>-vel
            a feromonok párolgásának a gyorsaságát állítjuk be, az
            <function>f</function>-el pedig azt, hogyha egy hangya belelép
            egy cellába, akkor mennyivel növeli meg annak a feromonértékét.
            A <function>d</function> kapcsolóval meg tudjuk adni, hogy mi legyen
            a cellák feromonértékének a kezdőértéke. Az <function>a</function>
            és a <function>i</function> kapcsolókkal meg tudjuk adni a maximális
            és a minimális fermonoértékeket. Az <function>s</function>
            kapcsoló azt állítja, hogy a hangyák mennyi feromont hagyjanak a
            szomszédos cellákban. Végezetül pedig lehetőségünk van 
            beállítani azt is, hogy az egyes cellákban maximum hány
            hangya lehessen egyszerre. Természetesen ezeket nem muszáj
            megadni, mivel vannak a programban alapértelmezett értékek a 
            futtatáshoz.
        </para>
        <caution>
            <title>Futtatás</title>
            <para>
                Mindegyik fájlnak egy mappában kell lennie. Majd:
                <programlisting>
                    qmake myrmecologist.pro
                    make
                    ./myrmecologist //+ a kapcsolók, ha szeretnéd állítani
                </programlisting>
            </para>
        </caution>
        <para>
            <figure>
                <title>Kapcsolók nélkül</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Myrmecologist/alapertelmezett.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <figure>
                <title>Kapcsolókkal</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Myrmecologist/kapcsoloval.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>
        <para>
            Most, hogy láttuk, hogyan is működik a program, lássuk magát a forrást.
            Mivel most több fájlból áll a forrás, ezért egy kicsit forradalmibb
            módon próbálom neked demonstrálni a program alapvető felépítését. Ezt
            nevezzük UML osztálydiagramnak. Segítségével könnyebben átláthatod
            a bonyolult programokat.
            <figure>
                <title>UML diagram</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Myrmecologist/uml.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
            Az ábrán láthatjuk a programunk egyes osztáylait. Azon elemek, melyek előtt
            a "-" jel szerepel, nem érhetők el az osztályon kívül, míg a "+"
            jelesek igen. Tehát ezekkel különböztetjük meg az oszrtályok 
            <function>public</function> és <function>private</function> tagjait. 
            A legkisebb osztály az <function>Ant</function>, melyet a 
            <filename>ant.h</filename> header tartalmazza.
            <programlisting language="c++"><![CDATA[
class Ant
{

public:
    int x;
    int y;
    int dir;

    Ant(int x, int y): x(x), y(y) {
        
        dir = qrand() % 8;
        
    }

};

typedef std::vector<Ant> Ants;]]>
            </programlisting>
            Ebben csak a hangyák pozícióját határozzuk meg az x és az y koordináták
            segítségével, plusz az irányát is itt számoljuk ki, melyet a 
            <function>dir</function> változóban tárolunk.
            Az utolsó sor az ábrán már külön bubrékban szerepel. A
            <function>typedef</function> segítségével az 
            <function>Ant</function> típusú elemkeből álló vektorokra 
            az <function>Ants</function> alias-szal tudunk hivatkozni.
            Tehát:
            <programlisting language="c++">
                Ants elso;
            </programlisting>
            Ebben a kódcsipetben tehát egy <function>Ant</function>
            típusú elemekből álló vektort deklaráltunk.
        </para>
        <para>
            A következő osztályunk az <function>AntWin</function>, melyet
            az <filename>antwin.h</filename> és az 
            <filename>antwin.cpp</filename>-ben találunk. A header fájlban
            vannak az egyes elemek deklarációi, míg a C++ forrás tartalmazza
            azok definícióját. Ez viszonylag gyakori eljárás a C++
            programozásban, mivel így letisztultabb kódot kapunk.
            <programlisting language="c++"><![CDATA[
#include <QMainWindow>
#include <QPainter>
#include <QString>
#include <QCloseEvent>
#include "antthread.h"
#include "ant.h"

class AntWin : public QMainWindow
{
    Q_OBJECT

public:
    AntWin(int width = 100, int height = 75,
           int delay = 120, int numAnts = 100,
           int pheromone = 10, int nbhPheromon = 3,
           int evaporation = 2, int cellDef = 1,
           int min = 2, int max = 50,
           int cellAntMax = 4, QWidget *parent = 0);

    AntThread* antThread;

    void closeEvent ( QCloseEvent *event ) {

        antThread->finish();
        antThread->wait();
        event->accept();
    }

    void keyPressEvent ( QKeyEvent *event )
    {

        if ( event->key() == Qt::Key_P ) {
            antThread->pause();
        } else if ( event->key() == Qt::Key_Q
                    ||  event->key() == Qt::Key_Escape ) {
            close();
        }

    }

    virtual ~AntWin();
    void paintEvent(QPaintEvent*);

private:

    int ***grids;
    int **grid;
    int gridIdx;
    int cellWidth;
    int cellHeight;
    int width;
    int height;
    int max;
    int min;
    Ants* ants;

public slots :
    void step ( const int &);

};]]>
            </programlisting>
            A Qt egyes funkcióinak a használatához nélkülözhetetlen a 
            fenti header-ök csatolása. A <function>QMainWindow</function>
            osztállyal tudjuk megalkotni a programunk ablakját, amiben a
            a hangyaszimuláció kirajzolódik. Kirajzolódik, ezért van szükség
            a <function>QPainter</function> osztályra. A <function>QString</function>
            osztály segítségével tudunk Unicode karakterkódulású sztringeket
            tárolni, a <function>QCloseEvent</function> segítségével pedig
            a program bezárását tudjuk szabályozni paraméterek segítségével.
            Ez a header fájl kapcsolja össze az <function>Ant</function> és
            a <function>AntThread</function> osztáylokat. Összességében elmondható,
            hogy ebben az osztályban történik meg a pogramablaknak a létrehozása,
            itt állítjuk be az egyes paramétereket, amkiet parancssori argumentumok
            segítségével a programnak át tudunk adni. A program futásának
            szüneteltetéséért és bezárásáért is ez az  osztály felelős, itt vannak 
            meghatározva az egyes billentyűkhöz rendelt tevékenységek.
        </para>
        <para>
            Maga az érdemi számítást pedig az <filename>antthread.h</filename>
            és az <filename>antthread.cpp</filename> fájlok tartalmazzák.
            Az előzőhöz hasonlóan itt is csak a headert nézzük meg:
            <programlisting language="c++"><![CDATA[
#include <QThread>
#include "ant.h"

class AntThread : public QThread
{
    Q_OBJECT

public:
    AntThread(Ants * ants, int ***grids, int width, int height,
             int delay, int numAnts, int pheromone, int nbrPheromone, 
             int evaporation, int min, int max, int cellAntMax);
    
    ~AntThread();
    
    void run();
    void finish()
    {
        running = false;
    }

    void pause()
    {
        paused = !paused;
    }

    bool isRunnung()
    {
        return running;
    }

private:
    bool running {true};
    bool paused {false};
    Ants* ants;
    int** numAntsinCells;
    int min, max;
    int cellAntMax;
    int pheromone;
    int evaporation;
    int nbrPheromone;
    int ***grids;
    int width;
    int height;
    int gridIdx;
    int delay;
    
    void timeDevel();

    int newDir(int sor, int oszlop, int vsor, int voszlop);
    void detDirs(int irany, int& ifrom, int& ito, int& jfrom, int& jto );
    int moveAnts(int **grid, int row, int col, int& retrow, int& retcol, int);
    double sumNbhs(int **grid, int row, int col, int);
    void setPheromone(int **grid, int row, int col);

signals:
    void step ( const int &);

};]]>
            </programlisting>
            A <function>Qthread</function> osztályra azért van szükség, hogy
            kezelni tudjuk a program egyes szálait. Az  <function>AntThread</function>
            osztély konstruktora megkapja azokat az értékeket, amiket az
            <function>AntWin</function> osztályban megkapott a program, majd 
            elkezdi "mozgatni" a hangyákat. Kiszámolja az irányukat a 
            feromonszintek és a cellatelítettség alapján, állítja az 
            egyes cellák feromonértékeit, és megadja az <function>AntWin</function>
            osztálynak, hogy mely cellákat kell átszínezni.
        </para>
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/Siklokilovo/Java">itt</link>               
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A feladat megoldásában tutorként részt vett Petrus József Tamás.
                Tutoráltként pedig Szabó Benedek.
            </para>
        </caution>
        <caution>
            <title>Használat</title>
            <para>
                <programlisting>
                    sudo apt-get install openjdk-8-jdk
                    javac game_of_life.java
                    java game_of_life
                </programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Melvin Conway 1970-ben alkotta meg saját sejtautomatáját.
            A sejtautomaták lényege, hogy megadunk néhány feltételt
            az életben maradásra, a születésre, és a halálozásra, majd
            figyeljük, hogy az általunk "teremtett" lények, hogyan
            "élnek". Conway 3 egyszerű szabályt adott meg,
            és mind a mai napig ez a legnépszerűbb sejtautomata.
        </para>
        <para>
            A szabályok a következők:
            <programlisting>
1. szabály: Egy sejt csak akkor marad életbe, ha 2 vagy 3 szomszédja van.
2. szabály: Ha egy sejtnek 3-nál több szomszédja van, túlnépesedés miatt
                meghal. Ha pedig 2-nél kevesebb a szomszédai száma, akkor
                pedig az elszigetelődés miatt hal meg.
3. szabály: Egy sejt megszületik, ha az üres cellának pontosan 3 élő sejt
                található a szomszédos celláiban.
            </programlisting>
            Ezen szabályok megadásával elképesztő animációkat kapunk,
            de mi most kifejezetten egyre, a siklókilövőre koncentrálunk.
            Ehhez fix cellákba helyezzük a kezdeti sejteket, és utána
            folymatosan indulnak el felfelé a siklók.
            <programlisting language="java"><![CDATA[
	public class game_of_life extends JFrame {
    RenderArea ra;
    private int i;
    
    public game_of_life() {
        super("Game of Life");
        this.setSize(1005, 1030);
        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
        this.setResizable(false);
        ra = new RenderArea();
        ra.setFocusable(true);
        ra.grabFocus();
        add(ra);
        int[][] siklokilovo = {{6,0},{6,1},
            {7,0},{7,1},
            {3,13},
            {4,12},{4,14},
            {5,11},{5,15},{5,16},{5,25},
            {6,11},{6,15},{6,16},{6,22},{6,23},{6,24},{6,25},
            {7,11},{7,15},{7,16},{7,21},{7,22},{7,23},{7,24},
            {8,12},{8,14},{8,21},{8,24},{8,34},{8,35},
            {9,13},{9,21},{9,22},{9,23},{9,24},{9,34},{9,35},
            {10,22},{10,23},{10,24},{10,25},
            {11,25}};
        int min_o = 5;
        int min_s = 85;]]>
            </programlisting>
            A <function>game_of_life</function> osztálynak a 
            <function>JFrame</function> a szülőosztálya. A 
            <function>JFrame</function> osztályra azért van szükség,
            hogy az ablak, amiben a programunk fut, megjelenjen.
            Deklarálunk egy <function>RenderArea</function> objektumot,
            mellyel a hálót és a sejteket fogjuk kirajzolni.
            A <function>game_of_life()</function> konstruktorban pont
            ezeket állítjuk be. A <function>super()</function> függvénnyel
            meghívjuk a szülő osztály konstruktorát, ezután be tudjuk 
            személyre tudjuk szabni a programablakot.
            Megadjuk az ablak nevét, a méretét. Beállítjuk
            azt, hogy hogyan záródjon be a program alapértelmezetten, és az
            átméretezhetőséget kikapcsoljuk, mivel fix abalkmérettel
            dolgozunk. Az <function>ra</function> objektumot hozzáadjuk
            az ablakhoz, így tudjuk kirajzolni a sejtautomatát. Ezután
            pedig megalkotjuk a siklókilövőhöz szükséges fix pontok
            koordinátáit. Végül pedig meghatározzuk, hol legyen az origó, 
            ahonnan a koordinátákat kirajzoljuk.
            <programlisting language="java"><![CDATA[
	for (int i = 0; i < siklokilovo.length; ++i)
        {
          ra.entities.get(min_o + siklokilovo[i][1]).set(min_s+ siklokilovo[i][0],!ra.entities.get(min_o + siklokilovo[i][1]).get((min_s+ siklokilovo[i][0])));
                this.update(this.getGraphics());  
        }
        

        ra.edit_mode = false;
        ra.running = true;]]>
            </programlisting>
            A <function>for</function> ciklusban az <function>ra</function>
            objektum <function>entities</function> listájának átadjuk a 
            kiinduló sejtek pozícióját. Majd meghívjuk az <function>update</function>
            függvényt, amely frissíti az ablak tartalmát. Ez a függvény egy 
            tagfüggvénye a <function>JComponent</function> osztálynak. Azért tudjuk elérni, 
            mert a <function>RenderArea</function> osztályunknak az őse a
            <function>JPanel</function> osztály, aminek az őse a <function>JComponent</function>.
            Abban 
            különbözik a miénktől, hogy paraméteréül kér egy 
            <function>Graphics</function> osztályú objektumot.
            Ilyen objektumot
            a <function>getGraphics()</function> függvénnyel tudunk készíteni az
            ablakunkból. 
            Az <function>edit_mode</function>-ra azért van szükség, mert
            a program képes lenne egyedi ábrák használatára is, de ez most
            nem része a feladatnak. A <function>running</function>
            pedig jelzi, hogy a program fut.
            <programlisting language="java"><![CDATA[
	public void update() {
        ArrayList<ArrayList<Boolean>> entities = new ArrayList<ArrayList<Boolean>>();// = ra.entities;
        int size1 = ra.entities.size();
        int size2 = ra.entities.get(0).size();
        for(int i=0;i<size1;i++)
        {
            entities.add( new ArrayList<Boolean>());
            for(int j=0;j<size2;j++)
            {
                int alive = 0;
                
                if(ra.entities.get((size1+i-1)%size1).get((size2+j-1)%size2)) alive++;
                if(ra.entities.get((size1+i-1)%size1).get((size2+j)%size2)) alive++;
                if(ra.entities.get((size1+i-1)%size1).get((size2+j+1)%size2)) alive++;

                if(ra.entities.get((size1+i)%size1).get((size2+j-1)%size2)) alive++;
                if(ra.entities.get((size1+i)%size1).get((size2+j+1)%size2)) alive++;

                if(ra.entities.get((size1+i+1)%size1).get((size2+j-1)%size2)) alive++;
                if(ra.entities.get((size1+i+1)%size1).get((size2+j)%size2)) alive++;
                if(ra.entities.get((size1+i+1)%size1).get((size2+j+1)%size2)) alive++;
                


                /*for(int k=-1;i<2;k++)
                {
                    for(int l = -1; l < 2 ;l++)
                    {
                        if(!(k==0 && l == 0))
                        {
                            if(ra.entities.get((size1+i+k)%size1).get((size2+j+l)%size2)) alive++;
                        }
                    }
                }*/

                if(ra.entities.get(i).get(j))
                {
                    if(alive < 2 || alive > 3)
                    {
                        //ra.entities.get(i).set(j,false);
                        entities.get(i).add(false);
                    }
                    else
                    {
                        entities.get(i).add(true);
                    }
                }
                else
                {
                    if(alive == 3)
                    {
                        //ra.entities.get(i).set(j,true);
                        entities.get(i).add(true);
                    }
                    else
                    {
                        entities.get(i).add(false);
                    }
                }

            }
        }
        ra.entities = entities;

    }]]>
            </programlisting>
            Az <function>update()</function> függvény felelős a
            Conway által meghatározott szabályok implementálásáért.
            Minden sejthez kiszámoljuk a szomszédjai számát, majd 
            a szabáylok alapján eldöntjük, hogy életben marad-e, meghal,
            vagy születik.
            <programlisting language="java"><![CDATA[	
    class RenderArea extends JPanel implements KeyListener {
        public ArrayList<ArrayList<Boolean>> entities;

        public int diff;
        public boolean edit_mode;
        public boolean running;
        public RenderArea() {
            super();
            setSize(1000, 1000);
            setVisible(true);
            setBackground(Color.WHITE);
            setForeground(Color.BLACK);
            setLocation(0, 0);

            diff = 10;
            

            
            this.addKeyListener(this);
            entities = new ArrayList<ArrayList<Boolean>>();
            for(int i=0;i<1000/diff;i++)
            {
                entities.add(new ArrayList<Boolean>());
                for(int j=0;j<1000/diff;j++)
                {
                    entities.get(i).add(false);
                }
            }
            
        }

        


        @Override
        public void keyTyped(KeyEvent e) {
            //System.out.println(e.getKeyChar());
        }
    
        @Override
        public void keyReleased(KeyEvent e) {
            System.out.println("Key pressed:"+e.getKeyChar());
            if(e.getKeyChar()=='e')
            {
                edit_mode = !edit_mode;
            }
            else if(e.getKeyChar()=='q')
            {
                this.running = false;
            }
            else if(e.getKeyChar()=='c')
            {
                if(edit_mode)
                {
                    for(int i=0;i<this.entities.size();i++)
                    {
                        for(int j=0;j<this.entities.get(1).size();j++)
                        {
                            this.entities.get(i).set(j,false);
                        }
                    }
                    this.update(this.getGraphics());
                }
                
            }

        }
    
        @Override
        public void keyPressed(KeyEvent e) {
            //System.out.println(e.getKeyChar());
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            for(int i=0;i<1000;i+=diff)
            {
                g.drawLine(i, 0, i, 1000);
            }
            for(int j=0;j<1000;j+=diff)
            {
                g.drawLine(0, j, 1000, j);
            }
            for(int i=0;i<1000;i+=diff)
            {
                for(int j=0;j<1000;j+=diff)
                {
                    if(entities.get(i/diff).get(j/diff))
                    {
                        g.setColor(Color.BLACK);
                    
                    }
                    else
                    {
                        g.setColor(Color.WHITE);
                    }
                    
                    g.fillRect(i+2, j+2, diff-3, diff-3);
                }
            }
        }

        

        private static final long serialVersionUID = 1L;
        
    }]]>
            </programlisting>
            A <function>RenderArea</function> osztály a <function>JPanel</function>
            osztály gyermeke, éa implementálja a <function>KeyListener</function>
            interfészt. Az intefész és az osztály között annyi a különbség, 
            hogy az interfészben nincsenek definiálva a tagfüggvények. Azokat
            nekünk kell definiálni a saját osztályunkon belül.  
            Az osztály konstruktorában meghívjuk a <function>JPanel</function>
            konstruktorát. Eközött és a JFrame között annyi a különbség, hogy a 
            <function>JFrame</function> osztály a fő abalkot alakítja ki, a 
            <function>JPanel</function> pedig ebbe az ablakba illeszkedik bele.
            Beállitjuk a panel szélességét, amely a fő abalkéval egyenlő, a 
            <function>setSize()</function> segítségével. A <function>setVisible(true)</function>
            láthatóvá teszi a panelt. Beállítjuk a az előtér és a háttér színét 
            feketére és fehérre. A <function>diff</function> a kirajzolandó
            háló sűrűségét határozza meg. Hozzáadjuk a panelhez a 
            billentyűzet kezelését, és a kétdimenziós listánkban minden 
            elem logikai értékét hamisra állítjuk. Tehát alap esetben minden
            sejt halott. 
            A
            <function><![CDATA[@override]]></function> címkével azt jelöljük, hogy 
            a függvény nem az osztályban van deklarálva, hiszen a <function>KeyListener</function>
            deklarálja azokat. Mivel implementáltuk ezt az interfészt, ezért minden
            tagfüggvényét kötelezően definiálnunk kel, ezért láthatod, hogy néhány
            függvény nem csinál semmit. Mi azt kezeljük, amikor a felhasználó 
            felengedi az egyik billentyűt, erre szolgál a <function>KeyReleased</function>
            függvény. Ezek közül a "q" billentyű kezelése lényeges, mivel a program
            jelenleg nem képes iteraktívitásra. Ha képes lenne, akkor az "e" billentyűvel
            lépnénk ki a szerkesztő módból. A "c" pedig a kijelölt négyzeteket tisztította volna, 
            ha előről szeretnénk kezdeni a szerkesztést. A "q" billentyűvel ki tudunk lépni a programból.
            A <function>paintComponent</function> szintén egy felüldefiniált függvény, ez a
            <function>JPanel</function> osztály tagfüggvénye. A függvény elsőnek 
            a <function>super.paintComponent</function> függvényt hívja meg. Ez újra
            rajzolja a panelt úgy, mintha mi nem módosítottunk volna a tagfüggvényen.
            Ez azért hasznos, mert így nem kell nekünk az egészet kirajzolni, csak
            azt a részt, amit módosítani szeretnénk. Tehát ha mi az 1000x1000-es panelből
            csak egy 500x500-as rész újrarajzolására szeretnénk használni
            a <function>paintComponent</function>-et, akkor a maradék részt az 
            alapértelmezett <function>paintComponent</function> kirajzolja nekünk.
            Mi ezt a függvényt  a rácsháló kirajzolására használjuk, plusz a 
            sejteket is ezzel ábrázoljuk. A hálót simán a <function>drawLine()</function>
            függvénnyel ábrázoljuk. A sejteket viszont úgy, hogy nem a teljes
            négyzetet töltjük ki, hanem adunk neki egy fehér keretet.
            <programlisting language="java"><![CDATA[
 if(entities.get(i/diff).get(j/diff))
        {
            g.setColor(Color.BLACK);
                    
        }
 else
        {
            g.setColor(Color.WHITE);
        }
                    
g.fillRect(i+2, j+2, diff-3, diff-3);]]>
            </programlisting>  
        </para>
        <para>
            Végezetül a <function>main</function>-ben példányosítunk egy
            <function>game_of_life</function> objektumot, majd addig 
            jelenítjük meg az újabb állapotokat, ameddig a felhasználó
            le nem nyomja a "q" billentyűt, vagy be nem zárja a programot.
            <programlisting language="java"><![CDATA[
    public static void main(String args[])
    {
        game_of_life gol = new game_of_life();
        while(gol.ra.running)
        {
            if(!gol.ra.edit_mode)gol.update();
            try{Thread.sleep(120);}
            catch(Exception ex)
            {

            }
            gol.ra.update(gol.ra.getGraphics());
        }
        gol.dispose();
    }]]>
            </programlisting>
            A <function>while</function> cikluson belül hívjuk meg a 
            saját <function>update()</function> függvényünket, mellyel 
            újraszámoljuk a sejtek állapotát, és pozícióját. Majd 
            a szálat altatjuk 120 miliszekundumig. Ez az utasítás azért került
            egy kivételkezelő blokkba, mert enélkül a Java fordító hibát dobott.
            A ciklus utolsó utasítása, hogy meghívjuk a másik <function>update()</function>
            függvényt, melynek segítségével frissítjuk az ablak tartalmát. A program
            futásának végeztével, pedig a <function>dipose()</function> függvénnyel
            bezárjuk az ablakot. Ez akkor hívódik meg, amikor a "q" gomb lenyomásával a
            <function>running</function> változó hamisra változik, vagyis kilépünk a 
            <function>while</function> ciklusból. 
            <figure>
                <title>Siklókilövő</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Source/Siklokilovo/Java/program.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
         </para>
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/Siklokilovo/QT">itt</link>               
        </para>
        <caution>
            <title>Használat</title>
            <para>
                <programlisting>
                    sudo apt-get install libqt4-dev
                    qmake-qt4 -project
                    qmake-qt4 *.pro
                    make
                    ./QT (vagy a bináris neve, ahogy létrejött)
                </programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az előző feladatban taglalt Conway-féle életjátékot fogjuk most megcsinálni a Qt grafikus felületet
            használva C++ nyelven. A szabályok továbbra is adottak. A sejtek meghalnak, ha 2-nél kevesebb
            a szomszédjuk vagy 3-nál több szomszédja van. Megszületik, ha pontosan 3 szomszédja van, és ha
            még abban a cellában nem él. Végezetül, ha 2-nél több, de 3-nál kevesebb a szomszédok száma,
            akkor a életben marad a sejt. Ebben a feladatban is a siklőkilövőt kell megvalósítani, de ehhez már
            tudjuk a koordinátákat, tehát ez nem lesz gond. A program nem képes önálló alakzatok megvalósítására,
            még  a forrása sem tartalmazza az ehhez szükséges kódokat.
        </para>
        <para>
            A program forrása 4 fájlból áll, erre azért van szükség, hogy áltláthatóbbak legyenek az egyes osztályok
            definíciója.
            <programlisting language="c++"><![CDATA[
#include <QtGui/QMainWindow>
#include <QPainter>
#include "sejtszal.h"

class SejtSzal;

class SejtAblak : public QMainWindow
{
    Q_OBJECT

public:
    SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);
    ~SejtAblak();
    // Egy sejt lehet élõ
    static const bool ELO = true;
    // vagy halott
    static const bool HALOTT = false;
    void vissza(int racsIndex);

protected:
    bool ***racsok;
    bool **racs;
    int racsIndex;
    // Pixelben egy cella adatai.
    int cellaSzelesseg;
    int cellaMagassag;
    // A sejttér nagysága, azaz hányszor hány cella van?
    int szelesseg;
    int magassag;    
    void paintEvent(QPaintEvent*);
    void siklo(bool **racs, int x, int y);
    void sikloKilovo(bool **racs, int x, int y);

private:
    SejtSzal* eletjatek;

};]]>
            </programlisting>
            A <filename>sejtablak.h</filename>
            fájlban előre deklaráljuk a <function>Sejtszal</function>
            osztályt, erre azért van szükség, hogy használni tudjuk
            az elemeit a <function>SejtAblak</function> osztályban.
            A <function>SejtAblak</function> osztály a <function>QMainWindow</function>
            osztály leszármazottja, ezért elérheti annak a tagfüggvényeit.
            A <function>Q_OBJECT</function> makróval tesszük lehetővé, hogy a 
            fordító kezelni tudja a Qt-s kiegészítéseket. A <function>public</function>
            részben található a konstruktor és a destruktor deklarációja. Itt definiáljuk
            a sejteket állapotát jelző változókat is, és a <function>vissza</function> függvényt. Ezek az osztályon kívül is elérhetőek.
            A <function>protected</function> rész az, amelyet a leszármazott osztályok is
            elérhetnek. Két logikia tipusra mutató mutatónk van, <function>racsokra</function>
            azért van szükség, mert 2 rácsot használunk, egyik tartalmazza az aktuális
            állapotot, a másik pedig az eggyel későbbit. Ezek valamelyikére mutata a
            <function>racs</function> mutató. A <function>racsIndex</function> azt 
            jelöli, hogy melyik rácsot használjuk éppen. A cellák méretét
            a <function>cellaSzelesseg</function> és <function>cellaMagassag</function>
            változók tárolják. A <function>paintEvent</function> egy <function>QMainWindow</function>-beli
            tagfüggvény, mellyel az aktuális rácsot rajzoljuk ki. A <function>siklokilovo</function>
            és a <function>siklo</function> függvények azt adják meg, hogy melyik pontjai legyenek
            élő sejtek a rácsnak, ahhoz, hogy a program kirajzoljon egy siklót, vagy egy siklókilövőt.
            A <function>private</function> részben pedig egy <function>Sejtszal</function> objektumra
            mutató pointert deklarálunk. 
            A <filename>sejtablak.cpp</filename> fájl tartalmazza az osztály 
            tagfüggvényinek a definiálását. Elsőnek lássuk a konstruktort:
            <programlisting language="c++"><![CDATA[
SejtAblak::SejtAblak(int szelesseg, int magassag, QWidget *parent)
    : QMainWindow(parent)
{
    setWindowTitle("A John Horton Conway-féle életjáték");

    this->magassag = magassag;
    this->szelesseg = szelesseg;

    cellaSzelesseg = 6;
    cellaMagassag = 6;

    setFixedSize(QSize(szelesseg*cellaSzelesseg, magassag*cellaMagassag));

    racsok = new bool**[2];
    racsok[0] = new bool*[magassag];
    for(int i=0; i<magassag; ++i)
        racsok[0][i] = new bool [szelesseg];
    racsok[1] = new bool*[magassag];
    for(int i=0; i<magassag; ++i)
        racsok[1][i] = new bool [szelesseg];

    racsIndex = 0;
    racs = racsok[racsIndex];
    // A kiinduló racs minden cellája HALOTT
    for(int i=0; i<magassag; ++i)
        for(int j=0; j<szelesseg; ++j)
            racs[i][j] = HALOTT;
    // A kiinduló racsra "ELOlényeket" helyezünk
    //siklo(racs, 2, 2);
    sikloKilovo(racs, 5, 60);


    eletjatek = new SejtSzal(racsok, szelesseg, magassag, 120, this);
    eletjatek->start();

}]]>
            </programlisting>
            A konstruktor egy magasságot, egy szélességet, és egy 
            <function>QWidget</function> objektumra mutató pointert kér paramétereként.
            A <function>QWidget</function> osztály adja az alapját a felhasználói felületet
            létrehozó objektumoknak.
            Érdekesség, hogy meghívja a <function>QMainWindow</function> osztály 
            konstruktorát is, aminek paraméterül átadja a pointert. Ennek köszönhetően
            be tudjuk állítani az ablak nevét a <function>setWindowTitle</function> függvéynnel.
            A <function>this</function> az aktuális objektumra mutató pointer. Ezért
            ennek segítségével adjuk meg, hogy minek a változóját szeretnénk definiálni. Ha
            nem használnánk, akkor nem tudna a fordító különbséget tenni az azonos nevű változók között.
            A <function>cellaSzelesseg</function> és <function>cellaMagassag</function>
            változóknál erre nincs szükség, azok értékét 6-ra állítjuk. A <function>setFixedSize</function>
            függvénnyel beállítjuk az ablak méretét. Ehhez <function>QSize</function>
            osztályt használjuk, ami egy kétdimenziós vektornak a méretét adja vissza.
            Ezután létrehozzuk a két rácsot, a <function>racsIndexet</function> nullára
            állítjuk, és a <function>racs</function> mutatót ráállítjuk a index által
            meghatározott rácsra. Ezt a rácsot feltöltjük csupa halott sejttel. Meghívjuk
            a <function>sikloKilovo</function> függvényt és példányosítunk egy <function>Sejtszal</function>
            objektumot, és elindítjuk a programszálat a <function>start()</function> függvénnyel.
            Ezt azért tehetjük meg, mert a <function>SejtSzal</function> osztály leszármazottja a
            <function>QThread</function> osztálynak.
            <programlisting language="c++"><![CDATA[
void SejtAblak::paintEvent(QPaintEvent*) {
    QPainter qpainter(this);

    // Az aktuális
    bool **racs = racsok[racsIndex];
    
    // racsot rajzoljuk ki:
    for(int i=0; i<magassag; ++i) { // végig lépked a sorokon
        for(int j=0; j<szelesseg; ++j) { // s az oszlopok
            // Sejt cella kirajzolása
            if(racs[i][j] == ELO)
                qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                                  cellaSzelesseg, cellaMagassag, Qt::black);
            else
                qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                                  cellaSzelesseg, cellaMagassag, Qt::white);
            qpainter.setPen(QPen(Qt::gray, 1));

            qpainter.drawRect(j*cellaSzelesseg, i*cellaMagassag,
                              cellaSzelesseg, cellaMagassag);
        }
    }

    qpainter.end();
}]]>
            </programlisting>
            A <function>paintEvent</function> függvény felelős azért, hogy a 
            sejteket kirajzoljuk az ablakba. Elsőnek példányosítunk egy 
            <function>QPainter</function> objektumot, ez az osztály felelős azért, 
            hogy rajzolni tudjunk. A <function>racsIndex</function> függvényében
            eldöntjük, hogy melyik rácsban rajzolunk. Elsőnek egy négyzetet
            kitöltünk fehérrel, ha halott, és feketével, ha élő az ott lévő sejt.
            Ehhez a <function>fillRect</function> függvényt használjuk. Majd a 
            <function>setPen</function> függvénnyel a átállítjuk a rajzoló eszköz színét
            szürkére, és 1 pixeles vastagságra. Ezzeket az értékeket a <function>QPen</function>
            osztály segítségével adjuk át a függvénynek. Végül szürke színnel körbe rajzoljuk
            a négyzetet.
            <programlisting language="c++"><![CDATA[
SejtAblak::~SejtAblak()
{
    delete eletjatek;

    for(int i=0; i<magassag; ++i) {
        delete[] racsok[0][i];
        delete[] racsok[1][i];
    }

    delete[] racsok[0];
    delete[] racsok[1];
    delete[] racsok;


}]]>
            </programlisting>
            A destruktor segítségével felszabadítjuk a pointerek által mutatott tárterületet,
            vagyis a rácsokat és a <function>Sejtszal</function> objektumot, amire
            az <function>eletjatek</function> mutat.
            <programlisting language="c++">
void SejtAblak::vissza(int racsIndex)
{
    this->racsIndex = racsIndex;
    update();
}
            </programlisting>
            A <function>vissza</function> függvény segítségével állítjuk át a <function>racsIndex</function> változót. Majd frissítjük
            az ablak tartalmát.
            <programlisting language="c++"><![CDATA[
void SejtAblak::sikloKilovo(bool **racs, int x, int y) {

    racs[y+ 6][x+ 0] = ELO;
    racs[y+ 6][x+ 1] = ELO;
    racs[y+ 7][x+ 0] = ELO;
    racs[y+ 7][x+ 1] = ELO;

    racs[y+ 3][x+ 13] = ELO;

    racs[y+ 4][x+ 12] = ELO;
    racs[y+ 4][x+ 14] = ELO;

    racs[y+ 5][x+ 11] = ELO;
    racs[y+ 5][x+ 15] = ELO;
    racs[y+ 5][x+ 16] = ELO;
    racs[y+ 5][x+ 25] = ELO;

    racs[y+ 6][x+ 11] = ELO;
    racs[y+ 6][x+ 15] = ELO;
    racs[y+ 6][x+ 16] = ELO;
    racs[y+ 6][x+ 22] = ELO;
    racs[y+ 6][x+ 23] = ELO;
    racs[y+ 6][x+ 24] = ELO;
    racs[y+ 6][x+ 25] = ELO;

    racs[y+ 7][x+ 11] = ELO;
    racs[y+ 7][x+ 15] = ELO;
    racs[y+ 7][x+ 16] = ELO;
    racs[y+ 7][x+ 21] = ELO;
    racs[y+ 7][x+ 22] = ELO;
    racs[y+ 7][x+ 23] = ELO;
    racs[y+ 7][x+ 24] = ELO;

    racs[y+ 8][x+ 12] = ELO;
    racs[y+ 8][x+ 14] = ELO;
    racs[y+ 8][x+ 21] = ELO;
    racs[y+ 8][x+ 24] = ELO;
    racs[y+ 8][x+ 34] = ELO;
    racs[y+ 8][x+ 35] = ELO;

    racs[y+ 9][x+ 13] = ELO;
    racs[y+ 9][x+ 21] = ELO;
    racs[y+ 9][x+ 22] = ELO;
    racs[y+ 9][x+ 23] = ELO;
    racs[y+ 9][x+ 24] = ELO;
    racs[y+ 9][x+ 34] = ELO;
    racs[y+ 9][x+ 35] = ELO;

    racs[y+ 10][x+ 22] = ELO;
    racs[y+ 10][x+ 23] = ELO;
    racs[y+ 10][x+ 24] = ELO;
    racs[y+ 10][x+ 25] = ELO;

    racs[y+ 11][x+ 25] = ELO;

}]]>
            </programlisting>
            A <function>siklokilovo</function> függvény pedig 
            élőre állítja <function>racs</function> mutató által mutaott rács
            megfelelő tagjait.
            <programlisting language="c++"><![CDATA[
#include <QThread>
#include "sejtablak.h"

class SejtAblak;

class SejtSzal : public QThread
{
    Q_OBJECT

public:
    SejtSzal(bool ***racsok, int szelesseg, int magassag,
             int varakozas, SejtAblak *sejtAblak);
    ~SejtSzal();
    void run();

protected:
    bool ***racsok;
    int szelesseg, magassag;
    // Megmutatja melyik rács az aktuális: [rácsIndex][][]
    int racsIndex;
    // A sejttér két egymást követõ t_n és t_n+1 diszkrét idõpillanata
    // közötti valós idõ.
    int varakozas;
    void idoFejlodes();
    int szomszedokSzama(bool **racs,
                        int sor, int oszlop, bool allapot);
    SejtAblak* sejtAblak;

};]]>
            </programlisting>
            A <filename>sejtszal.h</filename> headerben definiáljuk a <function>Sejtszal</function>
            osztályt, de a <function>SejtAblak</function> osztályt is előre deifiniáljuk.
            A <function>Sejtszal</function> osztály a <function>QThread</function> osztály
            gyermeke, mely segítségével programszálaakat kezelhetünk. Itt is használjuk a 
            <function>Q_OBJECT</function> makrót. A <function>protected</function> részben
            deklarálunk egy változót a rácsok kezelésére, a rács szélességét és magasságát
            is eltároljuk ebben az osztályban. A <function>racsIndex</function>-re szintén
            szükség van. Hogy ne legyen túl gyors a sejtautomata, ezért beállítunk egy 
            bizonyos várakozási időt, ezt az értéket a <function>vvarakozas</function>
            változóban tároljuk. Az <function>idoFejlodes</function> függvény segítségével
            implementáljuk a Conway-féle szabályokat, és az alapján eldöntjük a sejt állapotát.
            Hogy megkapjuk az adott sejt szomszédainak számát, deklarálujuk a <function>szomszedokSzama</function>
            függvényt. Végül pedig deklarálunk egy <function>SejtAblak</function> objektumra mutató pointert.
            <programlisting language="c++"><![CDATA[
SejtSzal::SejtSzal(bool ***racsok, int szelesseg, int magassag, int varakozas, SejtAblak *sejtAblak)
{
    this->racsok = racsok;
    this->szelesseg = szelesseg;
    this->magassag = magassag;
    this->varakozas = varakozas;
    this->sejtAblak = sejtAblak;

    racsIndex = 0;
}]]>
            </programlisting>
            A <function>Sejtszal</function> osztály konstruktora paramétereként kéri a kér rácsot, azok szélességét, és magasságát, valamint a várkozási időt és
            egy pointert egy <function>SejtAblak</function> objektumra. A paraméterként kapott értékeket átadjuk az osztály tagváltozóinak, és a <function>racsIndex</function>
            változót nullázzuk.
            <programlisting><![CDATA[
int SejtSzal::szomszedokSzama(bool **racs,
                              int sor, int oszlop, bool allapot) {
    int allapotuSzomszed = 0;
    // A nyolcszomszédok végigzongorázása:
    for(int i=-1; i<2; ++i)
        for(int j=-1; j<2; ++j)
            // A vizsgált sejtet magát kihagyva:
            if(!((i==0) && (j==0))) {
        // A sejttérbõl szélének szomszédai
        // a szembe oldalakon ("periódikus határfeltétel")
        int o = oszlop + j;
        if(o < 0)
            o = szelesseg-1;
        else if(o >= szelesseg)
            o = 0;

        int s = sor + i;
        if(s < 0)
            s = magassag-1;
        else if(s >= magassag)
            s = 0;

        if(racs[s][o] == allapot)
            ++allapotuSzomszed;
    }

    return allapotuSzomszed;
}]]>
            </programlisting>
            A <function>szomszedokSzama</function> függvény egy adott rács adott pontjának szomszádait viszgálja. 
            Paraméterként egy logikai változót is kap, ezzel tudjuk meghatározni, hogy élő vagy halott szomszédokat
            keresünk. Egy sejtnek nyolc szomszédja lehet, tehát ezeken megyünk végig. Magát a sejet nem viszgáljuk, ezért
            van az <function>if</function> feltétel. Egyéb esetben, ha az <function>o</function> változó értéke kisebb, mint 0, akkor
            átugrunk az utolsó oszlopra. Ha az <function>o</function> nagyobb, mint nulla, akkor pedig az első oszlopra ugrunk. Ugyanezt
            a megoldást alkalmazzuk a sorokra is. Majd megvizsgáljuk, hogy a rács <function>s</function>. sorában és
            <function>o</function>. oszlopában milyen állapotú sejt található. Ha ez megegyezik a keresett <function>allapot</function>-tal, akkor
            növeljük a <function>allapotuSzomszed</function> változó értékét 1-el. A függvény peig ennek a változónak a végső
            értékével fog visszatérni.
            <programlisting language="c++"><![CDATA[
void SejtSzal::idoFejlodes() {

    bool **racsElotte = racsok[racsIndex];
    bool **racsUtana = racsok[(racsIndex+1)%2];

    for(int i=0; i<magassag; ++i) { // sorok
        for(int j=0; j<szelesseg; ++j) { // oszlopok

            int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);

            if(racsElotte[i][j] == SejtAblak::ELO) {
                /* Élõ élõ marad, ha kettõ vagy három élõ
             szomszedja van, különben halott lesz. */
                if(elok==2 || elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }  else {
                /* Halott halott marad, ha három élõ
             szomszedja van,akkor élõ lesz. */
                if(elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
        }
    }
    racsIndex = (racsIndex+1)%2;
}]]>
            </programlisting>
            Magát a konkrét szabályokat az <function>idoFejlodes</function>
                    eljárás tartatja be, itt dől el, hogy egy sejt milyen állapotba
            kerül. Elsőnek meghatározzuk, hogy melyik rácsból váltunk melyikbe. Majd
            ezalapján a <function>racsUtana</function> rácsba betöltjük a sejtállapotokat. 
            Ahhoz, hogy ezt megtegyük, tudnunk kell, hogy az egyes sejteknek a <function>racsElotte</function>
            rácsban milyen szomszédai voltak. Ehhez meghívjuk az imént taglalt <function>szomszedokSzama</function> függvényt.
            A szabályokat a Java-s feladatban már tisztáztuk, szóval azt most nem részletezzük. A végén a rácsindexet átállítja 
            az éppen aktuálisan frissített rácsra.
            <programlisting language="c++"><![CDATA[
void SejtSzal::run()
{
    while(true) {
        QThread::msleep(varakozas);
        idoFejlodes();
        sejtAblak->vissza(racsIndex);
    }

}]]>
            </programlisting>
            A <function>run()</function> függvényt felüldefiniáljuk. Egy végtelen ciklust hozunk létre. Ebben elsőnek altatjuk az éppen futó
            programszálat, a <function>varakozas</function> változóban megadott ideig, majd meghívjuk a <function>idoFejlodes</function> függvényt.
            Végezetül pedig a <function>sejtAblak</function> objektum <function>vissza</function> függvényének átadjuk az éppen frissített rács 
            indexét, hogy az megjenelítse az ablakban az aktuális állapotot.
            <figure>
                <title>Siklókilövő</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Source/Siklokilovo/QT/program.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/BrainB">itt</link>               
        </para>
        <caution>
            <title>Passzolva</title>
            <para></para>
        </caution>
        <caution>
            <title>Használata előtt</title>
            <para>
                <programlisting>
                    sudo apt-get install libqt4-dev
                    sudo apt-get install opencv-data
                    sudo apt-get install libopencv-dev
                </programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A BrainB Benchmark feladata az esport tehetségek felkutatása lenne,
            úgy, hogy feltérképezi az agy kognitív képességeit, és az 
            elért pontszámok alapján össze lehet hasonlítani az egyes 
            egyéneket. Maga a benchmark a "karakterelvesztést" teszteli,
            vagyis ha a játékban elveszítjük a karakterünket, mennyi ideig
            tart megtalálnunk, és ha megtaláltuk, mennyi ideig tart elveszítenünk.
            Ideális esetben rövidebb ideig tart megtalálnunk, mint elveszteni.
            A program azt is figyeli, hogy az egyes karakterelvesztésekhez
            milyen bit/sec képernyőváltások tartoznak.
            <figure>
                <title>Program</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Source/BrainB/program.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
            A program így néz ki, a feladat annyi, hogy a kurzort rajta kell tartani a Samu Entropyn, minnél tovább tartod
            rajta, annál több New Entropy jelenik meg, ezzel nehezítve a dolgod. Ha elveszted, akkor a szaporodás lelassul, hogy könyebben
            megtalálhasd a karakteredet. 
            A benchmark összesen 10 percig tart, és 
            minél komplikáltabb lesz a kép a végén, annál jobb vagy.
            <figure>
                <title>Eredmény</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../../attention_raising/Source/BrainB/eredmeny.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
            A végén pedig megkapod ezt a fájlt, ami tartalmazza az elért eredményt.
            Hogy te is le tudd futattni, fontos, hogy minden fájl egy mappában legyen, majd
            pedig a következő paracsokat kell kiadni:
            <function>qmake BrainB.pro</function>, <function>make</function>,
            <function>./BrainB</function>. Ha nem szeretnéd az egész
            benchmarkot végig várni, Esc-el ki tudsz lépni bármikor, és
            az addig elért eredményedről is kapsz pontos leírást.
        </para>
        <para>
            A <filename>main.cpp</filename> nézzük át elsőnek.
            <programlisting language="c++"><![CDATA[
#include <QApplication>
#include <QTextStream>
#include <QtWidgets>
#include "BrainBWin.h"

int main ( int argc, char **argv )
{
        QApplication app ( argc, argv );

        QTextStream qout ( stdout );
        qout.setCodec ( "UTF-8" );]]>
            </programlisting>
            Mivel a program a Qt grafikus felületét használja, ezért a
            hozzzá tartozó osztályokat is szükséges hozzáfűzni a 
            forráshoz. Természetesen a <filename>BrainBWin.h</filename>-ra
            is szükségünk van, mert ezzel biztosítjuk, hogy a main-ből
            el tudjuk éerni a többi fájlt. A <function>main</function>
            a már megszokott formában köszön vissza, viszont első
            lépésként deklarálunk egy <function>QApplication</function>
            típusú objektumot, melynek paramétereként adjuk
            át a parancssori argumentumok számát, és tömbüket. A <function>qout</function>
            segítségével pedig a standard kimenetre írunk. Ez is egy objektum, amely
            QTextStream típusú. A <function>qout</function> objektumnak
            része a <function>setCodec</function> függvény, mellyel a
            karakterkódolást tudjuk beállítani.
            <programlisting language="c++"><![CDATA[
                qout << "\n" << BrainBWin::appName << QString::fromUtf8 ( " Copyright (C) 2017, 2018 Norbert Bátfai" ) << endl;]]>
            </programlisting>
            A <function>std::cout</function>-hoz hasonlóan, a <function>qout</function>-ba
            is beleshifteljük a kimenetet. A <function>BrainBWin</function> osztályról majd
            később beszélünk, de itt az osztály <function>appName</function> változóját
            érjük el és írjuk ki. A <function>QString::fromUtf8</function> függvény
            segítségével pedig UTF-8-as stringet írunk ki a parancssorba.
            <programlisting language="c++"><![CDATA[
                QRect rect = QApplication::desktop()->availableGeometry();]]>
            </programlisting>
            A <function>QRect</function> osztály segítségével egy téglalapot
            tudunk rajzolni a síkra, melynek méretét a kijelző méretével tesszük
            egyenlővé. A kijelző méretét úgy kapjuk meg, hogy a 
            <function>desktop()</function> függvéy visszaadja magát az asztalt,
            az <function>availableGeometry()</function> pedig annak a méretét.
            <programlisting language="c++">
                BrainBWin brainBWin ( rect.width(), rect.height() );
            </programlisting>
            Létrehozzuk a <function>BrainBWin</function> objektumunkat, melynek
            átadjuk a képernyő méretét. Ekkor meghívódik a <function>BrainBWin</function>
            konstruktora, amely a következőképpen néz ki:
            <programlisting language = "c++"><![CDATA[
BrainBWin::BrainBWin ( int w, int h, QWidget *parent ) : QMainWindow ( parent )
{


        statDir = appName + " " + appVersion + " - " + QDate::currentDate().toString() + QString::number ( QDateTime::currentMSecsSinceEpoch() );

        brainBThread = new BrainBThread ( w, h - yshift );
        brainBThread->start();

        connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

}]]>
            </programlisting>
            A <function>QMainWindow</function> osztály segítségével hozzuk létre a fő ablkát a 
            programnak, és ezen belül készítjükm el a <function>BrainBWin</function> ablakot. 
            A hierarchikus sorrendet úgy érjuk el, hogy a <function>BrainBWin</function>
            konstruktora meghívja a <function>QMainWindow</function> konstruktorát, és jellezzük
            neki, hogy ő a szülő. A <function>QString</function> típusú <function>statDir</function>
            változóvban tároljuk a későbiiekben létrehozandó mappa nevét. Mjd a
            <filename>BrainBWin.h</filename>-ban deklarált <function>BrainBThread</function>
            objektumra mutató muutatót ráállítjuk egy újonan lefoglalt tárterületre. Ehhez
            meghívódik a <function>BrainBTread</function> konstruktora.
            <programlisting language="c++"><![CDATA[
BrainBThread::BrainBThread ( int w, int h )
{

        dispShift = heroRectSize+heroRectSize/2;

        this->w = w - 3 * heroRectSize;
        this->h = h - 3 * heroRectSize;

        std::srand ( std::time ( 0 ) );

        Hero me ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                  this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                                                         255.0 * std::rand() / ( RAND_MAX + 1.0 ), 9 );

        Hero other1 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Norbi Entropy" );
        Hero other2 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 3, "Greta Entropy" );
        Hero other4 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Nandi Entropy" );
        Hero other5 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 7, "Matyi Entropy" );

        heroes.push_back ( me );
        heroes.push_back ( other1 );
        heroes.push_back ( other2 );
        heroes.push_back ( other4 );
        heroes.push_back ( other5 );

}]]>    
            </programlisting>
            Paramáterként átadjuk a magasságot és a szélességet. A <function>dispShift</function> 
            alapértelmezett értéke 40, és a <function>heroRectSize</function>-é is.
            AZ első sorban a <function>dispShift</function>-hez hozzáadjuk a 
            <function>heroRectSize</function> másfélszeresét. Ezután pedig 
            random számokat generálunk, és létrehozzuk az öt alapértelmezett "karaktert", ami
            meg fog jelenni a képernyőn. A <function>Hero</function> class
            a <filename>BrainBThread.h</filename>-ban van definiálva. A konstruktorának
            5 paraméterre van szüksége, de ha nem adunk meg, akkor használja az alapértelmezett
            értékeket:
            <programlisting language="c++"><![CDATA[
Hero ( int x=0, int  y=0, int color=0, int agility=1,  std::string name ="Samu Entropy" )]]>
            </programlisting>
            Az <function>me</function>-nek nem adtunk meg nevet, ezért
            ő lesz <function>Samu Entropy</function>, akit majd követni kell az egérrel.
            A létrehozott hősöket pedig a <function>heroes</function> vektorba rakjuk.
            A hősök mozgásáért a <function>move</function> függvény lesz a felelős.
            <programlisting language="c++"><![CDATA[
    void move ( int maxx, int maxy, int env ) {

        int newx = x+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 ) ;
        if ( newx-env > 0 && newx+env < maxx ) {
            x = newx;
        }
        int newy = y+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 );
        if ( newy-env > 0 && newy+env < maxy ) {
            y = newy;
        }]]>
            </programlisting>
            Ezzel új pozíciót adunk meg a hősöknek, annak a függvéynében, hogy
            hol van hozzá képest a másik hős, ezt az <function>env</function>
            változóban tároljuk. Az új pozíció meghatározásában fontos szerepe van
            az agilitásnak is, hiszen az előző x-hez az agilitás random számszorosának és
            az agilitás felének a különbségét adjuk. Ha a kapott szám és a környezet
            különbsége nagyobb,mint nulla, és összegük kisebb, mint a max x érték, akkor
            ez lesz az új x koordinátája a hősnek. Ugyan ezt hajtjuk végre az y
            koordinátával is. 
        </para>
        <para>
            A <function>BrainBThread</function> osztály definíciója a következő:
            <programlisting><![CDATA[
class BrainBThread : public QThread
{
    Q_OBJECT

    
     //Norbi
    cv::Scalar cBg { 247, 223, 208 };
    cv::Scalar cBorderAndText { 47, 8, 4 };
    cv::Scalar cCenter { 170, 18, 1 };
    cv::Scalar cBoxes { 10, 235, 252 };]]>
            </programlisting>
            A fejrészben láthatjuk, hogy a <function>BrainBThread</function>
            osztály az alosztályaa lesz a <function>QThread</function> osztálynak.
            A <function>cv::</function> használatához volt szükség az 
            openCV telepítésére. A <function>Scalar</function> osztály 
            konstruktora 4 paramétert kér, mi ebből csak 3-at adunk meg, 
            a negyediket alapértelmezett értéken hagyjuk. A változók neveiből
            sejthető, hogy jeen esetben RGB kódot tárolunk bennük, ezzel hatátozzuk
            meg a hősök színét.
            <programlisting><![CDATA[
    Heroes heroes;
    int heroRectSize {40};

    cv::Mat prev {3*heroRectSize, 3*heroRectSize, CV_8UC3, cBg };
    int bps;
    long time {0};
    long endTime {10*60*10};
    int delay {100};

    bool paused {true};
    int nofPaused {0};

    std::vector<int> lostBPS;
    std::vector<int> foundBPS;

    int w;
    int h;
    int dispShift {40};]]>
            </programlisting>
            Az első sorban deklaráljuk a <function>heroes</function> vektort.
            Majd adunk a <function>heroRectSize</function> értékét 40-re
            állítjuk, ez lényegében a hösőkt ábrázoló téglalap mérete.
            A <function>cv::Mat</function> osztály segítségével
            több dimenziós tömböt hozunk létre, amiben megadjuk a sorok,
            oszlopok számát, egy típust, és egy <function>Scalar</function>
            vektort. A típussal jelöljük, hogy a <function>Scalar</function>
            vektorban RGB színeket tárolunk. Majd létrehozzuk, a <function>bps</function>
            változót, melyben a pillanatnyi bps értékeket fogjuk tárolni. Megadjuk
            a benchmark idejét, ahogy láthatod, 10 percre van állítva. A <function>lostBPS</function>
            és a <function>foundBPS</function> vektorokban fogjuk tárolni a 
            az elvesztés és a megtalálás pillanatában fennálló bps-t.  
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
