<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/Haromszogmatrix">itt</link>               
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A feladat megoldásában tutoráltként részt vett: Országh Levente.
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban a pointerek használatával fogunk egy kicsit
            jobban megismerkedni. De mielőtt rátérnénk a forrásra, előtte
            tisztázzuk mi is az a háromszögmátrix. Ez 2 tulajdonsággal rendelkezik,
            az első, hogy négyzetes, tehát sorai és oszlopai száma
            megegyezik, a másik pedig az, hogy a főátlója alatt(a mi programunkban felett) csupa
            nulla szerepel.
            A program ezt a mátrixot fogja elkészíteni:
            <figure>
                <title>Háromszögmátrix</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Haromszogmatrix/matrix.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
            Most, hogy tudjuk, mit várunk el a programtól, nézzük meg, hogyan lehet ezt megvalósítani. Ahogy a feladat kiírásában is láthatjátok,
            ezt egy egészre mutató mutatatónak a mutatójával fogjuk létrehozni. Gondolom ez most egy kicsit
            bonyolultnak hangzik, de itt egy ábra a program egyszerű megértéséhez:
            <figure>
                <title>Pointerek a memóriában</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Haromszogmatrix/pointer.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A könnyebb megértés érdekében vegyük sorra, hogy mi is van az ábrán. Legfelül látjuk az <function><![CDATA[double **tm]]></function> mutatót, ez a deklaráció. Azért áll 4 négyzetből, mert az
            <function>double</function> típusú változók 8 bájtosak. És ez a mutató egy <function><![CDATA[double*]]></function>-ra mutat, vagyis annak a memóriacímére, a memóriacím kerül be a kék oválisba.
            Ezután láthatod a <function>tm+1</function>-et, ez azt jelenti, hogy a <function>tm</function> mutató "eggyel" arrébb mutat, vagyis 4 bájttal árrébb. 
            A <function><![CDATA[*(tm+1)]]></function>-el pedig a benne lévő értéket kaojuk meg. Ezzel ekvivalens jelölés, mely talán jobban érthető, ha úgy képzeljük el ezt,
            mintha egy tömb lenne. Tehát a <function>tm+1</function> értelmezhető így: <function><![CDATA[&tm[1]]]></function>, vagyis a <function>tm</function> tömb második elemének
            memóriacímeként. Ebből következik, hogy a <function><![CDATA[*(tm+1)]]></function> pedig a <function><![CDATA[tm[1]]]></function>, mely nem más, mint a <function>tm</function> tömb második elemének
            az értéke. Mivel még mindig a pointereknél tartunk, ezért ez az érték szintén egy memóriacím lesz, mégpedig egy <function>double</function> típusú változójé. És ezzel megérkeztünk a 
            változók szintjére, ahol már nincsenek pointerek. Ha azt akarod tudni, hogy mi a <function><![CDATA[*(tm+1)]]></function> által mutatott <function>double</function> értéke, akkor egyszerű a dolgunk,
            csak elé rakunk még egy csillagot, tehát <function><![CDATA[*(*(tm+1))]]></function>. Értelem szerűen, itt úgy tudsz a következő elemre mutatni, hogy +1-et hozzáadsz, vagyis
            <function><![CDATA[*(tm+1)+1]]></function>, ennek az értékét pedig <function><![CDATA[*(*(tm+1)+1)]]></function>. Ebben az esetben is használhatod a tömbös analógiát. Mivel a mátrix lényegében
            egy két dimenziós tömb, ezért ábrázolhatod így is <function><![CDATA[&tm[1][1]]]></function> a memóriacímet, és <function>tm[1][1]</function>-el az értékét.
            Összességében rajtad áll, hogy melyiket szeretnéd használni, kezdetben talán a tömbös megoldás érthetőbb, de érdemes hozzászokni a másikhoz, mert az az elterjedtebb. 
        </para>
        <para>
            Most elemezzük a programot sorról sorra.
            <programlisting language="c"><![CDATA[
                #include <stdio.h>
                #include <stdlib.h>

                int
                main ()
                {               
                    int nr = 5;
                    double **tm;]]>
            </programlisting>
            Az elején, ahogy már megszoktad includálj a megfelelő header fájlokat, az stdio.h ismerős
            lehet, ez kell a <function>printf</function> használatához, és most megismerkedünk
            az stdlib.h-val, mely a <function>malloc</function> utasítás használatához lesz szükséges.
            Az <function>nr</function> tartalmazza az oszlopok számát, és itt deklarájuk a
            <function><![CDATA[**tm]]></function> pointert is.
            <programlisting language="c"><![CDATA[
                printf("%p\n", &tm);
    
                if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
                {
                    return -1;
                }

                printf("%p\n", tm);]]>
            </programlisting>
            Ebben a részben a <function>printf</function> kiírja a tm memóriacímét, majd az if feltételén belül, a <function>tm</function>-et ráállítjuk a malloc által
            foglalt 5*8 bájtnyi táterületre. A malloc egy pointert ad vissza, ami a lefoglalt tárra mutat, <function>void *</function> típusút, tehát bármely típust
            vissza tud adni típuskényszerítéssel. Jelen esetben ez <function>double **</function> visszaadására kényszerítjük. Majd az if feltételeként megvizsgáljuk, hogy
            tudott-e lefoglalni területet a malloc, ha nem, akkor visszatérünk hibával. Ha a tárfoglalás sikerült, akkor kíírjuk a lefoglalt tár címét.
            Ha az ábrát visszanézed, most tartunk a második sorban.
            <programlisting language="c"><![CDATA[
                 for (int i = 0; i < nr; ++i)
                 {
                       if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
                       {
                            return -1;
                        }

                }]]>
            </programlisting>
            A <function>for</function> cikluson belül "létrehozzuk" az ábra szerinti második sor elemeit, melyek <function>double *</function> típusúak. A ciklusban 0-tól megyünk 4-ig, egyesével
            lépkedve. A <function>tm</function> mutatót itt úgy kezeljük, mint egy tömböt, és a tm által mutatott mutatókahoz foglalunk tártetületet, és ráállítjuk őket. Éredemes megfigyelni,
            hogy mindegyikhez i+1-szer 4 bájtot foglalunk le, és a malloc <function>double *</function>-ot ad vissza. Itt is megvizsgáljuk, hogy sikerült-e a foglalás, hanem hibával
            térünk vissza. Most kész a másdik sor, és mindegyik <function>double *</function> egy harmadik sorban lévő <function>double</function>-ek csopoortjának első elemére mutat, mindegyik más
            csoportra.
            <programlisting language="c"><![CDATA[
                printf("%p\n", tm[0]);    
    
                for (int i = 0; i < nr; ++i)
                    for (int j = 0; j < i + 1; ++j)
                        tm[i][j] = i * (i + 1) / 2 + j;

                for (int i = 0; i < nr; ++i)
                {
                    for (int j = 0; j < i + 1; ++j)
                        printf ("%d, ", tm[i][j]);
                    printf ("\n");
                }]]>
            </programlisting>
            Kiíratjuk a harmadik sor első <function>double</function> csoportjának első elemének a memóriacímét. Majd a for cikluson belül értéket adunk a harmadik sori <function>double</function>-eknek. Az
            <function>i</function>-vel megyünk a 4-ig, vagyis <function>nr-1</function>-ig, <function>j</function>-vel pedig mindig 0-tól i-ig. Az i jelöli a sorok számét, a j pedig
            az oszlopokét. Mártix minden eleméhez a sorszám*(szorszám+1)/2+oszlopszám, és ezzel megkapjuk a feladat legelején felvázolt mátrixot, amit a következő <function>for</function>
            -ban már csak elemenként kiíratunk.
         </para>
         <para>
             Hogy egy kicsit szokja a szemed a többféle jelölést, nézzük meg az előbb megadott mátrix néhány elemének módosítását.
             <programlisting language="c">
                  tm[3][0] = 42;
                  (*(tm + 3))[1] = 43;	// mi van, ha itt hiányzik a külső ()
                  *(tm[3] + 2) = 44;
                  *(*(tm + 3) + 3) = 45;
             </programlisting>
             Az elsőt már láttad a gyakorlatban, hogy működik, mivel a programban eddig ezt használtuk, tehát a tm 3. sorának első elemének értékét 42-re módosítjuk. Utána a harmadik sor második
             elemének az értékét változtatjuk, majd a harmadik sor harmadik elemét, végül pedig a harmadik sor negyedik elemét. Itt is láthatod, hogy az első verzió sokkal egyszerűbb a többinél, 
             főleg azoknak, akik már sokat hasznátak tömböket C-ben. A második lehetőségnél felmerül a kérdés, hogy elhagyható-e a külső zárójel. Elhagyható viszont, így nem a harmadik
             sorba lesz a módosítás, hanem a 4. sor első eleménél, mivel <function>*(tm + 3)[1]</function> azzal ekvivalens, hogy <function>*(tm+4)</function>. 
             <figure>
                <title>(*(tm + 3))[1] = 43</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Haromszogmatrix/jo.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>*(tm + 3)[1] = 43</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Haromszogmatrix/mas.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
         </para>
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/EXOR">itt</link>                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az EXOR titkosító lényegében a logikai vagyra, azaz a XOR műveletre utal, mely bitenként összeshasonlítja a két operandust, és mindig 1-et ad vissza, kivéve, amikor
            az összehasonlított 2 Bit megegyezik, mert akkor nullát. Tehát 2 operandusra van szükségünk, ez jelen esetben a titkosítandó bemenet, és a titkosításhoz használt kulcs.
            Ideális esetben a ketté mérete megyegyezik, így garantálható, hogy szinte feltörhetetlen kódot kapunk, mivel túl sokáig tart annak megfejtése. A mi pédánkban természetesen
            nem lesz ilyen hosszú a kulcs, mivel ki is szeretnénk próbálni a programot. Viszont ha a kulcs rövidebb, mint a titkosítandó szöveg, akkor a kulcs elkezd ismétlődni, ami
            biztonsági kockázatot rejt magában.
        </para>
        <para>
            Nézzük is meg ennek a titkosító algoritmusnak a C-beli implementációját, melynek majd a törő verzióját is elkészítjük a későbbiekben.
            <programlisting language="c">
                #define MAX_KULCS 100
                #define BUFFER_MERET 256
            </programlisting>
            Elsőnek a kulcs méret és a buffer méretének maximumát konstansban tároljuk el, ezek nem módosíthatóak. A szintaxisa is másabb, mint egy változó definiálásánal, itt
            lényegében azt adjuk meg, hogy mivel helyettesítse a megadott nevet a program a forrásban. Az előre definiált konstansok nevét általában nagy betűvel írjuk, ezzel
            is elkülönítve a vátozóktól. Nem csak számokat használhatunk konstansként, hanme stringeket, és kifejezéseket is. Érdekessége még, hogy nem program futtatásakor
            történik meg a behelyettesítés, hanem a már a fordítás alatt, tehát a gépi kód már behelyettesített értékeket tartalmazza.
            <programlisting language="C">
                int
                main (int argc, char **argv)
            </programlisting>
            Újabb érdekesség, hogy a <function>main()</function> definiálása itt egy kicsit másképp zajlik, mivel jelen esetben argumentumokat adunk át neki, az argumentumokat általában a 
            terminálon keresztül adjuk át, amikor futtatjuk. Az <function>argc</function>-vel adjuk át az argumentumok számát, és az argumentumokra mutató mutatókat pedig az
            <function>argv</function> tömbben tároljuk el.
            <programlisting language="c">
                char kulcs[MAX_KULCS];
                char buffer[BUFFER_MERET];
            </programlisting>
            A <function>main()</function> belül deklarálunk két tömböt, egyikbe a kulcsot tároljuk, a másikban pedig a beolvasott karaktereket, mind a kettőnek a mérete korlátozott,
            melyet még a #define segítségével adtunk meg.
            <programlisting language="c">
                int kulcs_index = 0;
                int olvasott_bajtok = 0;

                int kulcs_meret = strlen (argv[1]);
                strncpy (kulcs, argv[1], MAX_KULCS);
            </programlisting>
            Definiálunk számlálókat, melyek segítségével bejárjuk majd a kulcs tömböt, és számoljuk a beolvasott bájtokat. A kulcs méretét a <function>strlen()</function> függvénnyel kapjuk meg,
            mely jelen esetben visszadja a második parancssori argumentum hosszát. Ezután a <function>strncpy()</function> függvénnyel átmásoljuk az <function>argv[1]</function>-ben tárolt 
            sztringet karakterenként a kulcs tömbe "másolja", lényegében mindegyikhez visszaad egy pointert. A MAX_KULCS-csal pedig meghatározzuk, hogy mennyi karaktert msáoljon át.
            <programlisting><![CDATA[
                while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
                {

                    for (int i = 0; i < olvasott_bajtok; ++i)
                    {

                        buffer[i] = buffer[i] ^ kulcs[kulcs_index];
                        kulcs_index = (kulcs_index + 1) % kulcs_meret;

                    }

                write (1, buffer, olvasott_bajtok);

                }]]>
            </programlisting>
            A <function>while</function> cikluson feltétele addig lesz igaz, ameddig a <function>read</function> parancs beolvassa a megadott mennyiségű bájtokat. A <function>read</function> 
            3 argumentumot kap, az egyik a file descriptor, ami megadná, hogy honna szeretnénk beolvasni a bájtokat, jelen esetben a standard inputról olvasunk, a bájtokat a buffer-ben tároljuk
            egészen addig, ameddig el nem érjük a megadott mennyiséget, amit BUFFER_MERET definiál. A beolvasott bájtok számát adja vissza. Ezután pedig végigmegyünk elemenként a bufferben
            eltárolt karaktereken és össze EXOR-ozzuk a kulcs tömb megfelelő elemével, majd inkrementáljuk a <function>kulcs_index</function>-et 1-el, mely egésezn addig nő, ameddig el nem érjük
            a <function>kulcs_meret</function>-et, ekkor lenullázódik.
            Végezetül pedig kiírjuk a buffer tartalmát a stabdard outputra.
            <figure>
                <title>Titkosítandó szöveg</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/EXOR/tiszta.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Fordítás és futtatás</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/EXOR/exor.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Titkosított szöveg</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/EXOR/titkos.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Ebben a feladatban tutoráltként részt vett: Molnár András Imre, Pócsi Máté.
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az előző feladatát kell most java-ban megoldani. Mivel a Java a C és a C++
            alapján készült, ezért az előző kód implementációja nem nehéz feldata, de
            tarmészetesen vannak különbségek, melyeket érdemes megemlíteni.
        </para>
        <para>
            Az első és legfontosabb dolog, hogy a Java a C-vel ellentétben Objektum-orietált
            programozási nyelv, azaz létretudunk hozni objektumokat, úgynevezett class-okat
            melyekkel bizonyos utasításokat tudunk végrehajtani. A C++-ban kicsit arra hasonlít,
            mintha egy változót hoznank létre, csak nem egy típust írunk elé, hanem a class nevét.
            De ott a class elkülönül a <function>main()</function> függvénytől, míg a Java-ban 
            szerves részét képezi a classnak, tehát az egész program egy nagy class-ból áll.
            <programlisting language="java"><![CDATA[
                public class ExorTitkosító {
                    ...
                    ...
                }]]>
            </programlisting> 
            Tehát ezen belül kell mindent deklarálni és definiálni. A class-nak lehet public és private
            elemei, ezt a függvény deklaráció elé írjuk, jelen esetben nem alkalmazzunk private
            elemeket, de a lényeg az, hogy azokhoz nem férünk hozza közvetlenül a classon kívül, csak
            akkor ha a class tartalmaz egy public függvényt, amivel ki tudjuk nyerni az értéket.
        </para>
        <para>
            Elsőnek nézzük meg a <function>main</function> tartalmát:
            <programlisting language="java"><![CDATA[
     public static void main(String[] args) {
        
        try {
            
            new ExorTitkosító(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }]]>
            </programlisting>
            Az main fejléce egy kicsit furán néz ki, mivel egy kicsit bonyolultabb, mint
            azt C-ben megszoktuk. A <function>public</function> annyit tesz, hogy elérhető
            a class-on kívül is. A <function>static</function> azt jelenti, hogy a
            a <function>main</function> része a class-nak, de egy külön álló objektum,
            nem része egyik beágyazott objektumnak sem. A void-ot már ismerjük, tehát ennek
            a <function>main</function>-nek nincs visszatérési értéke. Ráadásul itt is képesek
            vagyunk parancssori argumentumokat átadni a programnak a <function>String[] args</function>
            segítségével. Egy másik újdonság a <function>try</function> és a <function>catch</function>
            használata, mely lényegében a Java-ban és a C++-ban a kivételkezéshez
            nélkülözhetetlen. A <function>try</function> blokk tartalmazza az utasításokat,
            ha valami hiba történik, akkor dobu k egy hibát, a <function>catch</function>
            "elkapja" és visszaad egy hibaüzenetet a terminálba. Jelen esetben ha nem adunk meg
            kulcsot, akkor kapunk hibát. A <function>try</function>-ban tárhelyet foglalunk az
            ExorTitkosító függvénynek, melynek átadjuk a kulcsot, a bemenetet és a kimenetet.
            <programlisting language="java"><![CDATA[
    public ExorTitkosító(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }]]>
            </programlisting>
            Az <function>ExorTitkosító</function> függvény a már említett argumentumokat kéri, és dobja
            <function>throws</function> a hibát, ha ez nem teljesül. A
            függvényen belül pedig a C kódban megismert utasításokat hajtjuk végre. Itt látható egy primitív adattípus, a <function>byte</function>, mely 8-bit-ből áll. Jelen esetben egy 
            <function>byte</function>-okból álló tömböt hozunk létre kulcs és buffer néven. Az első argumentumból a <function>getBytes()</function> függvény segítségével olvassuk be a
            kulcsot a kulcs tömbbe. A buffer tömbnek pedig foglalunk egy 256 bájt-ból álló területet a memóriában. Majd a definiáljuk a már jól ismert változókat a kulcs tömb bejárásához, és a 
            beolvasott bájtok számlálására. A <function>while</function> ciklus addig megy, ameddig be nem olvasunk a buffer méretű karaktersorozatot, vagy már nem tudunk többet beolvasni. Majd
            a beágyazott <function>for</function> ciklussal elemenként összeexorozzuk a buffer tartalmát a kulccsal, és növeljük a kulcsindexet a már megszokott módon a % operátorral, mely a
            maradékos osztást jelenti. Ennek következtében ha eléjük a kulcs tömb hosszát, akkor lenullázódik. 
        </para>
        <para>
            Végezetül lássuk, hogy hogyan kell futtatni ezt a programot:
            (A képeken létható parancsok futttaása előtt telepíteni kell ezt: sudo apt-get install openjdk-8-jdk)
            <figure>
                <title>Titkosított szöveg</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/EXOR/java_exor.png" format="PNG" scale="220"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            
        </para>
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/Source/EXOR">itt</link>                
        </para>
        <para>
            <emphasis role = "strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Ebben a feladatban tutorként és tutoráltként részt vett: Imre Dalma, György Dóra.
            </para>
        </caution>
        <para>
            Az előbbi feéadatokban láthattad, hogy hogyan lehet tikosított szövegeket készíteni az EXOR titkosítás segítségéval. Most ennek
            az ellentétét kell megcsinálnunk, ami egy kicsit trükkösebb, és talán nem is tökéletes, de az előző feladatban generált
            titkos szöveg feltörésére alkalmas lesz.
        </para>
        <para>
            <programlisting>
                #define MAX_TITKOS 4096
                #define OLVASAS_BUFFER 256
                #define KULCS_MERET 8
            </programlisting>
            Ezúttal is meghatározunk bizonyos konstansokat, ebből a kulcs_meret érdekes, mert feltételezzük, hogy a kulcs 8 elemből áll, már
            itt látni, hogy ez nem lenne túl hatékony a való életben.
            <programlisting><![CDATA[
                double
                atlagos_szohossz (const char *titkos, int titkos_meret)
                {
                    int sz = 0;
                    for (int i = 0; i < titkos_meret; ++i)
                        if (titkos[i] == ' ')
                            ++sz;

                    return (double) titkos_meret / sz;
                }]]>
            </programlisting>
            Az <function>atlagos_szohossz</function> függvénnyel kiszámítjuk a bemenet átlagos szóhosszát, argumentumként átadjuk egy tömböt, és annak a méretét. Majd egy <function>for</function>
            ciklussal bejárjuk, és minden elem után hozzáadunk 1-et az <function>sz</function> változóhoz. Visszatérési értékként pedig a tömb méretének és a számlálónka a hányadosát
            adjuk.
            <programlisting language="c"><![CDATA[
                int
                tiszta_lehet (const char *titkos, int titkos_meret)
                {
                    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
                    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
                    // potenciális töréseket

                    double szohossz = atlagos_szohossz (titkos, titkos_meret);

                    return szohossz > 6.0 && szohossz < 9.0
                        && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
                        && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

                }]]>
            </programlisting>
            A <function>tiszta_lehet</function> függvény az átlagos szóhossz segítségével vizsgálja, hogy a fejtésben lévő kód tiszta-e már. Itt meg kell felelni az átlagos magyar szóhossznak,
            és a leggyakoribb szavakat tartalmaznia kell. Felmerül a kérdés, hogy mi történik akkor, ha ezeknek nem felel meg a törni kívánt szöveg? Sajnos akkor nem tudjuk feltörni, tehát
            ez egy újabb gyengesége a programunknak.
            <programlisting language="c"><![CDATA[
            void
            exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
            {

                int kulcs_index = 0;

                for (int i = 0; i < titkos_meret; ++i)
                {

                    titkos[i] = titkos[i] ^ kulcs[kulcs_index];
                    kulcs_index = (kulcs_index + 1) % kulcs_meret;

                }

            }]]>
            </programlisting>
            Az <function>exor</function> függvény uygan azt csinálja, mint az EXOR titkosító, mivel ha valamit kétszer EXOR-ozunk, akkor visszakapjuk önmagát. Lényegében ezzel
            állítjuk vissza a tiszta szöveget. Ez argumentumként megkap egy lehetséges kulcsot, annak méretét, és magát a titkosított szöveget, annak méretével együtt.
            <programlisting language = "c">
                int
                exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
                        int titkos_meret)
                {

                    exor (kulcs, kulcs_meret, titkos, titkos_meret);

                   return tiszta_lehet (titkos, titkos_meret);

                }
            </programlisting>
            Az <function>exor_tores</function> hívja a korábban definiált függvényeket, és 0-át vagy 1-et ad vissza, attól függően, hogy tiszta-e már a szöveg.
            <programlisting language="c">
                char kulcs[KULCS_MERET];
                char titkos[MAX_TITKOS];
                char *p = titkos;
                int olvasott_bajtok;
            </programlisting>
            Mostmár áttérhetünk a <function>main</function> belüli deklarációkra, definíciókra. Elsőnek deklarálunk egy kulcs[] tömböt, és egy titkos[] tömböt. Ezek mérete a fentebb
            már rögzített értékekkel lesz azonos.  Majd definiálunk egy mutatót, mely a titkos[] tömbre mutat, és deklaráljuk a beolvasott bájtok számlálóját.
            <programlisting language="c"><![CDATA[
                while ((olvasott_bajtok =
                        read (0, (void *) p,
                        (p - titkos + OLVASAS_BUFFER <
                        MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
                        p += olvasott_bajtok;]]>
            </programlisting>
            A <function>while</function> ciklussal addig olvassuk a bájtokat, ameddig a buffer be nem telik, vagy a bemenet végére nem érünk.
            <programlisting language = "c"><![CDATA[
                for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
                        titkos[p - titkos + i] = '\0';]]>
            </programlisting>
            Ezzel a <function>for</function> ciklussal kinullázzuk a buffer megmaradt helyeit, és utána pedig előállítjuk az összes lehetséges kulcsot:
            <programlisting language="c"><![CDATA[
   for (int ii = '0'; ii <= '9'; ++ii)
    for (int ji = '0'; ji <= '9'; ++ji)
      for (int ki = '0'; ki <= '9'; ++ki)
	for (int li = '0'; li <= '9'; ++li)
	  for (int mi = '0'; mi <= '9'; ++mi)
	    for (int ni = '0'; ni <= '9'; ++ni)
	      for (int oi = '0'; oi <= '9'; ++oi)
		for (int pi = '0'; pi <= '9'; ++pi)
		  {
		    kulcs[0] = ii;
		    kulcs[1] = ji;
		    kulcs[2] = ki;
		    kulcs[3] = li;
		    kulcs[4] = mi;
		    kulcs[5] = ni;
		    kulcs[6] = oi;
		    kulcs[7] = pi;

		    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
		      printf
			("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
			 ii, ji, ki, li, mi, ni, oi, pi, titkos);

		    // ujra EXOR-ozunk, igy nem kell egy masodik buffer  
		    exor (kulcs, KULCS_MERET, titkos, p - titkos);
		  }]]>
            </programlisting>
            Végig futatjuk az összes lehetőségen a <function>for</function> ciklust, majd meghívjuk az <function>exor_tores</function> függvényt. Ha ez igazat ad, tehát a
            visszatérési érték 1, akkor kiíratjuk az aktuális kulcsot és a feltört szöveget. Ahogy látod ez csak olyan kódokat tud feltörni, amit számokkal
            kódoltunk. Ezután pedig újra meghívjuk az <function>exor</function> függvényt, ezzel elkerülve a második buffer létrehozását. Az előző feladatban én a betűket és számokat is használtam, ezt is ki lehetne bővíteni, hogy fel tudjuk törni azt a kódot, de az a baj, hogy
            nagyon sokáig tartana. Tehát ennél a megoldásnál maradva újratitkosítottam az tiszta.txt-t  
            <figure>
                <title>Törés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/EXOR/törés.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A <filename>t.c</filename> fordítva és futtatva a képen látható módon folyamatosan kapjuk a lehetséges megfejtéseket, fontos hogy nem kell végig
            várni a folyamatot, mert az sokáig tart, Ctrl+c-vel meg tudod állítani. Jelen esetben láthatod, hogy sikerült megtalálnia a megfelelő kódot.
            <figure>
                <title>Törés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/EXOR/eredmény.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban újra visszatérünk a Monty Hall problémánál megismert R nyelvhez. Segítségével
            neurális hálózatot fogunk létrehozni, mely képes "tanulni", és megközelíteni az átalunk megadott
            megfelelő értékeket. A hálózat a nevét a neuronról kapta, mely gyunk egy sejtje. Feladata az elektromos 
            jelek összegyűjtése, feldolgozás és szétterjesztése. Az a feltételezés, hogy az agyunk információfeldolgozási
            képességét ezen sejtek  hálózata adja. Éppen emiatt a mesterséges intelligencia kutatások során ennek a szimulálást
            tűzték ki célul. A neuron matematikai modeljét McCulloch és Pitts alkotta meg 1943. Ezt mutatja a következő ábra:
            <figure>
                <title>Neuron</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/NN_R/neuron.png" format="PNG" scale="700"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A lényeg, hogy a neuron akkor fog tüzelni, ha a bemenetek súlyozott
            összege meghaladnak egy küszöböt. Az aktivációs függvény adja meg a kimenet értékét.
        </para>
        <para>
            Ezt a modellt fogjuk implementálni egy R programba. Az első részben a logikai
            vagyot tanítjuk meg a neurális hálózatnak, mely 1-et ad vissza, kivéve, ha mind a két
            operandusa 0, mert akkor 0-át.
            <programlisting><![CDATA[
library(neuralnet)

a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
OR    <- c(0,1,1,1)

or.data <- data.frame(a1, a2, OR)

nn.or <- neuralnet(OR~a1+a2, or.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.or)

compute(nn.or, or.data[,1:2])]]>
            </programlisting>
            A neurarnet könyvtárat kell használni a feladat megoldásához. Az a1, a2, OR
            változókhoz hozzárndeljük a megfelelő értékeket, amit szeretnénk betanítani
            a programnak. Majd az or.data-ban tároljuk el ezeket a változókat, melyek
            a betanítás alapjául fognak szolgálni. Az nn.or változó értékéül pedig a 
            <function>neuralnet</function> függvény visszatérési értékét adjuk. Ennek 
            a függvénynek több argumentuma van, ezeket vegyük gyorsan sorra. Az első elem
            maga a formula, amit meg kell tanulni a programnak, majd jön egy minta, mely
            alapján a tanulást végzi, a harmadik argumentum a rejtett neuronok számát adja meg.
            A <function>linear.output</function> egy logikai változó, melynek értékét TRUE-ra
            kell állítani, ha azt szeretnénk, hogy az aktuvációs függvény ne fusson le a 
            kimeneti neuronokra. A stepmax adja meg a maximum lépésszámát a neuron háló tanulásának,
            mely befejeződik, ha elérjük ezt az értéket. A <function>threshold</function>
            pedig számérték, mely meghatározza a hiba részleges deriváltjainak küszöbértékét, 
            a tanulás megállási kritériumaként funkcionál. Ezután pedig <function>plot</function>
            kirajzoltatjuk a neurális háló tanulási folyamatának egy állapotát. A neuralnet
            minden bementhez kiszámol egy súlyozást, amellyel megszorozza a bemenet értékét.Majd pedig
            kiszámítjuk a logikai művelet neurális háló szerinti értékét, és összevetjük
            a referencia értékkekkel.
            <figure>
                <title>OR</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/NN_R/or.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
        A jobb oldali kis ablakban láthatod, hogy egészen jó közelítéssel sikerült
        visszaadnia a megfeleő értékeket a programnak. Ugyan ezt megismételjük az AND logikai
        operátorral is, mely akkor lesz igaz, azaz 1, ha mind a 2 operandusa 1, amúgy hamis.
        <programlisting><![CDATA[
 a1    <- c(0,1,0,1)
a2    <- c(0,0,1,1)
AND   <- c(0,0,0,1)

and.data <- data.frame(a1, a2, OR, AND)

nn.and <- neuralnet(AND~a1+a2, orand.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.and)

compute(nn.and, and.data[,1:2])]]>
        </programlisting>
        <figure>
                <title>AND</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/NN_R/and.png" format="PNG" scale="140"/>
                        </imageobject>
                    </mediaobject>
        </figure>
        </para>
        <para>
            Ezután pedig jönne az EXOR, viszont ez már nem annyira egyszerű. Amikor régen
            ezt a technológiát kitalálták, és az EXOR nem működött, sokan elpártoltak tőle.
            Majd a kor nagy matematikusai megfejtették, hogy nem lehetetlen feladat, csak egy
            apróságra van szükség, létre kell hozni a rejtett neuronokat, melyek segítik a tanulást.
            <programlisting><![CDATA[
a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])]]>
            </programlisting>
            <figure>
                <title>EXOR első próba</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/NN_R/exor_1.png" format="PNG" scale="140"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Látható, hogy nagyon nagy a hibaarány, és még az eredmények is tévesek lettek,
            mindegyik 0,5 körüli lett, az 1 és a 0 helyett. A <function>neuralnet</function>
            <function>hidden</function> argumentuma 0-ra volt állítva ebben az esetben, tehát
            nem használtunk rejtett neuronokat. Ha ezt átállítjuk, akkor a következőt kapjuk:
            <programlisting><![CDATA[
a1      <- c(0,1,0,1)
a2      <- c(0,0,1,1)
EXOR    <- c(0,1,1,0)

exor.data <- data.frame(a1, a2, EXOR)

nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

plot(nn.exor)

compute(nn.exor, exor.data[,1:2])]]>
            </programlisting>
            Módosítottuk a rejtett neutronok számát, elsőnek 6, majd 4 és végül
            megint 6 neuront hozunk létre. Lássuk az eredményt:
            <figure>
                <title>EXOR második próba</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/NN_R/exor_2.png" format="PNG" scale="140"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Láthatod, hogy sikerült, megkaptuk a helyes eredményeket, bár az ábra jóval
            bonyolultabb lett a rejtett neuronok miatt.
        </para>
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Perceptron">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban folytatjuk a elmélkedést a neuron hálózatokra, ezen belül
            perceptronokról lesz szó. Ez egy algoritmus amely a számítógépnek "megtanítja"
            a bináris osztályozást. Ide is berakhatnám az előző fejezetben lévő képet
            a neuronról, ami egy bemenetet kap, és egy bizonyos pontot elérve "tüzel", ad
            egy kimenetet. Itt is hasonló dologról van szó:
            <figure>
                <title>Perceptron bemenet</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Perceptron/percepron.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Tehát van egy halmaz amiben vannak piros és fekete pontok, a fekete pontok a vonal
            felett vannak, a pirosak pedig alatta. Adok a perceptronnak bemenetként egyet-egyet
            mind a kettőből, és a képes lesz megmondani a többite, hogy a vonal felett van-e,
            vagy alatta. Ezért nevezzük bináris osztáylozásnak, mert van a vonal felettiek osztálya
            és az alattiaké, ez a kapcsolat könnyen reprezentálható eggyel és nullával.
        </para>
        <para>
            Akkor lássuk magát a programot. Most C++-ban fogunk dolgozni, melyről tettem már
            említést a Java-s feladatban, szóval annyit már tudsz, hogy ez is egy
            objektum-orientált nyelv, szóval a class-okat képtelenség lesz elkerülni. 3 fájlre lesz
            szükség, abból az egyikkel, <filename>mandelpng.cpp</filename>-vel most nem
            foglalkoznék, hiszen a következő fejezetben pont erről lesz szó. Egyelőre legyen
            elég annyi, hogy ezzel tudunk készíteni egy képet, ami a Mandelbrot halmazt
            ábrázolja.
            <figure>
                <title>mandelpng.cpp fordítása és futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Perceptron/fordit.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Mivel a program tartalmazza a png.hpp header fájlt, ezért van szükség a -lpng
            kapcsolóra. A png.hpp-t a <emphasis role="strong">sudo apt-get install libpng++-dev tudod telepíteni.</emphasis>
            <figure>
                <title>Mandelbrot-halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Perceptron/mandel.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Ez a kép lesz a bemenete a perceptron algoritmust szimuláló programunknak. Az első dolog
            amit nagyon fontos, hogy most 2 fájlból áll a programunk. A <filename>ml.hpp</filename> és
            <filename>main.cpp</filename>-re lesz szükségünk. Az <filename>ml.hpp</filename>
            tartalmazza a Perceptron class-t, ezzel a <filename>main.cpp</filename> sokkal
            átláthatóbb. Ezt technikát gyakran használják, szóval érdemes megtanulni. Magát a 
            class-t most nem vesézzük ki, helyette vessünk egy pillantást a main-re.
            <programlisting language="c++"><![CDATA[
#include <iostream>
#include "ml.hpp"
#include <png++/png.hpp>

int main (int argc, char **argv)
{
                ...
}]]>
            </programlisting>
            Itt láthatod, hogyan kell az ml.hpp-t includálni, maga a main fejrésze pedig
            az EXOR-nál már jól megszokott felépítést követi.
            <programlisting language="c++"><![CDATA[
                png::image <png::rgb_pixel> png_image (argv[1]);]]>
            </programlisting> 
            Ezzel létrehozzunk egy üres png-t, melynek mérete megegyezik a bemenetként kapott
            fájl méretével. Ehhez van szükség a png.hpp headerre. Egy fontos dolog még, hogy
            miért van szükség a dupla kettőpontra. A C++-ban létezik egy olyan fogalom, hogy
            névterek. Erről még fogunk szót ejteni, de gyelőre annyi elég lesz róla, hogy a
            png.hpp-ben használt függvények, változók elé oda kell rakni a png:: -ot. Ugyan
            így van ez az iostream-ben lévő <function>cout</function>-tal is, mely a standard
            kimenetre írja ki azt amit szeretnénk. Előtte az std:: prefixet használjuk. Lényegében
            ez azért hasznos, mert ha lenne a png.hpp-ben és az iostream-ben is <function>cout</function>
            , akkor ezzel meg tudjuk őket különböztetni. Persze kicsit hosszú mindegyik
            elé odaírni, és lesz is rá majd megoldás, de ennek használatát egyelőre kerüljük.
            <programlisting language="c++"><![CDATA[
    int size = png_image.get_width() * png_image.get_height();
    
    Perceptron* p = new Perceptron (3, size, 256, 1);
    
    double* image = new double[size];]]>
            </programlisting>
            A kép méretét eltároljuk egy változóban, majd létrehozunk felhasználó által
            definiált típust, ez a <function>Perceptron</function>, melyet a <filename>ml.hpp</filename>
            Perceptron osztályában találunk. Lényegében itt adjuk meg a rétegek számát, jelen esetben
            ez 3, majd azt adjuk meg, hogy hány darab neuront szeretnénk az egyes rétegekben. Az utolsóba
            csak 1-et rakunk, mely az eredményt adja majd. Definiálunk még egy double* pointert,
            melyet size-zal megyegyező memóriaterületre állítunk rá.
            <programlisting language = "c++"><![CDATA[
      for (int i = 0; i<png_image.get_width(); ++i)
        for (int j = 0; j<png_image.get_height(); ++j)
            image[i*png_image.get_width() + j] = png_image[i][j].red;]]>
            </programlisting> 
            Az egymásba ágyazott for cilusok segítségével az újonan lefogllat tárba másoljuk
            bele a beolvasott kép pixeleinek piros komponensét.
            <programlisting language = "c++">
                double value = (*p) (image);
            </programlisting>
            Itt meghívjuk a Perceptron class () operátorát, mely vissza fogja adni az nekünk
            szükséges eredményt. Végezetül ezt már csak kiíratjuk a <function>cout</function>-tal.
            <programlisting language="c++"><![CDATA[
                std::cout << value << std::endl;]]>
            </programlisting>
            Futassuk:
            <figure>
                <title>Fordítás és futtatás</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Perceptron/fordit_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Fontos figyelembe venned, hogy nem mindig fogja ugyanazt az értéket adni, szóval
            nem kell kétségbe esni, ha nem ugyan az jön ki, mint a képen.
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
