<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
                
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban a Lisp nyelvet fogjuk megismerni. A nyelvet John McCarthy alkotta meg 1958-ban.
            Ez nevezhető a második magas szintű programozási nyelvnek, melynél csak a Fortran régebbi. Ez az
            alapján gondolhatnánk azt, hogy nem sok értelme van róla beszélni, tekintve korát, de a 
            mesterséges intelligencia kutatások egyre nagyobb előretörése újra előtérbe hozta. Most
            nem a mestreséges intelligenciával foglalkozunk, és nem is a Lisp nyelvvel önmagában, hanem
            a GIMP képszerkesztő programjának egy különlegességével. Ezt nevezik Script-fu-nak, mely lehetőséget
            ad, hogy a Windows rendszereken megismert makrókhoz hasonló dolgokat alkossunk meg. Ehhez pedig a 
            Lisp nyelvet fogjuk használni. A nyelv szintaktikailag nem bonyolult, viszont van pár dolog, amire oda 
            kell figyelni. Ilyen az, hogy nem infix alakban kell megadni a műveleteket, hanem prefix-ben. A másik 
            fontos dolog, hogy a zárójelek használatára is oda kell figyelni, ugyanis a Lisp teljesen zárójelezett 
            programozási nyelv. Nézzük is, hogy hogyan néz ki a feladat megoldása.  
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Magát a gimpet így tudod letölteni (terminálon keresztül):
                <programlisting>
                    sudo apt-get install gimp
                </programlisting>
            </para>
        </caution>
        <para>
            Maga a faktoriális kiszámítása nyelvtől függetlenül ugyan úgy
            kell megoldani. Persze vannak eltérő megoldások, de az alapja ugyanaz.
            Az <function>n!</function> faktoriális értéke a következő:
            <programlisting>
                n * (n-1) * (n-2) ... * 2 * 1
            </programlisting>
            Az iteratív megoldásnál adná magát, hogy egy <function>for</function>
            vagy egy <function>while</function> ciklust kéne használni. De ez
            Lispben nem egészen így van. Ciklust fogunk használni, ami nagyon 
            hasonlít a <function>while</function> ciklushoz, viszont ezt expliciten
            nem írjuk ki.
            <programlisting><![CDATA[
(define (fakt n)
    (if (= 0 n) 
                (set! n 1)
    )
    (let loop ((variable (- n 1)))
        (if (> variable 1)                               
            (begin
                (set! n (* n variable))
                (loop (- variable 1) )
            )
        )
    )
    n
)]]>
            </programlisting>
            Tehát definiálunk egy függvényt, aminek a neve <function>fakt</function>,
            és egy paramétert kér. Az első <function>if</function>-ben ellenőrizzük, hogy
            a megadott paraméter nulla-e. Ha igen, akkor az <function>n</function> értékét
            1-re állítjuk, mivel ez a 0! értéke.
            A <function>let</function> operátor teszi lehetővé, hogy
            változókat hozzunk létre, és azokkal művelteket hajtsunk végre. Jelen esetben a
            ciklusváltozót hozzuk létre, melynek értéke paraméterül kapott szám és az 1
            különbsége. Aztán megfogalmazunk egy feltételt, ha a változó nagyobb, mint
            1, akkor a paraméter értékét megváltozatatjuk a faktoriális szabályának
            megfelelően. Tehát a <function>set</function> segítségével adhatunk
            új értéket egy véktozónak. Ha ezt megtettük, akkor a csökkentjük a 
            ciklusváltozót 1-el. Végezetül pedig visszadjuk az <function>n</function>
            értékét, amikor a ciklus lefutott.
        </para>
        <para>
            Az iteratív megoldással szemben a rekurzív sokkal rövidebb, viszont 
            átlátni talán egy kicsit nehezebb, hogy mi is történik a háttérben.
            <programlisting><![CDATA[
(define (fakt n)
    (
    if (< n 1) 
         1 
    (* n (fakt (- n 1))) ;else ag
    )
)]]>
            </programlisting>
            A függvény fejrésze teljesen megegyezik az előző példával, de utána
            láthatjuk a rekurzív megoldás erősségét. Nincs szükségünk ciklusokra.
            Ezt azzal érjük el, hogy a függvény önmagát hívja meg, abban az esetben, ha
            a paraméter értéke nagyobb, mint 1. Ellenkező esetben pedig 1-et 
            adunk vissza.
            Matematikai szempontból ez a megoldás
            teljesen helyes és pontos. Viszont fontos látni, hogy programozói szempontból
            a ez tartalmaz egy felesleges függvéynhívást. Hiszen a vezérlés akkor is
            az <function>else</function> ágra ugrik, amikor az <function>n</function> 1, pedig
            tudjuk 1!-nak az értéke 1.
            A programot így módosíthatjuk:
            <programlisting><![CDATA[
(define (fakt n)
    (
    if (< n 2) 
         1 
    (* n (fakt (- n 1))) ;else ag
    )
)]]>  
            </programlisting>
            Ezzel a módosítással elérjük. hogyha az <function>n</function> 1, akkor
            ne ugorjon a vezérlés az <function>else</function> ágra. Hogy jobban lásd, mi is történik a háttérben ennél a
            megoldásnál, vess egy pillantást az alábbi ábrára:
            <figure>
                <title>Rekurzió</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/fakt_seged.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A képen láthatod, hogyan is zajlik az 5!-nak a kiszámolása. Tehát folyamatosan
            az <function>else</function> ágra ugrik a vezérlés, egészen addig, ameddig el
            nem érünk az 1!-ig. Ekkor visszatérünk eggyel, és fokozatosan haladunk vissza
            a hívási láncba, mindig visszaadva a megfelelő értéket, vagyis az éppen
            aktuális n és az (n-1) szorzatát.
        </para>
    </section>

    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <caution>
            <title>Használat</title>
            <para>
                Ha már telepítetted a faktorálisos feladat alapján a GIMP-et, akkor
                a következőt kell tenned, hogy használhasd a scriptet:
                <programlisting><![CDATA[
cp *.scm /home/<user_name>/snap/gimp/165/.config/GIMP/2.10/scripts/]]>
                </programlisting>
                Ha új betústílusokat akarsz hozzáadni a GIMP-hez, akkor pedig ezt:
                <programlisting><![CDATA[
cp *.ttf /home/<user_name>/snap/gimp/165/.config/GIMP/2.10/fonts/]]>
                </programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A mandala lényegében egy alakzat, amit a neved forgatásával, állítasz elő.
            Magát az alakzatot a GIMP-ben bárki meg tudja csinálni, erről egy
            <link xlink:href="https://bit.ly/2GGZaU4">tutoriál</link> található az 
            interneten. A mi programunk is nagyjából ezt valósítja meg, azzal a 
            különbséggel, hogy a folyamatok automatizálva vannak, tehát nem kell
            kézzel előállítani a saját mandaládat.
        </para>            
        <para>
            Az előző feladatokban már megismerkedtünk a Lisp programozási 
            nyelvvel, szóval a szintaktika már nem lesz újdonság, lássuk is a 
            forrást:
            <programlisting><![CDATA[
(define (elem x lista)

    (if (= x 1) (car lista) (elem (- x 1) ( cdr lista ) ) )

)]]>
            </programlisting>
            Az első függvényünk egy listának az <function>x.</function> elemét
            adja vissza. Ehhez a rekurziót használjuk, tehát ha az első elemét
            keressük a listának, akkor a <function>car</function> függvénysegítségével
            visszaadjuk, de ha nem, akkor lesz szükség további hívásokra. A 
            megoldás lényege, hogy mindig eggyel kisebb <function>x</function>-re
            hívjuk meg az <function>elem</function> függvényt, és a lista első 
            elemét töröljük. Ha egy 5 elemű lstából ki szeretnénk venni az utolsó
            elemet, akkor tehát 4-szer hívja meg önmagát a fóüggvény, majd visszaadja
            a lista első elemét, ami ekkor már az eredeti lista utolsó eleme lesz.
            <programlisting>
(define (text-width text font fontsize)
(let*
    (
        (text-width 1)
    )
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    

    text-width
    )
)
            </programlisting>
            A <function>text-width</function> függvény paraméteréül egy szöveget
            kér, annak a betűstílusát és a méretét. A <function>let*</function>
            függvény segítségével definiálunk egy változót. A <function>set!</function>
            függvény beállítja a <function>text_width</function> változó értékét az
            általunk megadott értékre. Jelen esetben ez a <function>gimp-text-get-extents-fontname</function>
            függvény által visszaadott lista első eleme. Ez a függvény egy szövegdobozt
            hoz létre az általunk megadott szöveggel, és ennek a szövegdoboznak a 
            szélességével, magasságával tér vissza. A visszaadott listában van
            még két elem, de azok a feladat megoldásának sezmpontjából nem fontosak.
            Tehát a függvény visszaadja a szövegünk szélességét.
            <programlisting>
(define (text-wh text font fontsize)
(let*
    (
        (text-width 1)
        (text-height 1)
    )
    ;;;
    (set! text-width (car (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;; ved ki a lista 2. elemét
    (set! text-height (elem 2  (gimp-text-get-extents-fontname text fontsize PIXELS font)))    
    ;;;    
    
    (list text-width text-height)
    )
)  
            </programlisting>
            Ez a függvény nagyon hasonlít az előzőre, de ebben az a különbség, hogy nem
            csak a szélességet, de a magasságot is vissza kell adnunk. Az eredeti 
            mandalához elég lenne az előző függvény, de a mi programunk a 
            mandala közepére kiír egy másik szöveget is. Ennek a helyes pozícionálásához
            nélkülözhetetlen a <function>text-wh</function> függvény. Mivel a 
            <function>gimp-text-get-extents-fontname</function> által visszaadott
            lista második eleme a magasság, ezért használjuk a már korábban megírt
            <function>elem</function> függvényt, ezzel a <function>text-height</function>
            változó értékét is meg tudjuk határozni. Végezetelül visszadajuk a 
            szövegdoboz szélességéből és magasságából álló listát. 
        </para>
        <para>
            Az eddig tárgyalt függvények csak segédfüggvények voltak, a mandala
            készítő függvény most jön.
            <programlisting>
(define (script-fu-bhax-mandala text text2 font fontsize width height text2_color gradient)
(let*
    (
        (image (car (gimp-image-new width height 0)))
        (layer (car (gimp-layer-new image width height RGB-IMAGE "bg" 100 LAYER-MODE-NORMAL-LEGACY)))
        (textfs)
        (text-layer)
        (text-width (text-width text font fontsize))
        ;;;
        (text2-width (car (text-wh text2 font fontsize)))
        (text2-height (elem 2 (text-wh text2 font fontsize)))
        ;;;
        (textfs-width)
        (textfs-height)
        (gradient-layer)
    ) 
            </programlisting>
            A neve <function>script-fu-bhax-mandala</function>. Alap esetben csak
            egy szöveget kérne paraméteréül, de most kettőt kérünk a 
            felhasználótól. Megadható a betűstílus, a betűméret, a kép mérete, a második
            szöveg színe és
            a kép elkészítéséhez szükséges grádiens.
            A szokásos módon létrehozunk változókat. Az <function>image</function>
            változóban tároljuk a képet, amit a <function>gimp-image-new</function>-val
            létrehozunk. Ennek képnek a mérete az általunk megadott paraméterek. Ezután
            létrehozunk egy új réteget, amelynél megadjuk, hogy melyik képhez
            adja hozzá az új réteget, meagdjuk a réteg méretét, a típusát, ami 
            jelen esetben RGB, tehát a réteg képes lesz kezelni az RGB színeket. Ezeken
            felül megadható a réteg neve, az átlátszósága és a réteg kombináció módja.
            A új réteget a <function>layer</function> változóban tároljuk. Ezen a részen
            érdemes még megemlíteni a <function>text-width</function>, 
            <function>text2-width</function> és <function>text2-height</function>
            változókat. Ezeknek az értékét a már fentebb taglalt függvényekkel
            számoljuk ki. A többi változóról majd a későbbiekben lesz szó.
            <programlisting>
    (gimp-image-insert-layer image layer 0 0)

    (gimp-context-set-foreground '(0 255 0))
    (gimp-drawable-fill layer FILL-FOREGROUND)
    (gimp-image-undo-disable image) 

    (gimp-context-set-foreground text2_color)
            </programlisting>
            A <function>gimp-context-insert-layer</function> függvény azt 
            teszi lehetővé, hogy egy réteget hozzáadjunk egy képhez. Jelen
            esetben az <function>image</function> változóban tárolt
            képhez adjuk hozzá a korábban létrehozott rétegünket. Az utolsó
            2 paraméter a szülő réteg számát és a beillesztés helyét adja meg.
            Tehát a réteg a kép többi rétegével egyenrangú lesz, mivel egyik sem a 
            szülője, és ő kerül legfelülre.
            A <function>gimp-context-set-foreground</function>
            segitségével lehet az előtérszínt módosítani, de ez nem azt jelenti, hogy
            ezzel a paranccsal a kép ilyen színű lesz, csak ezután bármit írnánk, 
            rajzolnánk a képre, az ilyen színű lenne. A <function>gimp-drawable-fill</function>
            segítségével színezzük be a rétegünket az előbb megadott előtérszínnel.
            A <function>gimp-image-undo-disable</function> arra szolgál, hogy ne lehessen
            visszavonni az előző módosításokat az <function>image</function>-en. Végezetül
            újra meghívjuk a <function>gimp-context-set-foreground</function>, ezúttal
            a második szöveg színe lesz ilyen. Ha már elolvastad a belinkelt 
            tutoriált, akkor tudhatod, hogy elsőnek maga az ábra is ilyen lesz, csak
            utána alkalmazunk rá grádienst, ami átszínezi a többit.
            <programlisting>
    (set! textfs (car (gimp-text-layer-new image text font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text-width 2))  (/ height 2))
    (gimp-layer-resize-to-image-size textfs)
            </programlisting>
            A <function>textfs</function> változóban tároljuk el a 
            <function>gimp-text-layer-new</function> által létrehozott
            szöveges rétegünket, amelhez meg kell adni, hogy melyik képre
            szeretnénk ráilleszteni, milyen szöveggel, milyen 
            betűstílussal és betűmérettel. Ezen kívül, még azt is
            meg kell adni, hogy a betűméretet milyen mértékegységben adtuk meg, jelen
            esetben pixelekben. Ezt a réteget beszúrjuk az <function>image</function>-be,
            egészen pontosan az éppen aktív réteg fölé. A <function>gimp-layer-set-offsets</function>
            függvépyn felelős a réteg eltolásának a meghatározásában. Tehát a 
            szöveget űgy toljuk el, hogy az x-tengelyen középen legyen, viszont az y
            tengelyen kicsit lejjebb, mint a középérték. Végezetül pedig a réteget
            a kép ,méretével megegyezővé tesszük a <function>gimp-layer-resize-to-image-size</function>
            függvénnyel. Ezután létrehozunk egy új réteget.
            <programlisting>
    (set! text-layer (car (gimp-layer-new-from-drawable textfs image)))
    (gimp-image-insert-layer image text-layer 0 -1)
    (gimp-item-transform-rotate-simple text-layer ROTATE-180 TRUE 0 0)
    (set! textfs (car(gimp-image-merge-down image text-layer CLIP-TO-BOTTOM-LAYER)))
            </programlisting>
            Az új réteget úgy kapjuk, hogy lényegében lemásoljuk az <function>textfs</function>
            réteget. Ehhez a <function>gimp-layer-new-from-drawable</function> függvényre
            van szükség. Majd a réteget uygan úgy beillesztjük a képbe, mint előzőleg, tehát
            az éppen aktív réteg fölé. Majd elforgatjuk 180°-al, ehhez a
            <function>gimp-item-transform-rotate-simple</function> függvényt használjuk. 
            A paraméterekj közül egyértelmű, hogy meg kell adni, hogy mit forgatunk, és hány
            fokban. Viszont az utolsó 3 már érdekesebb, a <function>TRUE</function>
            azt jelenti, hogy a automatikusan a kijelölés közepe körül forgasson, az 
            utolsó kettő pedig a forgatás középpontjának koordinátái. A 
            <function>gimp-image-merge-down</function> függvény a képnek a megadott
            rétegét és az alatta lévő első látható réteget vonja össze. A 
            <function>CLIP-TO-BOTTOM-LAYER</function> paraméter azt adja meg, hogy a 
            az eredményül kapott réteget olyan méretűre kell állítani, mint a legalsó réteg.
            Ugyanezeket a lépéseket végzi el a program még 90°-al, 45°-al és 30°-al.
            Ha kész van a forgatásokkl előállított alakzat, akkor következik annak 
            szépítése.
            <programlisting>
    (plug-in-autocrop-layer RUN-NONINTERACTIVE image textfs)
    (set! textfs-width (+ (car(gimp-drawable-width textfs)) 100))
    (set! textfs-height (+ (car(gimp-drawable-height textfs)) 100))  
            </programlisting>
            A <function>plug-in-autocrop-layer</function> körbevágja az
            aktív réteget, vagyis azt, amelyiken az alakzatunk van. A 
            <function>textfs-width</function> és a <function>textfs-height</function> 
            változóknak átadjuk a <function>textfs</function> réteg 100x100 pixellel
            növelt méretét.
            <programlisting>
    (gimp-layer-resize-to-image-size textfs)
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
    (plug-in-sel2path RUN-NONINTERACTIVE image textfs)
            </programlisting>
            A <function>textfs</function> méretét visszaálltjuk a képpel megegyező méretre,
            majd ellipszis kijelölést alkalmazunk a képen. Ehhez meg kell adnunk
            az ellipszist magába foglaló téglalap bal felső sarkának koordinátáit, és magának 
            a téglalapnak a szélességét és magasságát. Ezt az ellipszis kijelölést a 
            <function>plug-in-sel2path</function> függvény segítségével görbévé alakítjuk.
            <programlisting>
    (gimp-context-set-brush-size 22)
    (gimp-edit-stroke textfs) 
            </programlisting>
            A létrehozott görbe vonalvastagságát a <function>gimp-context-set-brush-size</function>
            függvénnyel állítjuk be. A <function>gimp-edit-stroke</function> pedig a 
            <function>textfs</function> rétegben kijelült területet, vagyis a görbét az 
            előtér színére színezi. Ezekkel az utasításokkal létrehoztuk a külső 
            gyűrűt, ugyanígy hozzuk létre a belsőt is.
            <programlisting>
    (set! textfs-width (- textfs-width 70))
    (set! textfs-height (- textfs-height 70))
    
    (gimp-image-select-ellipse image CHANNEL-OP-REPLACE (- (- (/ width 2) (/ textfs-width 2)) 18) 
        (- (- (/ height 2) (/ textfs-height 2)) 18) (+ textfs-width 36) (+ textfs-height 36))
    (plug-in-sel2path RUN-NONINTERACTIVE image textfs)
        
    (gimp-context-set-brush-size 8)
    (gimp-edit-stroke textfs)
            </programlisting>
            Annyia különbség, hogy csökkentjük a <function>textfs-width</function>
            és a <function>textfs-height</function> változók értékét 70-nel. Egy másik
            különbség, hogy a vonalvastagsága is vékonyabb lesz a belső gyűrűnek.
            Ha nem alkalmaznánk grádienst, aza szín átmenetet, akkor itt véget is
            érhetne a program, a következő eredménnyel:
            <figure>
                <title>Alap mandala</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Mandala/elso.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Ennél még befolyásolhatjuk mandala színét a <function>text2_color</function>
            néven átadott paraméter segítségével, ahogy azt a feladat elején is említettem.
            De ezzel nem elégszünk meg, nézzük, hogyan lehet tovább javítani a kinézetét.
        </para>
        <para>
            Következő lépésként a színátmenetet oldjuk meg, mellyel sokkal látványosabb
            mandalákat lehet készíteni.
            <programlisting>
    (set! gradient-layer (car (gimp-layer-new image width height 
                RGB-IMAGE "gradient" 100 LAYER-MODE-NORMAL-LEGACY)))
            </programlisting>
            Első lépésként létrehozunk egy új réteget, melynek szélesége és
            magassága megyegyezik a kép méretével, ez is RGB színeket használ, és
            teljesen átlátszó.
            <programlisting>
    (gimp-image-insert-layer image gradient-layer 0 -1)
    (gimp-image-select-item image CHANNEL-OP-REPLACE textfs)
    (gimp-context-set-gradient gradient) 
    (gimp-edit-blend gradient-layer BLEND-CUSTOM LAYER-MODE-NORMAL-LEGACY GRADIENT-RADIAL 100 0 REPEAT-NONE FALSE TRUE 5 .1 TRUE 500 500 (+ (+ 500 (/ textfs-width 2)) 8) 500)
            </programlisting>
            A szokásos módon az új réteget, amit a <function>gradient-layer</function>
            változóban tárolunk, a kép utolsó aktív rétege fölé. A
            <function>gimp-image-select-item</function> függvény a megadott réteget
            kijelöléssé alakítja, vagyi annak az alfa csatornáját. A kijelölt területre
            a <function>gimp-edit-blend</function> függvény segítségével tudunk
            színátmenetet beállítani, melynek paraméteréül a felhasználó által megadott 
            grádiens nevét, a színezés módját, a színátmenet típusát és azt a területet, ahol színezni szeretnénk,
            kell megadni. Rengeteg más paramétere van, de ezek a legfontosabbak.
            <programlisting>
                (plug-in-sel2path RUN-NONINTERACTIVE image textfs)
            </programlisting>
            A kijelölést görbévé alakítjuk a szokásos módon.
            <programlisting>
    (set! textfs (car (gimp-text-layer-new image text2 font fontsize PIXELS)))
    (gimp-image-insert-layer image textfs 0 -1)
    (gimp-layer-set-offsets textfs (- (/ width 2) (/ text2-width 2)) (- (/ height 2) (/ text2-height 2)))
            </programlisting>
            A második szöveget, amit meg tudunk adni, ezekkel a sorokkal helyezzük al a kép közepére.
            <programlisting>
    (gimp-selection-none image)
    
    (gimp-display-new image)
    (gimp-image-clean-all image)
    )
)
            </programlisting>
            Végezetül pedig megszüntetjük a kijelölést, a képet új ablakban jelenítjük meg a 
            GIMP-ben, ehhez a <function>gimp-display-new</function> függvéynt használjuk.
            A <function>gimp-image-clean-all</function> függvénnyel pedig eltüntetjük a
            képből a szükségtelen információkat.
            Ahhoz, hogy alaértelmezett értékeket állítsunk be a felhasználóknak a 
            következő utsasításokat kell elvégezni:
            <programlisting>
(script-fu-register "script-fu-bhax-mandala"
    "Mandala9"
    "Creates a mandala from a text box."
    "Norbert Bátfai"
    "Copyright 2019, Norbert Bátfai"
    "January 9, 2019"
    ""
    SF-STRING       "Text"      "Bátf41 Haxor"
    SF-STRING       "Text2"     "BHAX"
    SF-FONT         "Font"      "Sans"
    SF-ADJUSTMENT   "Font size" '(100 1 1000 1 10 0 1)
    SF-VALUE        "Width"     "1000"
    SF-VALUE        "Height"    "1000"
    SF-COLOR        "Color"     '(255 0 0)
    SF-GRADIENT     "Gradient"  "Deep Sea"
)
            </programlisting>
            Ebben a részben adhatunk nevet, magyarázó szöveget a scriptünknek. Beállíthatjuk, hogy
            a script megnyitásakor mik legyenek az alap értékek, amiből a felhasználó kiindulhat.
            Azt pedig, hogy honnan legyen elérhető a script a GIMP menüjéből a követkeőképpen
            tudjuk meghatározni:
            <programlisting><![CDATA[
(script-fu-menu-register "script-fu-bhax-mandala" 
    "<Image>/File/Create/BHAX"
)]]>
            </programlisting>
            Végezetül pedig lássuk, hogy milyen képet tudunk készíteni ezzel a scripttel.
            <figure>
                <title>Végső mandala</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/GIMP_Lisp/Mandala/vege.png" format="PNG" scale="200"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                
