<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot">itt</link>               
        </para>
        <para>
            Mielőtt a Mandelbrot halmazzal foglalkoznánk, elsőnek tisztázzuk, hogy
            mik is a fraktálok, és mi a kapcsolatuk a MAndelbrot-halmazzal. A
            fraktálok lényegében olyan alakzatok, melyek végtelenül komplexek.
            Két fő tulajdonságuk van, az egyik, hogy a legtöbb geometria alakzattal
            ellentétben a fraktálok szélei "szakadozottak", nem egyenletesek. A 
            másik tulajdonságuk pedig, hogy nagyon hasonlítanak egymásra. Ha egy 
            kör határfelületét folyamatosan nagyítjuk, egy idő után kisimul(a
            csúcsokat leszámítva), megkülönböztethetetlenné válik egy egyenestől.
            Ezzel szemben a fraktálok első tulajdonsága, mi szerint határfelöletük
            szakadozott, megmarad, függetlenül a nagyítás mértékétől.
            A Mandelbrot halmaz is a fraktálok közé tartozik. Ezt és a hozzá 
            tartozó szabályt Benoit Mandelbrot fedezte fel 1979-ben. A halmaz
            komplex számokból áll, melyek az alábbi sorozat elemei:
            <emphasis role="strong">x<subscript>1</subscript>:=c,
            x<subscript>n+1</subscript>:=(x<subscript>n</subscript>)<superscript>2</superscript>
            +c</emphasis>, és ez a sorozat konvergens, azaz korlátos. Ezeket a 
            számokat ábrázolva a komplex számsíkon kapjuk meg a Mandelbrot-halmaz
            híres farktálját.
            <figure>
                <title>Mandelbrot halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/mandelbrot.png" format="PNG" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
            Ezt az ábrát fogjuk mi megalkotni a C++ programunkkal. Ehhez a png++ header
            fájlra lesz szükségünk, mely nincs alapból telepítve. 
            A <function>sudo apt-get install libpng++-dev</function> paranccsal tudjuk
            feltelepíteni, és a g++ fordító használatánál szükségünk lesz a 
            <function>-lpng</function> kapcsolóra. Most vegyük szépen végig a programot.
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
#include <iostream>
#include <png++/png.hpp>

int main (int argc, char *argv[])
{
    ...
}]]>
            </programlisting>
            Tehát, ahogy már említettem, szükségünk lesz a <function>p++/png.hpp</function>
            header-re. Parancssori algumentum segítségével adjuk meg, hogy melyik
            fájlba szeretnénk elmenteni a képet.
            <programlisting language="c++"><![CDATA[
    if (argc != 2) {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }]]>
            </programlisting>
            Ha nem adjuk meg az argumentumot, akkor dobunk egy hibaüzenetet, amely
            tartalmazza, a helyes használat leírását. Ha megadtuk az argumentumot,
            akkor elkezdődik a lényeg.
            <programlisting language="c++">
    double a = -2.0, b = .7,  c = -1.35, d = 1.35;
    int szelesseg = 600, magassag = 600, iteraciosHatar = 1000;
            </programlisting>
            Első lépésként megadjuk a függvény értékkészletét és
            értelmezésitartományát. Majd meghatározzuk a létrehozandó
            kép méretét, és az iterációs határt.
            <programlisting language="c++"><![CDATA[
                png::image <png::rgb_pixel> kep (szelesseg, magassag);]]>
            </programlisting>
            Ezzel az utasítással létrehozunk egy üres png-t, melybe majd 
            betöltjük a Mandelbrot halmaz ábráját.
            <programlisting language="c++">
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
            </programlisting>
            Megadjuk a lépésközt, amellyel majd végig megyünk a koordináta-rendszer
            rácspontjain. Deklaráljuk a változókat, amikben a c és a z komplex 
            számok valós és imaginárius részét fogjuk tárolni. Ezután pedig 
            végigmegyünk a rácson 2 egymásba ágyazott for ciklus segítségével.
            <programlisting language="c++"><![CDATA[
    for (int j=0; j<magassag; ++j) {
        for (int k=0; k<szelesseg; ++k) {
            reC = a+k*dx;
            imC = d-j*dy;
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            while (reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                
                ++iteracio;
                
            }
            
            kep.set_pixel(k, j, png::rgb_pixel(255-iteracio%256,
                                               255-iteracio%256, 255-iteracio%256));
        }
        std::cout << "." << std::flush;
    }]]>
            </programlisting>
            A valós számokat képesek vagyunk egy számegyenesen ábrázolni, de 
            a komplex számokat már nem, szükségünk van ugyanis egy másik tengelyre
            amelyen a képzetes részeket ábrázoljuk. Így lényegében egy 
            koordináta rendszert kapunk, ahol minden számnak van egy x és
            egy y koordinátája, jelen esetben egy valós és egy képzetes rész.
            Tehát elkezdünk végig lépkedni az értelmezési tartományon, és minden
            iterációban megadjuk a c számot, melyhez kiszámoljuk a z értékeket.
            Ehhez van szükség egy while ciklusra, melyben egészen addig számoljuk
            a halmaz következő elemeit, ameddig a z komplex szám négyzete kisebb, mint
            4 és még nem értük el az iterációs határt. Ha elértük az iterációs határt,
            az iteráció konvergens, tehát a c eleme a Mandelbrot halmaznak.
            <programlisting language = "c++">
                kep.set_pixel(k, j, png::rgb_pixel(255-iteracio%256,
                                               255-iteracio%256, 255-iteracio%256));
            </programlisting> 
            Megadjuk létehozott png képünk egyes pixeleinek a 
            megfelelőt színt, ezzel kirajzolódik a Mandelbrot-halmaz ábrája.
            <programlisting language="c++">
                kep.write (argv[1])
            </programlisting>
            Végezetül pedig a létrehozott képünk tartalmát beleírjük abba fájlba, amit
            a felhasználó megad argumentumként.
            <figure>
                <title>Program fordítás, futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/futtatas.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/abra.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot">itt</link>               
        </para>
        <para>
            Az előző feladatot fogjuk megoldani, csak most egy kicsit másképpen. Ahogy láttad,
            az előbb a komplex számokat két változóban tároltuk, egyikben a valós, ,másikban
            pedig a képzetes részét. De az infromatikusok lusták, mindek használnánk 2
            változót, ha lehet egyet is. Ezt teszi számunkra lehetőve a <function>complex</function>
            library, melynek segítségével a gép képes kezelni ezeket a számokat.
        </para>
        <para>
            Ahogy az előbb, most is végigfutunk a forráson. Az első különbség ott van, hogy
            a felhasználó adhatja meg a létrehozandó kép attribútumait, de ezt ki is hagyhatjuk,
            akkor az alapértelmezett értékeket használja a program.  
            <programlisting language="c++">
  int szelesseg = 1920;
  intmagassag = 1080;
  intiteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
            </programlisting>
            Az <function>atoi</function> és <function>atof</function> segítségével
            tudjuk átalakítani a parancssori argumentum stringet
            <function>int</function> és <function>double</function> típusra.
            Ezután létrehozzuk az üres png-t, mint legutóbb, majd a szükséges 
            változókat.
            <programlisting language = "c++"><![CDATA[
  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;]]>
            </programlisting>
            A két egymásba ágyazott for ciklus segítségével bejárjuk a rácsot,és
            beállítjuk a kép pixeleit a megfelelő értékre, mely most eltér az 
            előzőhöz képest. Itt egy színesebb ábrát fogunk kapni, az 
            előzőhöz képest.
            <programlisting><![CDATA[
 for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam
          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0; 
      //kiírja, hogy hány százaléknél tart a képgenerálás
      std::cout << "\r" << szazalek << "%" << std::flush;
    }]]>
            </programlisting>
        
        Na itt néhány dolog eltér az előző feladathoz képest. Itt használjuk elsőnek
        a complex típust, ami <function>double</function>-ket tartalmaz, és két
        részből áll, a valós és az imaginárius részből. Ennek a segítségével
        definiáljuk a c és a z_n változókat. Majd, innen már ismerős lehet, 
        kiszámoljuk minden c esetén a z_n-eket, és ha elérjük az iterációs határt
        akkor, tudhatjuk, hogy az iteráció konvergens.
        Ebből következik, hogy
        a c eleme a Mandelbrot halmaznak.  A while fejrészében 
        látható <function>abs()</function> függvény az abszolút értékét adja meg
        az bemenetként kapott argumentumának. A halmazt lértehozó sorozat
        képzési szabálya egy az egyben beírható a programba, nincs szükség
        semmilyen szétbontásra, mint az előző programnál volt, köszönhetően
        annak, hogy képesek vagyunk kezelni a komplex számokat. 
        Pusz dolog, hogy a a program a futása 
        azt is látjuk, hogy hány százalékát végezte el a számításoknak a gép. 
        Végezetül pedig itt is kiírjuk a png fájlt a parancssori argumnetumként 
        megadott fájlba a <function>write</function> segítségével.
            <figure>
                <title>Program fordítása és futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/futtatas_c.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot halmaz</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/abra_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Tovább folytatjuk a Mandelbrot-os témakört. Ezzel a feladattal nem egészen 
            direkt a kapcsolata a Mandelbrot halmaznak, inkább a Julia halmazokkal
            lesz szoros rokonságban. A Mandelbrot halmaz tartalmazza az összes Julia
            halmazt. Ez abból következik, hogy a Julia halmaz esetén a c konstans, és
            a rácsot a z-vel járjuk be, viszont a Mandelbrot halmazban a c változóként
            szerepel, melyhez kiszámoljuk a z értékeket. Szóval mindig újabb és újabb 
            Julia halmazt számolunk ki vele. 
        </para>
        <para>
            A Biomorfokra Clifford Pickover talált rá, méghozzá egy Julia halmazt rajzoló
            prgramjának írása közben. A programja rejtett egy bugot, és emiatt egészen
            furcsa dolgokat produkált a program, melyre azt hitte, hogy valami természeti
            csodára lelt rá. Magáról a Biomorfokról, és a Pickover történetéről
            részletesebben olvashatsz
            <link xlink:href="https://bit.ly/2HCbCYs">itt</link>.
            Mi is ez alapján készítettük el a biomorf rajzoló programunkat, mely
            a Mandelbrot-os programra alapul, annak egy továbbfejlesztett verziója.
        </para> 
        <para>
            A program eleje teljesen megegyezik a Mandelbrot halmazos programunkkal, azzal
            a kivétellel, hogy most a felhasználótól kérjük be a cc konstans érékét, és a 
            küszöbszámot. Ezek az adatok megtalálhatóak a cikkben, minden biomorfhoz 
            külön-külön.
            <programlisting language = "c++"><![CDATA[
#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }]]>
            </programlisting>
            Ahogy látható a parancssori argumentumok száma 10-re nőtt, melyeket
            nem kötelező megadni, ilyenkor az alapértelmezett értékeket használja.
            Ezt követően létrehozzuk az üres png-t, a lépésközt a rácsok között,
            és most a cc szám deklarációja is a cikluson kívülre kerül, mivel
            az jelen esetben konstans.
            <programlisting language="c++"><![CDATA[
    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );]]>
            </programlisting>
            Egy kisebb átalakításra volt szükség a cilusok tekintetében, melyet 
            ezen algoritmus alapján módosítottunk:
            <programlisting><![CDATA[
1 for x = xmin to xmax by s do
2   for y = ymin to ymax by s do
3       z = x + yi
4       ic = 0
5       for i = 1 to K do
6           z = f(z) + c
7           if |z| > R then
8               ic = i
9               break
10      PrintDotAt(x, y) with color ic
//forrás: https://bit.ly/2HCbCYs]]>
            </programlisting>
            Ennek a C++ implementációja a következő:
            <programlisting><![CDATA[
 for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, z_n) + std::pow(z_n,6) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*60)%255, (iteracio*100)%255, (iteracio*40)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }]]>
            </programlisting>
            A két egymásba ágyazott for ciklus segítségével végigmegyünk a rácspontokon
            és egy harmadik for ciklussal pedig kiszámoljuk a függvéynértékeket,
            egészen addig, amíg el nem érjük az iterációs határt, vagy nem 
            teljesül ez a feltétel:
            <programlisting language="c++"><![CDATA[
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)]]>
            </programlisting>
            Ez volt az a bug, amit Clifford Pickover programja tartalmazott,
            egy sor, ami nélkül ez a feladat lehet, hogy soha nem készült
            volna el.
            Végezetül pedig beállítjuk az egyes pixelek színét, makd kírjuk egy fájlba
            a tartalmát.
            <programlisting language="c++">
                kep.write ( argv[1] );
            </programlisting>
            <figure>
                <title>Program fordítása és futtatása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Biomorf/futtat.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Biomorf</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Biomorf/biomorf.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Sajnos nem sikerült elérni ugyanazt a színt, mint a cikkben, de lényeg
            ezen is látható.
        </para>                       
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/CUDA">itt</link> 
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Tovább folytatjuk a MAndelbrot-halmazos programunk fejlesztését, ezúttal
            az Nvidia CUDA technológiáját hívjuk segítségül, mallyel jelentősen fel tudjuk
            gyorsítani a kép generálását. A tecknika lényege, hogy egy 600x600 darab blokkból
            álló gridet hozunk létre, és mindegy blokkhoz tartozik egy szál. Ezzel
            sikerül a program futását párhuzamosítani.
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A CUDA használatához nvidia GPU-ra van szükség, és telepíteni
                kell a <function>nvidia-cuda-toolkit</function>-et.
            </para>
        </caution>
        <para>
            Lássuk akkor a forrást:
            <programlisting language="c++"><![CDATA[
#define MERET 600
#define ITER_HAT 32000

__device__ int
mandel (int k, int j)
{
    // Végigzongorázza a CUDA a szélesség x magasság rácsot:
    // most eppen a j. sor k. oszlopaban vagyunk

    // számítás adatai
    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

    // a számítás
    float dx = (b - a) / szelesseg;
    float dy = (d - c) / magassag;
    float reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;

    // c = (reC, imC) a rács csomópontjainak
    // megfelelő komplex szám
    reC = a + k * dx;
    imC = d - j * dy;
    // z_0 = 0 = (reZ, imZ)
    reZ = 0.0;
    imZ = 0.0;
    iteracio = 0;
    // z_{n+1} = z_n * z_n + c iterációk
    // számítása, amíg |z_n| < 2 vagy még
    // nem értük el a 255 iterációt, ha
    // viszont elértük, akkor úgy vesszük,
    // hogy a kiinduláci c komplex számra
    // az iteráció konvergens, azaz a c a
    // Mandelbrot halmaz eleme
    while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
    {
        // z_{n+1} = z_n * z_n + c
        ujreZ = reZ * reZ - imZ * imZ + reC;
        ujimZ = 2 * reZ * imZ + imC;
        reZ = ujreZ;
        imZ = ujimZ;

        ++iteracio;

    }
    return iteracio;]]>
}
 
            </programlisting>
            Előre definiáljuk a méret és az iterációs határ értékét. 
            A <function>mandel</function> fügvénnyel hozzuk létre a 
            Mandelbrot halmazt. Ez teljes mértékben megegyezik
            az első Mandelbrot-os feladatunkkal, ahol nem használtuk
            a complex típust. Érdekesség lehet, hogy a függvény
            visszatérési értéke előtt megtalálható a <function>__device__</function>
            kifejezés, mellyel azt jelezzük, hogy CUDA-val fogjuk számolni.
            Amikor az <function>nvcc</function>-vel fordítunk, akkor
            a fordító két részre osztja a programot, egy eszközhöz kapcsolódó részre, amelyet
            az NVIDIA fordító készít el, és egy host részre, mely a gcc-vel fordul.
            Amelyik delkaráció elé odaírjuk a <function>__device__</function> vagy
            a <function>__global__</function> kifejezést, azt az NVIDIA fordító
            fogja gépi kóddá alakítani.
            A régebbi feladatban a számok <function>double</function> típusúak
            voltak, itt áttértünk a <function>float</function> típusra, mivel
            a fordító úgyis erre konvertálta volna őket.
            <programlisting language="c++">
__global__ void
mandelkernel (int *kepadat)
{

    int tj = threadIdx.x;
    int tk = threadIdx.y;

    int j = blockIdx.x * 10 + tj;
    int k = blockIdx.y * 10 + tk;

    kepadat[j + k * MERET] = mandel (j, k);

}
            </programlisting>
            Ahogy említettem a <function>__global__</function> előtag jelzi,
            hogy ezt is a GPU-val fogjuk elvégeztetni. Ebben a részben adjuk át
            a <function>mandel</function> függvénynek az aktuálisan feldolgozás
            alatt álló érték indexét, amelyhez kiszámoljuk az összes lehetséges
            z értéket. A <function>threadIdx.x/y</function> jelöli, hogy melyik
            szálon fut az aktuális x és y számhoz tartozó érték kiszámítása. Ahhoz,
            hogy ezekenek a pontos indexét meg tudjuk adni, tudnunk kell, hogy melyik
            blokkba van éppen benne a szám, és hogy mekkora a blokk mérete, ezek
            segítségével a fent látható módon eltudjuk tárolni a koordinátákat a
            j és k változókban. Egy ábra, hogy könnyebben megértsd, hogyan működik
            ez az indexelés.
            <figure>
                <title>Indexelés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/cuda_seged.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <programlisting language="c++"><![CDATA[
void
cudamandel (int kepadat[MERET][MERET])
{

int *device_kepadat;
cudaMallocManaged ((void **) &device_kepadat, MERET * MERET * sizeof (int));


// dim3 grid (MERET, MERET);
// mandelkernel <<< grid, 1 >>> (device_kepadat);

dim3 grid (MERET / 10, MERET / 10);
dim3 tgrid (10, 10);
mandelkernel <<< grid, tgrid >>> (device_kepadat);  

cudaMemcpy (kepadat, device_kepadat,
        MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
cudaFree (device_kepadat);

}]]>
            </programlisting>
            A <function>cudamandel</function> függvénynek átadunk egy 600x600-as
            tömböt. Létrehozunk egy pointert, és a memóriában foglalunk neki egy
            az átadott tömmbbel megegyező méretű területet, melyre ráállítjuk. Majd
            ezt pointert fogjuk átadni a <function>mandelkernel</function>
            függvénynek. A függvényhívásnál észrevehetsz egy furcsaságot. A 
            <![CDATA[<<<a, b>>>]]> kifejezésben lévő 2 érték közül az <function>a</function>
            jelöli, hogy hány blokkot akarunk létrehozni, a <function>b</function>
            pedig a blokkokhoz tatrtozó szálak számát. A előbbi értéke jelen esetben
            3600, míg az utóbbié 100 lesz. Ha függvény lefutott, akkor átmásoljuk
            az értékeket a argumentumként megadott tömbbe, és felszabadítjuk a 
            lefoglalt területet.
            <programlisting language="c++"><![CDATA[
int
main (int argc, char *argv[])
{

// Mérünk időt (PP 64)
clock_t delta = clock ();
// Mérünk időt (PP 66)
struct tms tmsbuf1, tmsbuf2;
times (&tmsbuf1);

if (argc != 2)
    {
    std::cout << "Hasznalat: ./mandelpngc fajlnev";
    return -1;
    }

int kepadat[MERET][MERET];

cudamandel (kepadat);

png::image < png::rgb_pixel > kep (MERET, MERET);

for (int j = 0; j < MERET; ++j)
    {
    //sor = j;
    for (int k = 0; k < MERET; ++k)
    {
    kep.set_pixel (k, j,
            png::rgb_pixel (255 -
                    (255 * kepadat[j][k]) / ITER_HAT,
                    255 -
                    (255 * kepadat[j][k]) / ITER_HAT,
                    255 -
                    (255 * kepadat[j][k]) / ITER_HAT));
    }
    }
kep.write (argv[1]);

std::cout << argv[1] << " mentve" << std::endl;

times (&tmsbuf2);
std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

delta = clock () - delta;
std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

}]]>
            </programlisting>
            A <function>main</function> függvény nem tartalmaz nagy újdonságokat
            az előző feladatokhoz képest, annyi különbséggel, hogy most
            a futási időt is mérjük, hogy össze tudjuk hasonlítani a CUDA-s 
            verziót a simával. Itt is végigmegyünk az egyes pixleken, és
            beállítjuk a megfelelő színeket, melyhez felhasználjuk a képadatban
            tárolt értékeket.
            <figure>
                <title>Két program hasonlítása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/hason.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Hogy a két programot összetudjuk hasonlítani, a régi C++-os Mandelbrot 
            programunkat alakítottuk ást, hogy az is számolja a futási időt. Ahogy
            a képen is láthatod, a különbség letaglózó. Kevesebb mint az egy tizenhetede
            a CUDA-s implementáció, az eredetinek. Hogy lássuk, nem árulok zsákbamacskát,
            megmutatom az egyik és a másik által készített képeket is.
            <figure>
                <title>CUDA variáns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/mandel.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>C++ megvalósítás, párhuzamosítás nélkül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/CUDA/mandel_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Összességében elmondhatjuk, hogy a CUDA egy nagyon hasznos
            technológia, mely jelentős gyorsulást érhetünk el, főleg olyan
            programokban, ahol képet kell generálni. De videók renderelésnél
            is nagyon hasznos.
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
            
        <para>
            Megoldás forrása:<link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot/Zoom">itt</link>  
        </para>

        <para>
            Megoldás videó: 
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A feladat megoldásában tutorként részt vett Racs Tamás.
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Használata</title>
            <para>
                Telepíteni: sudo apt-get install libqt4-dev
            </para>
        </caution>
        <caution>
            <title>Megjegyzés</title>
            <para>A feladat megoldásában tutorként részt vett Racs Tamás</para>
        </caution>
        <para>
            A program a QT GUI-t használja, ennek segítségével tudjuk elkészíteni a 
            Mandelbrot halmazt beutazó programunkat. Ez a GUI az egyik legertejedtebb
            garfikus interfésze a C++-nak, rengeteg tutorial van róla fent a neten.  
        </para>
        <para>
                Fordítás:
                Az szükséges 4 fájlnak egy mappában kell lennie. A mappában futtatni
                kell a <function>qmake -project</function> parancsot. Ez létre fog
                hozni egy <function>*.pro</function> fájlt. Ebbe a fájlba be kell
                írni a következőt: <function>QT += widgets</function> sort. Ezután futtatni kell
                a <function>qmake *.pro</function>.
                Ezután lesz a mappában
                egy <function>Makefile</function>, ezt kell majd használni. Ki 
                adjuk a <function>make</function> parancsot, mely létrehoz 
                egy bináris fájlt. Ezt pedig a szokásos módon futtatjuk.
            <figure>
                <title>1. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/elso.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>2. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/szerk.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>3. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/vege.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Rengeteg figyelmeztetést ad vissza, de ezzel most nem kell törődni, hiszen a bináris fájl
            elkészült, melyet futtatunk, és elindul az utazásunk a végtelenbe.
            <figure>
                <title>4. lépés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/futtat.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Alapállapot</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/kep_1.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/kep_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Tovább nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom/kep_3.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Ahhoz, hogy részletesebb képet kapj a ránagyított területről, az "n" billentyűt
            kell lenyomnod, mely kiszámolja a z-ket a megadott területen. Ahogy folyamatosan nagyítjuk,
            észre vehetjük, hogy a újra meg újra Mandelbrot halmazokat kapunk.
        </para>
        <para>
            Most hogy láttad, hogyan működik a program, nézzük meg a forrást. A 
            szokásostól eltérően, most több fájlból áll a forrás. Ez azt a célt
            szolgálja, hogy átláthatóbb legyen.
        </para>
        <para>
            Elsőnek a <filename>frakablak.h</filename>-t dolgozzuk fel. Ez egy header
            fájl. Ezeket szokás a <function>#include</function> kulcsszóval a 
            programunkhoz fűzni, viszont eddig kizárólag előre elkészített header-öket
            használtunk, de most egy sajátot írtunk. Legfontosabb dolog, hogy a 
            a forrás szövegét egy keretbe kell foglalnunk, ez a keret így néz ki:
            <programlisting language="c++">
#ifndef FRAKABLAK_H
#define FRAKABLAK_H
        
        ...
          
#endif 
            </programlisting>
            Az ezek között megjelenő szöveg viszont semmiben nem különbözik az 
            eddig megszokott C++-os forrásoktól.
            <programlisting language="c++"><![CDATA[
#include <QMainWindow>
#include <QImage>
#include <QPainter>
#include <QMouseEvent>
#include <QKeyEvent>
#include "frakszal.h"]]>
            </programlisting>
            Természetesen most is a header fájlok importálásával kezdünk. Itt 
            észreveheted, hogy egyik sem láttuk még egyik forrásban sem. Ezek
            mind a Qt headerjei. A <function>QMainWindow</function> tartalmazza
            a programunk ablakának létrehozásához szükséges elemket. A <function>QImage</function>
            segítségével tudunk létrehozni képeket, erőssége, hogy a pixeleket közvetlenül
            tudjuk elérni. A <function>QPainter</function> arra szolgál, hogy a képet
            színezhessük. A <function>QMouseEvent</function> és a <function>QKeyEvent</function>
            segítségével tudjuk megoldnai, hogy az egér vagy billentyű használatával
            folyamatokat indítsunk el a prohramban. Például, hogy az egérrel való kijelölés hatására
            a program ránagyítson a halmazra. Az imént felsorolt Qt header-ök mind egy 
            osztályt tartalmaznak, melyek neve megegyezik a header-ök nevével. A 
            <filename>farktszal.h</filename>-ről pedig a későbbiekben részletesen
            beszélünk.
            <programlisting language="c++"><![CDATA[
class FrakSzal;

class FrakAblak : public QMainWindow
{
    Q_OBJECT

public:
    FrakAblak(double a = -2.0, double b = .7, double c = -1.35,
              double d = 1.35, int szelesseg = 600,
              int iteraciosHatar = 255, QWidget *parent = 0);
    ~FrakAblak();
    void vissza(int magassag , int * sor, int meret) ;
    void vissza(void) ;
    // A komplex sík vizsgált tartománya [a,b]x[c,d].
    double a, b, c, d;
    // A komplex sík vizsgált tartományára feszített
    // háló szélessége és magassága.
    int szelesseg, magassag;
    // Max. hány lépésig vizsgáljuk a z_{n+1} = z_n * z_n + c iterációt?
    // (tk. most a nagyítási pontosság)
    int iteraciosHatar;

protected:
    void paintEvent(QPaintEvent*);
    void mousePressEvent(QMouseEvent*);
    void mouseMoveEvent(QMouseEvent*);
    void mouseReleaseEvent(QMouseEvent*);
    void keyPressEvent(QKeyEvent*);

private:
    QImage* fraktal;
    FrakSzal* mandelbrot;
    bool szamitasFut;
    // A nagyítandó kijelölt területet bal felsõ sarka.
    int x, y;
    // A nagyítandó kijelölt terület szélessége és magassága.
    int mx, my;
    std::vector<int> zX, zY, zX2, zY2;
};]]>
            </programlisting>
            A header állományok deklarációkat tartalmaznak, tehát a függvények és
            változók
            definiálása nem itt történik. A <function>Frakszal</function> osztály
            teljes deklarációját a <filename>frakszal.h</filename> tartalmazza. Csak
            azért vol szükség arra, hogy deklarájuk itt, hogy az elemeit a 
            <function>FrakAblak</function> osztály fel tudja használni. Ennek az 
            osztálynak a szülő osztály a <function>QMainWindow</function>, ami 
            annyit jelent, hogy minden elemét a <function>QMainWindow</function>
            osztálynak, ami <function>public</function> részben van eltudjuk érni
            egy <function>FrakAblak</function> objektumon keresztül is. A 
            <function>Q_OBJECT</function> makró teszi lehetővé, hogy a program
            kezelni tudja a Qt C++ kiegészítőit. Ezután pedig a <function>public</function>
            elemeit deklaráljuk az osztálynak. A <function>public</function>
            azt jelenti, hogy ezeket az osztályon kívül el tudjuk érni. Első, amit
            deklarálni kell, az a konstruktor. Ez egy függvény, ami akkor hívódik meg,
            amikor egy objektumot létrehozunk, neve mindig megegyezik az osztály nevével.
            Ennek segítségével a változók értékét inicializáljuk alap értékkel, ha a 
            felhasználó nem adna meg paramétereket. Ezt követ a destruktor, ami a
            <function>~</function> jelről imserszik meg.
            A többi eleme a <function>public</function> résznek pedig változók és
            függvények. Ami érdekesebb az a <function>protected</function> rész, 
            ez olyan elemet taratlmaz, amik csak az osztályból érehtőek el, vagy
            a gyermek osztályokból. Itt vannak deklarálva azok a függvények, amivel
            a billenytyű és egér által küldött jeleket feldolgozzuk. A <function>private</function>
            rész pedig kizárólag az osztályból érhető el. Ezt azért alkalmazzák a 
            programozók, hogy megvédjék az osztály fontosabb elemeit attól, hogy 
            valaki az osztályon kívül módosítsa. Ezeknek az osztáylon kívüli elérésére
            általában egy függvény segítségével nyújtanak lehetőséget a programozók, mely
            csupán az értéküket adja vissza. Ezzel a header végére értünk, nézzük, hogy
            milyen definíciók tartoznak az imént deklarált változókhoz.
            <programlisting language="c++"><![CDATA[
FrakAblak::FrakAblak(double a, double b, double c, double d,
                     int szelesseg, int iteraciosHatar, QWidget *parent)
                         : QMainWindow(parent)
{
    setWindowTitle("Mandelbrot halmaz");

    szamitasFut = true;
    x = y = mx = my = 0;
    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;
    this->szelesseg = szelesseg;
    this->iteraciosHatar = iteraciosHatar;
    magassag = (int)(szelesseg * ((d-c)/(b-a)));

    setFixedSize(QSize(szelesseg, magassag));
    fraktal= new QImage(szelesseg, magassag, QImage::Format_RGB32);

    mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
    mandelbrot->start();
}]]>
            </programlisting>
            Elsőnek a konstruktor nézzük meg. A <function>FrakAblak</function>
            osztály konstruktorát a <function>::</function> hatóköroperátorral
            tudjuk elérni.
            Egy érdekesség, hogy a <function>FrakAblak</function>
            konstruktor a <function>QMainWindow</function> osztály konstruktorát is 
            meghívja. A <function>setWindowTitle</function> függvénnyel van lehetőségünk
            beállítani a <function>QMainWindow</function> által létrehozott ablak nevét
            beállítani. Amikor létrehozzuk a <function>FrakAblak</function> objektumot
            a <function>szamitasFut</function> logikai értéket igazra állítjuk. Mivel 
            kezdetben nincs kijelölt terület, ezért az <function>x,y</function> változókat,
            melyek a kijelölt terület bal felső sarkát adják meg, nullára állítjuk. Ugyanígy
            járunk el a <function>mx,my</function> változókkal is, melyek a terület szélességét
            adják meg. Hogy jelöljük melyik változó név tartozik az objektumhoz, és melyik
            a paraméterhez, ezért <function><![CDATA[this->]]></function> operátort
            használjuk. Ez jelöli, hogy az objektum saját változójáról van szó. Tehát
            ezen a részen átadjuk a paraméterek értékeit a megfele változóknak. Többek
            között paraméterként adjuk meg a komplex számsík vizsgálandó területét, azt, hogy 
            erre a területre milyen széles hálót feszítsünk ki. A magasságot viszont már ezek
            alapján adjuk meg, és típuskényszerítést alkalmazunk, hogy egész számot kapjunk.
            Ha már tudjuk a magasságot és a szélességet, az ablakot fix nagyságúra állítjuk
            a <function>setFixedSize</function> függvénnyel. A <function>fraktal</function>
            pointert ráállítjuk egy <function>QImage</function> objektumra, melyhez a
            <function>new</function> operátort használjuk. A <function>mandelbrot</function>
            pointer pedig egy <function>FrakSzal</function> objektumot fog címezni. Majd
            a <function>start()</function> függvény segítségével elindítjuk a szál végrehajtását.
            <programlisting language="c++"><![CDATA[
FrakAblak::~FrakAblak()
{
    delete fraktal;
    delete mandelbrot;
}]]>
            </programlisting>
            A destruktorban pedig a <function>fraktal</function> és <function>mandelbrot</function>
            pointerek által mutatatott területet szabadítjuk fel.
            <programlisting language="c++"><![CDATA[
void FrakAblak::paintEvent(QPaintEvent*) {
    QPainter qpainter(this);
    qpainter.drawImage(0, 0, *fraktal);
    if(!szamitasFut) {
        qpainter.setPen(QPen(Qt::white, 1));
        qpainter.drawRect(x, y, mx, my);
        if(!zX.empty()) //excuse me
        {
            for(int i=0; i<zX.size(); i++)
            {
                qpainter.drawLine(zX[i],zY[i],zX2[i],zY2[i]);
            }
 
        }

    }
    qpainter.end();
}]]>
            </programlisting>
            A <function>paintEvent</function> függvény, ahogy a neve is mutatja a 
            kép kirajzolásáért felelős.  Átadunk egy pointert, ami a kirajzolni
            kívánt dologra mutat. Majd példányosítunk egy <function>QPainter</function>
            objektumot, melynek átadjuk a paraméterként kapott pointert. Ezután a 
            <function>drawImage</function> függvény segítségével kirajzoltatjuk 
            a <function>farktal</function> által mutatott kép objektumot az
            ablak (0,0)-ás koordinátájától kezdve. Ha nem fut éppen számítás, 
            akkor a toll színét fehérre állítjuk, és kirajzolunk egy téglalapot
            vele a megadott (x,y) koordinátából, a megadott mx*my-os méretben. Abban
            az esetben, ha a <function>zX</function> vektor nem üres, akkor 
            végig megyünk a vektoron és vonalakat rajzolunk ki az
            (x,y) és (x2,y2) koordináták között. Végezetül pedig, mivel a 
            <function>QPainter</function> objektumot mindig fel kell szabadítani,
            ezért az <function>end()</function> tagfüggvénye segítségével ezt 
            meg is tesszük.
            <programlisting><![CDATA[
 void FrakAblak::mousePressEvent(QMouseEvent* event) {
    
    if (event->button() == Qt::LeftButton)
    {

        // A nagyítandó kijelölt területet bal felsõ sarka:
        x = event->x();
        y = event->y();
        mx = 0;
        my = 0;
    }
    else if(event->button() == Qt::RightButton)
    {
               double dx = (b-a)/szelesseg;
               double dy = (d-c)/magassag;
               double reC, imC, reZ, imZ, ujreZ, ujimZ;
 
               int iteracio = 0;
 
               reC = a+event->x()*dx;
               imC = d-event->y()*dy;
 
               reZ = 0;
               imZ = 0;
               iteracio = 0;
 
               while(reZ*reZ + imZ*imZ < 4 && iteracio < 255) {
                   // z_{n+1} = z_n * z_n + c
                   ujreZ = reZ*reZ - imZ*imZ + reC;
                   ujimZ = 2*reZ*imZ + imC;
                   zX.push_back((int)((reZ - a)/dx));
                   zY.push_back( (int)((d - imZ)/dy));
                   zX2.push_back((int)((ujreZ - a)/dx));
                   zY2.push_back((int)((d - ujimZ)/dy));
                   reZ = ujreZ;
                   imZ = ujimZ;
 
                   ++iteracio;
                }
    }

    update();
}]]>
            </programlisting>
            A <function>mousePressEvent</function> függvény azt határozza meg, hogy
            mi történjen, ha felhasználó csak rákattint az egérrel képre. Paraméteréül
            egy <function>QMouseEvent</function> objektumra mutató pointert kap.
            Ennek az objektumnak a <function>button()</function> függvényével
            tudjuk lekérdezni, hogy melyik gombot nyomta le a felhasználó. Ha a 
            balt, akkor egy pixelre nagyítunk rá, vagyis vagy teli zöld, vagy teli
            fekete lesz az ablak. Ezt onnan tudjuk, hogy a nagyítandó terület
            méretét meghatározó változók nullára vannak állítva. Ha jobb gomb
            kerül lenyomásra, akkor a memgadott pontból kezdődően kiszámoljuk az
            z<subscript>n</subscript> komplex számokat, és ezeket berakjuk egy tömbbe.
            Addig megyünk a <function>while</function> ciklusban, ameddig a
            z<subscript>n</subscript> értéke kisebb, mint 2, vagy ameddig
            nem érjük el az iterációs határt. Az itt kiszámolt pontokat 
            fogja összekötni a <function>paintEvent()</function> függvény
            <function>for</function> ciklusa futása során. Az <function>update()</function>
            segítségével pedig frissítjük a kirajzolt képet, hogy azonnal változzon a 
            felhasználó behatására.
            <programlisting language="c++"><![CDATA[
void FrakAblak::mouseMoveEvent(QMouseEvent* event) {

    // A nagyítandó kijelölt terület szélessége és magassága:
    mx = event->x() - x;
    my = mx; // négyzet alakú

    update();
}]]>
            </programlisting>
            Ahhoz, hogy az egér mozgását kezeljük a <function>mouseMoveEvent</function>
            függvényt definiáljuk. Ahogy <function>mousePressEvent</function> függvénynél
            említettem, abban az esetben, ha csak a bal egérgombra nyomunk rá, akkor
            csak egy pixelre nyagyítunk rá. Akkor nem tettem hozzá, hogy ez csak akkor igaz,
            ha mozgatás nélkül engedjuk fel az egérgombot. Ha viszont mozgatjuk, akkor
            a <function>mousePressEvent</function> függvényben megkapott x érték és a
            az utolsó egér pozíció x koordinátája alapján meghatározzuk a nagyítandó
            terület szélességét. Itt is meghívjuk a <function>update()</function> függvényt,
            hogy egyből látható legyen a behatás. Hogy teljes legyen a kép még van egy függvény, 
            ami azt kezeli, amikor elengedjük az egeret.
            <programlisting language="c++"><![CDATA[
 void FrakAblak::mouseReleaseEvent(QMouseEvent* event) {

    if(szamitasFut)
        return;

    szamitasFut = true;

    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;

    double a = this->a+x*dx;
    double b = this->a+x*dx+mx*dx;
    double c = this->d-y*dy-my*dy;
    double d = this->d-y*dy;

    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;

    delete mandelbrot;
    mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
    mandelbrot->start();

    update();
}]]> 
            </programlisting>
            Ha éppen fut a halmaz kiszámítása, akkor nem dolgozzuk fel 
            gombelengedést, egyébként pedig beállítjuk az egér mozgatásával
            meghatározott terület mérete alapján meghatározott síktartományt, amit
            vizsgálunk. Az éppen kirajzolt ábrát pedig dobjuk, azaz a <function>mandelbrot</function>
            pointer által mutatott objektumot töröljük. Majd foglalunk helyet egy újnak, 
            aminek átadjuk a megújult paramétereket. Végezetül pedig elindítjuk a 
            szálat, frissítünk.
        </para>
        <para>
            Ezt most egy kicsit nehezen állhat össze a fejekben, de összegezzük, hogy
            mi is történik. Amikor rákattintunk a bal egérgombra, akkor meghívódik a 
            <function>mousePressEvent</function> függvény, mely az 
            x és y koordinátákat beállítja az egér aktuális pozícójába. Abban az 
            esetben, ha nem mozgatjuk az egeret, csak elegendjük a gombot, meghívódik
            a <function>mouseReleaseEvent</function> függvény, az kiszámolja a megadott
            koordináták és szélesség alapján a Mandelbrot halmazt, 
            ami lényegében azt 
            eredméynezi, hogy egy pixelre ránagyít a program. Ha mozgatjuk az egeret, 
            akkor meghívódik a <function>mouseMoveEvent</function>, és ezzel 
            párhuzamosan a <function>paintEvent</function> függvéyn, ami
            folymatosan rajzolja azt a méretű négyzetet, amit az egér mozgatásával
            megadunk. Ha felengedjük a gombot, <function>mouseReleaseEvent</function>
            ránagyít az általunk meghatározott területre. Ugyan ezek a folyamatok
            zajlanak le, akkor is, ha a jobb egérgombot nyomjuk le, azzal a különbséggel,
            hogy akkor a z<subscript>n</subscript> számokat összeköti az adott ponttól
            kezdve. Azt fontos látni, hogy nem konkrétan a <function>mouseReleaseEvent</function>
            függvény nagyítja ki a képet, hanem a <function>vissza</function> függvény
            a <function>FraktalSzal</function> objektum által visszadott értékek alapján.
        </para>
        <para>
            A program abban az esetben, ha lenyomjuk az n billentyűt, akkor 
            a program újraszámolja a Mandelbrot halmazt.Ennek a kezeléséért
            a <function>kexPressEvent</function> függvény felelős. Ha 
            a halamaz számítása fut, akkor nem csinál semmit, amúgy újra kiszámolja
            a halmazt. Ha az n billentyűt lenyomjuk, akkor az iterációs határt a 
            duplájára növeli. Ezzel pontosabb lesz a halmaz kiszámítása.
            <programlisting language="c++"><![CDATA[
void FrakAblak::keyPressEvent(QKeyEvent *event)
{

    if(szamitasFut)
        return;

    if (event->key() == Qt::Key_N)
        iteraciosHatar *= 2  //bit shift: iteraciosHatar = iteraciosHatar << 1;
    szamitasFut = true;

    delete mandelbrot;
    mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
    mandelbrot->start();

}]]>
            </programlisting>
            Ahhoz, hogy megjelenítsük az halmazt, a <function>vissza</function> 
            függvényt fogjuk használni, ahogy már korábban említettem.
            <programlisting language="c++"><![CDATA[
void FrakAblak::vissza(int magassag, int *sor, int meret)
{
    for(int i=0; i<meret; ++i) {
        QRgb szin = qRgb(0, 255-sor[i], 0);
        fraktal->setPixel(i, magassag, szin);
    }
    update();
}]]>
            </programlisting>
            A függvény megkapja paraméteréül az éppen kirajzolandó sor y 
            koordinátáját, egy tömbre mutató pointert, ami az éppen aktuális
            iteráció számát mutatja a Mandelbrot halmaz számolása során, és
            az ablak szélességét. A <function>for</function> ciklus a kép pixeleit
            beállítja a megfelelő színekre. Ehhez létrehoz egy <function>QRgb</function>
            objektumot, amivel egy színt tárolunk el, majd pedig ezt a színt, és az aktuális
            (x,y) koordinátákatátadjuk a <function>setPixel()</function> függvénynek.
            <programlisting language="c++"><![CDATA[
void FrakAblak::vissza(void)
{
    szamitasFut = false;
    x = y = mx = my = 0;
}]]>
            </programlisting>
            Van a programunkban egy másik <function>vissza</function> függvény. 
            Ez nem zavarja meg a fordítót, mert a paraméterlista alapján
            meg tudja őket különböztetni. Ez a függvény nem kér paramétert, 
            csak visszaállítja a kijelölés értékeit nullára, és a 
            <function>szamitasFut</function> változó értékét hamisra változtatja.
            Ez akkor hívódik meg, amikor megtörténik a Mandelbrot halmaz 
            kirajzolása.
        </para>
        <para>
            Most nézzük meg, hogy a már emlegetett <function>FraktSzal</function>
            osztály milyen feladatokért felelős. Ennek is elsőnek a 
            deklarációját nézzük meg, amit a <filename>frakszal.h</filename>
            tartalmaz.
            <programlisting language="c++"><![CDATA[
#include <QThread>
#include <math.h>
#include "frakablak.h"

class FrakAblak;

class FrakSzal : public QThread
{
    Q_OBJECT

public:
    FrakSzal(double a, double b, double c, double d,
             int szelesseg, int magassag, int iteraciosHatar, FrakAblak *frakAblak);
    ~FrakSzal();
    void run();

protected:
    // A komplex sík vizsgált tartománya [a,b]x[c,d].
    double a, b, c, d;
    // A komplex sík vizsgált tartományára feszített
    // háló szélessége és magassága.
    int szelesseg, magassag;
    // Max. hány lépésig vizsgáljuk a z_{n+1} = z_n * z_n + c iterációt?
    // (tk. most a nagyítási pontosság)
    int iteraciosHatar;
    // Kinek számolok?
    FrakAblak* frakAblak;
    // Soronként küldöm is neki vissza a kiszámoltakat.
    int* egySor;

};]]>
            </programlisting>
            Az első header állományról tegyünk említést, a többi már úgyis ismerős.
            A <function>QThread</function> szintén egy osztály, ami azt teszi
            lehetővé, hogy programszálakat kezeljünk a programunkban. Ez az osztály
            szülőosztálya a <function>FraktalSzal</function> osztályunknak. Itt is
            alkalmazzuk a <function>Q_OBJECT</function> makrót, ami lehetővé teszi a
            fordító számára a Qt-s kiegészítők felismerését. A <function>public</function>
            részben megtalálható a konstruktor és a destruktor, valamint a 
            <function>run()</function> függvény. A 
            <function>protected</function> részben lévő változók pedig, már ismertek
            a <function>FrakAblak</function> osztályból. Kivéve a <function>farkAblak</function>
            pointert, ami egy pointer egy <function>FrakAblak</function> objektumra. Az 
            <function>egySor</function> pedig egy egészre mutató mutató. Lássuk 
            ezeknek a definiálását:
            <programlisting language="c++"><![CDATA[
FrakSzal::FrakSzal(double a, double b, double c, double d,
                   int szelesseg, int magassag, int iteraciosHatar, FrakAblak *frakAblak)
{
    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;
    this->szelesseg = szelesseg;
    this->iteraciosHatar = iteraciosHatar;
    this->frakAblak = frakAblak;
    this->magassag = magassag;

    egySor = new int[szelesseg];
}]]>
            </programlisting>
            A konstruktorban inicializáljuk a változók értékét a paraméterként kapott
            értékekkel, és létrehozunk egy <function>szelesseg</function> értékével
            megyegyező méretű, egész számokból álló tömböt, amire ráállítjuk az 
            <function>egySor</function> pointert.
            <programlisting language="c++"><![CDATA[
FrakSzal::~FrakSzal()
{
    delete[] egySor;
}
]]>
            </programlisting>
            A destruktorban pedig szokás szerint felszabadítjuk az imént említett
            pointer által mutatott tömböt. Azt, hogy tömbről van szó, explicit módon
            ki kell írni.
            <programlisting language="c++"><![CDATA[
void FrakSzal::run()
{
    // A [a,b]x[c,d] tartományon milyen sûrû a
    // megadott szélesség, magasság háló:
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;
    // Végigzongorázzuk a szélesség x magasság hálót:
    for(int j=0; j<magassag; ++j) {
        //sor = j;
        for(int k=0; k<szelesseg; ++k) {
            // c = (reC, imC) a háló rácspontjainak
            // megfelelõ komplex szám
            reC = a+k*dx;
            imC = d-j*dy;
            // z_0 = 0 = (reZ, imZ)
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            // z_{n+1} = z_n * z_n + c iterációk
            // számítása, amíg |z_n| < 2 vagy még
            // nem értük el a 255 iterációt, ha
            // viszont elértük, akkor úgy vesszük,
            // hogy a kiinduláci c komplex számra
            // az iteráció konvergens, azaz a c a
            // Mandelbrot halmaz eleme
            while(reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c

                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;

                reZ = ujreZ;
                imZ = ujimZ;

                ++iteracio;

            }
            // ha a < 4 feltétel nem teljesült és a
            // iteráció < iterációsHatár sérülésével lépett ki, azaz
            // feltesszük a c-rõl, hogy itt a z_{n+1} = z_n * z_n + c
            // sorozat konvergens, azaz iteráció = iterációsHatár
            // ekkor az iteráció %= 256 egyenlõ 255, mert az esetleges
            // nagyítasok során az iteráció = valahány * 256 + 255

            iteracio %= 256;

            //a színezést viszont már majd a FrakAblak osztályban lesz
            egySor[k] = iteracio;
        }
        // Ábrázolásra átadjuk a kiszámolt sort a FrakAblak-nak.
        frakAblak->vissza(j, egySor, szelesseg);
    }
    frakAblak->vissza();

}
                ]]>
            </programlisting>
            A <function>run()</function> függvény számolja ki a Mandelbrot 
            halmazt, és minden sor kiszámolása után meghívja a <function>vissza()</function>
            függvényt, ami kirajzolja azt a sort az ablakba. A <function>for</function>
            ciklus addig fut, ameddig az ablakban megjelenő összes sort ki nem számolta, 
            vagyis ameddig a ciklusváltozó eléri a magasságot. Ezután pedig 
            meghívódik a <function>vissza()</function> függvény, ami a kijelölés 
            értékeit állítja vissza, és jelzi a <function>FrakAblak</function> 
            objektumnak, hogy a számítás befejeződött.
        </para>
        <para>
            Ezen hosszú elemzés végeztével pedig lássuk, mint is rejt magában a 
            <function>main()</function> függvény, mely a <filename>main.cpp</filename>-ben
            található.
            <programlisting language="c++"><![CDATA[
#include <QApplication>
#include "frakablak.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    
    FrakAblak w1;
    w1.show();
                    
    return a.exec();
}]]>
            </programlisting>
            Ehhez a fájlhoz importáltuk a <function>QApplication</function>
            headert, amire azért volt szükség, mert a <function>QApplication</function>
            osztály teszi lehetővé, hogy grafikus felületű programokat kezeljünk.
            A <function>main</function> függvényben példányosítunk egy 
            objektumot, ami az imént említett osztályú. Létrehozunk egy
            <function>FrakAblak</function> típusú objektumot w1 néven. Majd meghívjuk
            ennek az objektumnak a <function>show()</function> függvényét. Jogosan
            merül fel a kérdés, hpgy ez a függvény hol is van definiálva. A 
            <function>QWidget</function> osztályban, melyet azért tudunk elérni, mert
            a szülő osztálya a <function>QMainWindow</function>, ami a 
            <function>FrakAblak</function> osztályunknak a szülő osztálya is.
            Ez a függvény jeleníti meg az ablakot, amiben a program fut. Az 
            <function>a</function> objektum <function>exec()</function> függvénye pedig
            addig fut, ameddig a program be nem záródik. Ha minden rendben lefutott, akkor
            nullával tér vissza, ellenkező esetben valamilyen hibakóddal. 
        </para>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Mandelbrot/Zoom_java">itt</link> 
        </para>
        <para>
            <emphasis role = "strong">
                Tanulságok, tapasztalatok, magyarázat...
            </emphasis>
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Telepíteni: sudo apt-get install openjdk-8-jdk
            </para>
            <para>
                Fordítás, futtatás:
                <programlisting>
javac MandelbrotHalmazNagyító.java
java MandelbrotHalmazNagyító
                </programlisting>
            </para>
        </caution>
        <para>
            Az előző feladatban készített nagyító Java implementációját
            kell most elkészíteni. A program teljesen ugyanazokkal
            a funkciókkal rendelkezik, mint a fentebb megismert C++-os
            verzió, annyi különbséggel, hogy itt az "s" gomb lenyomásával
            lehetőségünk van pillanatfelvételt készíteni a programról.
            A kép bel felső sarkában láthatjuk az éppen vizsgált tartomány
            koordinátáit, és az iterációs határt is. Az iterációs határ növelésére
            ez a program egy másik lehetőséget is nyújt az "n" billentyűn kívül.
            Az "m" gomb lenyomásával megtízszerezi a program az éppen aktuális
            iterációs határt, mellyel a program újra számolja halmazt. Egy másik
            újdonság az előzőhöz képest, hogy itt egy piros vonal jelöli azt, hogy
            melyik sorban tart éppen a rajzolás. Nézzünk is meg néhány képet a 
            programról:
            <figure>
                <title>Mandelbrot</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_1.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Mandelbrot nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_2.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Tovább nagyítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_3.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Még tovább javítva</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Mandelbrot/Zoom_java/kep_4.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
            Most pedig nézzük meg a forrást. Most is több fájlunk van, egészen
            pontosan 2. A <filename>MandelbrotHalmaz.java</filename> egy önmagában is
            müködő program, ellentétben az előző feladatban megismert fájlokkal, mivel
            azok teljesen egymásra épültek. Ez a forrás tartalmazza a MandelbrotHalmaz
            kiszámításához szükséges algoritmust. Lássuk a forráskódját:
            <programlisting language="java"><![CDATA[
import java.awt.Color;
public class MandelbrotHalmaz extends java.awt.Frame implements Runnable {
    protected double a, b, c, d;
    protected int szélesség, magasság;
    protected java.awt.image.BufferedImage kép;
    protected int iterációsHatár = 255;
    protected boolean számításFut = false;
    protected int sor = 0;
    protected static int pillanatfelvételSzámláló = 0;]]>
            </programlisting>
            Az <function>import</function> kulcsszó segítségével tudjuk a szükséges 
            osztáylokat hozzaádni a programunkhoz. Java-ban lényegében az egész
            program egy osztálynak fele meg. Ennek megfelelően létrehozunk deklarálunk
            egy osztályt <function>MandelbrotHalmaz</function> néven. Az <function>extends
            </function> segítségével az osztályunkat kiegészítjük a <function>Frame</function>
            osztállyal. Lényegében ez ahhoz hasonlít, mint a C++ forrásban egy 
            szülő osztályt adtunk meg. A <function>Frame</function> osztály felelős
            azért, hogy megalkossuk a programablakot. Az <function>implements</function>
            kulcszsóval pedig implementáljuk a <function>Runnable</function> interfészt.
            Ez abban különbözik egy osztálytól, hogy ebben nem tudjuk a deklarált elemeit
            definiálni, csak az osztályon keresztül, ami implementálja. A
            <function>Runnable</function> interfész amúgy a programszálakér felelős.
            Minden osztálynak implementálnia kell, amelyeket egy szálon szeretnénk
            futtatni. Láthatjuk, hogy itt is megjennek a már ismert változók, amik
            meghatározzák a komplex számsík vizsgált [a,b]x[c,d] tartományát,
            ennek a tartománynak a magasságát, szélességét és a Mandelbrot halmaz 
            számítási pontosságát meghatározó iterációs határt is. Itt is van egy 
            logikai változónk, a <function>számításFut</function>, mely azt
            tárolja, hogy fut-e a halmaz számítása, vagy sem. Alapértelmezetten 
            hamisra van állítva. Különleges lehet, hogy Java-ban nem lehet
            csoportosítani a <function>public, private, protected</function>
            elemeket. Mindegyik elé külön ki kell írni. Most nézzük meg
            az osztály konstruktorát:
            <programlisting language="java"><![CDATA[
    public MandelbrotHalmaz(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.szélesség = szélesség;
        this.iterációsHatár = iterációsHatár;
        this.magasság = (int)(szélesség * ((d-c)/(b-a)));
        kép = new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });]]>
            </programlisting>
            Hasonlóan a C++-os forráshoz, itt is paraméterként kéri a számításhoz
            szükséges változók értékét. Mivel Java-ban nincsenek pointerek, csak refernciák,
            ezért az osztályunk változóit a <function>.</function> operátorral érjük el,
            nem <function><![CDATA[->]]></function>. A magasságot kiszámítjuk a 
            vizsgált terület és a megadott szélesség alapján. Majd példányosítunk
            egy <function>BufferedImage</function> objektumot a <function>new</function>
            operátorral, mely területet foglal a megadott objektumnak, és visszatér
            egy referenciával. A <function>BufferedImage</function> osztály konstruktorának
            meg kell adnunk a kép méretét és típusát.
            Jelen esetben a képünk típusa <function>TYPE_INT_RGB</function>, ami 
            azt jeenti, hogy RGB színeket használunk, és az egyes színkomponenseket
            8-bites számokkal reprezentáljuk. Végül pedig meghívjuk a 
            <function>Frame</function> osztály tagfüggvényét, a 
            <function>addwindowListener()</function>-t. Ez a függvény azért felelős,
            hogy kezelni tudjuk az ablakon történő behatásokat, most kifejezetten azt, hogy
            az ablak záródjon be, ha az "x"-re kattintunk. A billentyűzetről érkező
            bemenetket is a konstruktorban kezeljük.
            <programlisting language="java"><![CDATA[
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel();
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 256;
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_M) {
                    if(számításFut == false) {
                        MandelbrotHalmaz.this.iterációsHatár += 10*256;
                        számításFut = true;
                        new Thread(MandelbrotHalmaz.this).start();
                    }
                }
            }
        });]]>
            </programlisting>
            A feladat bevezetőjében már említettem, hogy ebben a forrásban
            több billntyűt is kezelünk, egészen pontosan hármat. Ahhoz, hogy a
            billentyűk lenyomását érzékelje a program a <function>addKeyListener</function>
            függvényre van szükségünk. A konkrét lenyomásokat a program a 
            <function>KeyAdapter()</function> osztály segítségével dolgozza fel. A 
            <function>KeyListener</function> osztály tagfüggvényét, a <function>keyPressed</function>-et
            használva el tudjuk érni, hogy pontosan melyik billentyű lett lenyomva, és annak 
            függvényében utasításokat végrehajtani. Ha az "s" billentyűt nyomjuk le, akkor
            meghívódik a <function>pillanatfelvétel()</function> függvény, "n" esetén
            duplázzuk az iterációs határt, majd újra számoljuk a halmazt. Ugyan ezt tesszük
            az "m" lenyomásakor is, csak akkor az iterációt a tízszeresére növeljük. 
            <programlisting language="c++"><![CDATA[
        // Ablak tulajdonságai
        setTitle("A Mandelbrot halmaz");
        setResizable(false);
        setSize(szélesség, magasság);
        setVisible(true);
        // A számítás indul:
        számításFut = true;
        new Thread(this).start();
    }]]>
            </programlisting>
            A konstruktor végén pedig az ablakot állítjuk be, amiben a 
            program megjelenik. Majd elindítjuk a halmaz számítását.
            <programlisting language="java">
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolása
        g.drawImage(kép, 0, 0, this);
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }
    }
            </programlisting>
            A <function>paint()</function> egy metódus, mely arra szolgál, hogy az
            aktuális halmazt kirajzoljuk az ablakba. Ez úgy zajlik, hogy paraméterként 
            kap egy <function>Graphics</function> objektumot. Ennek a 
            <function>drawImage</function> függvényének megadjuk, hogy milyen képet
            szeretnénk kirajzolni, hova az ablakon belül, és melyik ablakba.
            Egy piros vonallal pedig ábrázoljuk a számítás előrehaladását. Ehhez
            elsőnek be kell állítani a színt, amit használnánk, ezt a <function>setColor</function>
            tagfüggvénnyel tudjuk állítani. A <function>drawLine</function> függvény
            pedig a megadott két pont közé húz egy egyenest.
            <programlisting language="java"><![CDATA[
    public void update(java.awt.Graphics g) {
        paint(g);
    }
            ]]></programlisting>
            Az alapértelmezett <function>update()</function> függvényt pedig felül
            definiáljuk, annak érdekében, hogy az újraszámolás során ne fehéredjen ki 
            a kép egy pillanatra. Az előző feladatban látott programhoz lépest újdonság a 
            <function>pillanatfelvétel()</function> eljárás. Ennek segítségével maga
            a program készít egy képet, nincs szükség a PrintScreen használatára.
            <programlisting language="java"><![CDATA[
    public void pillanatfelvétel() {
        // Az elmentendő kép elkészítése:
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.YELLOW);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        g.dispose();
        // A pillanatfelvétel képfájl nevének képzése:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmaz_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        // A fájl nevébe belevesszük, hogy melyik tartományban
        // találtuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }]]> 
            </programlisting>
            A kép elkészítséhez szükség van arra, hogy létrehozzunk egy új
            képobjektumot. Ezt nevezzük <function>mentkép</function>-nek.
            Majd a képből készítünk egy grafikus objektumot a <function>getGraphics()</function>
            függvény segítségével. Ezzel lehetővé tesszük, hogy a ki tdujuk rá írni a 
            <function>kép</function>-ben tárolt halmazt, a szükséges értkéket.
            Szöveget a képre a <function>drawString</function> függvénnyel tudjuk megtenni.
            A <function>dispose()</function> pedig bezárja az ablakot, amiben a kép
            tartalmának a kiírását végezzük. Majd a kép nevét adjuk meg. Ahogy a 
            forrásban is látható, ez tartalmazza a halmaz nevét, hogy hanyadik pillanatképet
            készítjük, és azt is, hogy melyik tartományban találtuk a halmazt.
            Végezetül a <function>javax.imageio.ImageIO.write()</function> függvény
            segítségével kiírjuk a <function>mentKép</function> tartalmát egy 
            png fájlba. A célállományt a <function>java.io.File()</function>
            segítségével hozzuk létre.
            <programlisting language="java"><![CDATA[
    public void run() {
        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        int rgb;
        int iteráció = 0;
        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                // c = (reC, imC) a háló rácspontjainak
                // megfelelő komplex szám
                reC = a+k*dx;
                imC = d-j*dy;
                // z_0 = 0 = (reZ, imZ)
                reZ = 0;
                imZ = 0;
                iteráció = 0;
                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                    // z_{n+1} = z_n * z_n + c
                    ujreZ = reZ*reZ - imZ*imZ + reC;
                    ujimZ = 2*reZ*imZ + imC;
                    reZ = ujreZ;
                    imZ = ujimZ;
                    
                    ++iteráció;
                    
                }
    
                iteráció %= 256;
                Color bg = new Color(0, 255-iteráció, 0);
                rgb = bg.getRGB();
                kép.setRGB(k, j, rgb);
            }
            repaint();
        }
        számításFut = false;
    }]]>
            </programlisting>
             A Mandelbrot halmaz kiszámolását a megadott tartományban a 
            <function>run()</function> függvény végzi. Ez a <function>Runnable</function>
            interfészben lett deklarálva, de nekünk kell definiálni. Maga az 
            algoritmus a teljes másolata a fejeztben már többször leírtnak. Egyedüli
            érdekesség a színezés beállítása. Deklarálunk ehhez egy <function>rgb</function>
            nevű változót. A példányosítunk egy <function>Color</function> objektumot
            <function>bg</function> néven, melyben eltároljuk a szükséges színt.
            Ennek a színnek az RGB felépítése teljesen megyegyezik a C++-os verziójéval.
            Ebből az objektumból a színt a <function>getRGB()</function> függvénnyel kapjuk
            meg, ami egy RGB értékkel tér vissza, azaz egy egész számmal.Végül a 
            <function>setRGB()</function> függvénnyel állítjuk be az egyes pixelek színét.
            A <function>repaint()</function> függvény azért felelős, hogy újrarajzoljuk a 
            halmazt a megváltozott értékek alapján. Ha végeztünk a halmaz számolásával, 
            a <function>számításFut</function> értékét hamisra állítjuk.
            <programlisting>
    public static void main(String[] args) {
        new MandelbrotHalmaz(-2.0, .7, -1.35, 1.35, 600, 255);
    }
            </programlisting>
            A <function>main</function> függvényben pedig nem teszünk mást, csak
            példányosítunk egy <function>MandelbrotHalmaz</function> objektumot.
            Ezzel a <filename>MandelbrotHalmaz.java</filename> forrás végére értünk,
            láthatjuk, hogy a nagyítás során végrehajtandó utasítások nagyrésze itt hajtódik
            végre.
         </para>
         <para>
             Nézzük meg, mit tartalmaz a <filename>MandelbrotHalmazNagyító.java</filename>
             forrás fájl.
             <programlisting language="java"><![CDATA[
 import java.util.*;
public class MandelbrotHalmazNagyító extends MandelbrotHalmaz {
    private int x, y;
    private int mx, my;
    private List<Integer> zX = new ArrayList<>();
    private List<Integer> zX2 = new ArrayList<>();
    private List<Integer> zY = new ArrayList<>();
    private List<Integer> zY2 = new ArrayList<>();]]>
             </programlisting>
             A <function>MandelbrotHalmazNagyító</function> osztályt kiegészítjük a 
             már kkorábban taglalt <function>MandelbrotHalmaz</function> osztállyal.
             Erre azért van szükség, mert a halmaz számolása abban az osztályban zajlik,
             de maga a programablakot is ott kezeljük. Az <function>x,y</function>
             változók a nagyítandó terület bal felső sarkát határozzák meg. A 
             <function>mx, my</function> pedig a terület méretét. Az 
             <function>zX, zX2, zY, zY2</function> listákban pedig a 
             z<subscript>n</subscript> számokat tároljuk el. 
             <programlisting language="java"><![CDATA[
    public MandelbrotHalmazNagyító(double a, double b, double c, double d,
        int szélesség, int iterációsHatár) {
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felső sarkát:
            public void mousePressed(java.awt.event.MouseEvent m) {
                if (m.getButton() == java.awt.event.MouseEvent.BUTTON1){
                // A nagyítandó kijelölt területet bal felső sarka:
                    x = m.getX();
                    y = m.getY();
                    mx = 0;
                    my = 0;
                }
                else if(m.getButton() == java.awt.event.MouseEvent.BUTTON3)
                {
                    double dx = (b-a)/szélesség;
                    double dy = (d-c)/szélesség;
                    double reC, imC, reZ, imZ, ujreZ, ujimZ;
 
                    int iteracio = 0;
 
                    reC = a+m.getX()*dx;
                    imC = d-m.getY()*dy;
 
                    reZ = 0;
                    imZ = 0;
                    iteracio = 0;
 
                    while(reZ*reZ + imZ*imZ < 4 && iteracio < 255) {
                        // z_{n+1} = z_n * z_n + c
                        ujreZ = reZ*reZ - imZ*imZ + reC;
                        ujimZ = 2*reZ*imZ + imC;
                        zX.add((int)((reZ - a)/dx));
                        zY.add( (int)((d - imZ)/dy));
                        zX2.add((int)((ujreZ - a)/dx));
                        zY2.add((int)((d - ujimZ)/dy));
                        reZ = ujreZ;
                        imZ = ujimZ;
 
                        ++iteracio;
                    }
                }
                repaint();
            }]]>
             </programlisting>
             Az osztály konstruktora érdekesnek tűnhet első látásra. A 
             <function>super()</function> függvény segítségével meg tdujuk hívni a 
             <function>MandelbrotHalmaz</function> osztály konstruktorát. Ezután 
             hozzá tudunk férni az ablak beállításaihoz, tehát át tudjuk állítani a 
             nevét a <function>setTitle()</function> függvénnyel. Ebben a részben 
             valósítjuk meg az egér kezelését a programban. Ha a bal egérgombot
             megnyomjuk, akkor a kurzor aktuális pozíciója beletöltődik a 
             a kijelölendő terület bal felső sarkát meghatározó változókba, a 
             terület méretét pedig nullázzuk. Ha pedig a jobb egérgomobt nyomjuk le, 
             akkor a program kiszámolja attól a ponttól kezdve a z<subscript>n</subscript>
             számokat, egsézen addig, míg el nem érjük az iterációs határt, vagy a 
             z<subscript>n</subscript> értéke nem haladja meg a 2-őt. A kapott értékeket
             pedig betöltkük a megfelelő listába. Végül meghívjuk a <function>repaint()</function>
             függvényt.
             <programlisting language="java"><![CDATA[
        public void mouseReleased(java.awt.event.MouseEvent m) {
                double dx = (MandelbrotHalmazNagyító.this.b
                        - MandelbrotHalmazNagyító.this.a)
                        /MandelbrotHalmazNagyító.this.szélesség;
                double dy = (MandelbrotHalmazNagyító.this.d
                        - MandelbrotHalmazNagyító.this.c)
                        /MandelbrotHalmazNagyító.this.magasság;
                // Az új Mandelbrot nagyító objektum elkészítése:
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON3){
                    return;
                    }
                dispose();
                new MandelbrotHalmazNagyító(MandelbrotHalmazNagyító.this.a+x*dx,
                        MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                        MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                        MandelbrotHalmazNagyító.this.d-y*dy,
                        600,
                        MandelbrotHalmazNagyító.this.iterációsHatár);
            }
        });]]>
             </programlisting>
             A konstruktor része még a egérgomb felengedését kezelő
             függvény is. Ekkor állítjuk be a vizsgált tartomány 
             hálósűrűségét meghatározó változókat, vagyis a <function>dx</function>
             és <function>dy</function>-t. Különbséget kell tennünk abban, hogy 
             melyik gombot engedtük fel, mert, ha a jobbot, akkor nem kell új
             Mandelbrot halmazt létrehozni, vagyis <function>return</function>
             kilépünk a függvényből. Ellenkező esetben bezárjuk a régi ablakot 
             a <function>dipose()</function> segítségével, majd létrehozunk egy 
             új <function>MandelbrotHalmazNagyító</function> objektumot, ami 
             nyit egy új ablakot. Az új objektumot a nagyításra kijelölt terület alapján
             határozzuk meg.
             <programlisting language="java"><![CDATA[
    addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt terület szélessége és magassága:
                mx = m.getX() - x;
                my = mx;
                repaint();
            }
        });]]>
             </programlisting>
             Ha az egerrel nem csak kattintunk, hanem húzunk is, akkor a 
             kattintáskor lenullázott méret változókat az első és
             az utolsó x érték különbségére módosítjuk. Mind a magasságot, 
             mind a szélességet, ezzel garantálva, hogy mindig négyzetet jelöljünk ki.
             Ennél is hívjuk a <function>repaint()</function> függvényt.
             Ennek az osztálynak is van <function>pillanatfelvétel()</function>
             függvény.
             <programlisting language="java"><![CDATA[
     public void pillanatfelvétel() {
        // Az elmentendő kép elkészítése:
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.YELLOW);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.WHITE);
        g.drawRect(x, y, mx, my);
        if (!zX.isEmpty())
        {
            for (int i = 0; i<zX.size(); ++i){
                g.drawLine(zX.get(i), zY.get(i), zX2.get(i), zY2.get(i));
            }
        }
        g.dispose();        
        // A pillanatfelvétel képfájl nevének képzése:
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        // A fájl nevébe belevesszük, hogy melyik tartományban
        // találtuk a halmazt:
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }]]>
             </programlisting>
             Ez csak annyiban különbözik az előzőtől, hogy a számítás állapotát
             jelző piros vonalat is kirajzolja, és a z<subscript>n</subscript>
             számokat összekötő vonalakat is fehér színnel.
             Erre azért volt szükség, mert pillanatfelvételt készítünk, így ha 
             éppen fut a számítás, akkor meg kell jeleníteni a piros vonalat is.
             Vagy ha kirajzoltattuk a z<subscript>n</subscript> számokat az ablakba, akkor
             a képen is jelenjen ez meg.
             <programlisting language="java"><![CDATA[
    public void paint(java.awt.Graphics g) {
        // A Mandelbrot halmaz kirajzolása
         g.drawImage(kép, 0, 0, this);
        // Ha éppen fut a számítás, akkor egy vörös
        // vonallal jelöljük, hogy melyik sorban tart:         
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        // A jelző négyzet kirajzolása:
        g.setColor(java.awt.Color.WHITE);
        g.drawRect(x, y, mx, my);
        if (!zX.isEmpty())
        {
            for (int i = 0; i<zX.size(); ++i){
                g.drawLine(zX.get(i), zY.get(i), zX2.get(i), zY2.get(i));
            }
        }
    }]]>
             </programlisting>
             Az osztály <function>paint</function> függvény felüldefiniálása is
             azt a célt szolgálja, hogy az imént a pillanatfelvételnél
             kirajzolt vonalakat az ablkban is kirajzoljuk. Egyrészt 
             ki kell rajzolni a számítás előrehaladását jelző vonalat, ha 
             éppen fut a halmaz számítása, ehhez piros szít használunk. Amikor
             kijelöljük a területet az egérrel, akkor ki kell rajzolni a programnak
             egy fehér négyzetet. Ezt a <function>drawRect()</function> függvény
             hajtja végre. Végül abban az esetben, ha már legalább egy z<subscript>n</subscript>
             számot kiszámoltunk, akkor az ezeket a pontokat összekötő egyeneseket
             is ábrázoljuk.
             <programlisting language="c++"><![CDATA[
    public static void main(String[] args) {
        // A kiinduló halmazt a komplex sík [-2.0, .7]x[-1.35, 1.35]
        // tartományában keressük egy 600x600-as hálóval és az
        // aktuális nagyítási pontossággal:
        new MandelbrotHalmazNagyító(-2.0, .7, -1.35, 1.35, 600, 255);
    }]]>
             </programlisting> 
             A <function>main</function> függvény pedig most is 
             csak példányosít egy objektumot, jelen esteben egy 
             <function>MandelbrotHalmazNagyító</function> osztályút.
         </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
