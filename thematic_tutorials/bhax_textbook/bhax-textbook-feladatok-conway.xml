<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Myrmecologist">itt</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Használat előtt</title>
            <para>
                sudo apt-get install qtbase5-dev
            </para>
        </caution>
        <para>
            A program lényegében a hanygák feromonokkal történő
            kommunkiációját szimulálja. A képernyőt cellákra
            osztjuk, és a cellákban lévő hangyák megkeresik azt
            a szomszédjukat, akinek a legerősebb a feromonja, és
            arra lép tovább. A cellák fermonon értékei folyamatosan
            csökkennek, viszont ha valamelyik hangya bele lép az egyikbe, 
            akkor ott megnő a fermomon szint. Ezeket az értékeket mind 
            parancssori argumentumok formájában tudjuk megadni.
        </para>
        <para>
            A <filename>main.cpp</filename>-ben megtalálható futtatási javaslat a következő:
            <programlisting>
./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
            </programlisting>
            A <function>w</function> kapcsolóval állítjuk be, hogy egy cella
            hány oszlopból álljon, vagyis, milyen széles legyen, a 
            <function>m</function>-el pedig a cellák magasságát. Az
            <function>n</function> kapcsoló a hangyák számát állítja be, a 
            <function>t</function>-vel pedig a lépéseik gyakoriságát állítjuk,
            melyet miliszekundumba adunk meg. A <function>p</function>-vel
            a feromonok párolgásának a gyorsaságát állítjuk be, az
            <function>f</function>-el pedig azt, hogyha egy hangya belelép
            egy cellába, akkor mennyivel növeli meg annak a feromonértékét.
            A <function>d</function> kapcsolóval meg tudjuk adni, hogy mi legyen
            a cellák feromonértékének a kezdőértéke. Az <function>a</function>
            és a <function>i</function> kapcsolókkal meg tudjuk adni a maximális
            és a minimális fermonoértékeket. Az <function>s</function>
            kapcsoló azt állítja, hogy a hangyák mennyi feromont hagyjanak a
            szomszédos cellákban. Végezetül pedig lehetőségünk van 
            beállítani azt is, hogy az egyes cellákban maximum hány
            hangya lehessen egyszerre. Természetesen ezeket nem muszáj
            megadni, mivel vannak a programban alapértelmezett értékek a 
            futtatáshoz.
        </para>
        <caution>
            <title>Futtatás</title>
            <para>
                Mindegyik fájlnak egy mappában kell lennie. Majd:
                <programlisting>
qmake myrmecologist.pro
make
./myrmecologist //+ a kapcsolók, ha szeretnéd állítani
                </programlisting>
            </para>
        </caution>
        <para>
            <figure>
                <title>Kapcsolók nélkül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Myrmecologist/alapertelmezett.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Kapcsolókkal</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Myrmecologist/kapcsoloval.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
            Most, hogy láttuk, hogyan is működik a program, lássuk magát a forrást.
            Mivel most több fájlból áll a forrás, ezért egy kicsit forradalmibb
            módon próbálom neked demonstrálni a program alapvető felépítését. Ezt
            nevezzük UML osztálydiagramnak. Segítségével könnyebben átláthatod
            a bonyolult programokat.
            <figure>
                <title>UML diagram</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Myrmecologist/uml.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Az ábrán láthatjuk a programunk egyes osztáylait. Azon elemek, melyek előtt
            a "-" jel szerepel, nem érhetők el az osztályon kívül, míg a "+"
            jelesek igen. Tehát ezekkel különböztetjük meg az oszrtályok 
            <function>public</function> és <function>private</function> tagjait. 
            A legkisebb osztály az <function>Ant</function>, melyet a 
            <filename>ant.h</filename> header tartalmazza.
            <programlisting language="c++"><![CDATA[
class Ant
{

public:
    int x;
    int y;
    int dir;

    Ant(int x, int y): x(x), y(y) {
        
        dir = qrand() % 8;
        
    }

};

typedef std::vector<Ant> Ants;]]>
            </programlisting>
            Ebben csak a hangyák pozícióját határozzuk meg az x és az y koordináták
            segítségével, plusz az irányát is itt számoljuk ki, melyet a 
            <function>dir</function> változóban tárolunk.
            Az utolsó sor az ábrán már külön bubrékban szerepel. A
            <function>typedef</function> segítségével az 
            <function>Ant</function> típusú elemkeből álló vektorokra 
            az <function>Ants</function> alias-szal tudunk hivatkozni.
            Tehát:
            <programlisting language="c++">
                Ants elso;
            </programlisting>
            Ebben a kódcsipetben tehát egy <function>Ant</function>
            típusú elemekből álló vektort deklaráltunk.
        </para>
        <para>
            A következő osztályunk az <function>AntWin</function>, melyet
            az <filename>antwin.h</filename> és az 
            <filename>antwin.cpp</filename>-ben találunk. A header fájlban
            vannak az egyes elemek deklarációi, míg a C++ forrás tartalmazza
            azok definícióját. Ez viszonylag gyakori eljárás a C++
            programozásban, mivel így letisztultabb kódot kapunk.
            <programlisting language="c++"><![CDATA[
#include <QMainWindow>
#include <QPainter>
#include <QString>
#include <QCloseEvent>
#include "antthread.h"
#include "ant.h"

class AntWin : public QMainWindow
{
    Q_OBJECT

public:
    AntWin(int width = 100, int height = 75,
           int delay = 120, int numAnts = 100,
           int pheromone = 10, int nbhPheromon = 3,
           int evaporation = 2, int cellDef = 1,
           int min = 2, int max = 50,
           int cellAntMax = 4, QWidget *parent = 0);

    AntThread* antThread;

    void closeEvent ( QCloseEvent *event ) {

        antThread->finish();
        antThread->wait();
        event->accept();
    }

    void keyPressEvent ( QKeyEvent *event )
    {

        if ( event->key() == Qt::Key_P ) {
            antThread->pause();
        } else if ( event->key() == Qt::Key_Q
                    ||  event->key() == Qt::Key_Escape ) {
            close();
        }

    }

    virtual ~AntWin();
    void paintEvent(QPaintEvent*);

private:

    int ***grids;
    int **grid;
    int gridIdx;
    int cellWidth;
    int cellHeight;
    int width;
    int height;
    int max;
    int min;
    Ants* ants;

public slots :
    void step ( const int &);

};]]>
            </programlisting>
            A Qt egyes funkcióinak a használatához nélkülözhetetlen a 
            fenti header-ök csatolása. A <function>QMainWindow</function>
            osztállyal tudjuk megalkotni a programunk ablakját, amiben a
            a hangyaszimuláció kirajzolódik. Kirajzolódik, ezért van szükség
            a <function>QPainter</function> osztályra. A <function>QString</function>
            osztály segítségével tudunk Unicode karakterkódulású sztringeket
            tárolni, a <function>QCloseEvent</function> segítségével pedig
            a program bezárását tudjuk szabályozni paraméterek segítségével.
            Ez a header fájl kapcsolja össze az <function>Ant</function> és
            a <function>AntThread</function> osztáylokat. Összességében elmondható,
            hogy ebben az osztályban történik meg a pogramablaknak a létrehozása,
            itt állítjuk be az egyes paramétereket, amkiet parancssori argumentumok
            segítségével a programnak át tudunk adni. A program futásának
            szüneteltetéséért és bezárásáért is ez az  osztály felelős, itt vannak 
            meghatározva az egyes billentyűkhöz rendelt tevékenységek.
        </para>
        <para>
            Maga az érdemi számítást pedig az <filename>antthread.h</filename>
            és az <filename>antthread.cpp</filename> fájlok tartalmazzák.
            Az előzőhöz hasonlóan itt is csak a headert nézzük meg:
            <programlisting language="c++"><![CDATA[
#include <QThread>
#include "ant.h"

class AntThread : public QThread
{
    Q_OBJECT

public:
    AntThread(Ants * ants, int ***grids, int width, int height,
             int delay, int numAnts, int pheromone, int nbrPheromone, 
             int evaporation, int min, int max, int cellAntMax);
    
    ~AntThread();
    
    void run();
    void finish()
    {
        running = false;
    }

    void pause()
    {
        paused = !paused;
    }

    bool isRunnung()
    {
        return running;
    }

private:
    bool running {true};
    bool paused {false};
    Ants* ants;
    int** numAntsinCells;
    int min, max;
    int cellAntMax;
    int pheromone;
    int evaporation;
    int nbrPheromone;
    int ***grids;
    int width;
    int height;
    int gridIdx;
    int delay;
    
    void timeDevel();

    int newDir(int sor, int oszlop, int vsor, int voszlop);
    void detDirs(int irany, int& ifrom, int& ito, int& jfrom, int& jto );
    int moveAnts(int **grid, int row, int col, int& retrow, int& retcol, int);
    double sumNbhs(int **grid, int row, int col, int);
    void setPheromone(int **grid, int row, int col);

signals:
    void step ( const int &);

};]]>
            </programlisting>
            A <function>Qthread</function> osztályra azért van szükség, hogy
            kezelni tudjuk a program egyes szálait. Az  <function>AntThread</function>
            osztély konstruktora megkapja azokat az értékeket, amiket az
            <function>AntWin</function> osztályban megkapott a program, majd 
            elkezdi "mozgatni" a hangyákat. Kiszámolja az irányukat a 
            feromonszintek és a cellatelítettség alapján, állítja az 
            egyes cellák feromonértékeit, és megadja az <function>AntWin</function>
            osztálynak, hogy mely cellákat kell átszínezni.
        </para>
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/Siklokilovo/Java">itt</link>               
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A feladat megoldásában tutorként részt vett Petrus József Tamás.
            </para>
        </caution>
		<caution>
			<title>Használat</title>
			<para>
				<programlisting>
sudo apt-get install openjdk-8-jdk
javac game_of_life.java
java game_of_life
				</programlisting>
			</para>
		</caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
		<para>
			Melvin Conway 1970-ben alkotta meg saját sejtautomatáját.
			A sejtautomaták lényege, hogy megadunk néhány feltételt
			az életben maradásra, a születésre, és a halálozásra, majd
			figyeljük, hogy az általunk "teremtett" lények, hogyan
			"élnek". Conway 3 egyszerű szabályt adott meg,
			és mind a mai napig ez a legnépszerűbb sejtautomata.
		</para>
		<para>
			A szabályok a következők:
			<programlisting>
1. szabály: Egy sejt csak akkor marad életbe, ha 2 vagy 3 szomszédja van.
2. szabály: Ha egy sejtnek 3-nál több szomszédja van, túlnépesedés miatt
			meghal. Ha pedig 2-nél kevesebb a szomszédai száma, akkor
			pedig az elszigetelődés miatt hal meg.
3. szabály: Egy sejt megszületik, ha az üres cellának 3 élő sejt
			található a szomszédos cellákban.
			</programlisting>
			Ezen szabályok megadásával elképesztő animációkat kapunk,
			de mi most kifejezetten egyre, a siklókilövőre koncentrálunk.
			Ehhez fix cellákba helyezzük a kezdeti sejteket, és utána
			folymatosan indulnak el felfelé a siklók.
			<programlisting language="java"><![CDATA[
	public class game_of_life extends JFrame {
    RenderArea ra;
    private int i;
    
    public game_of_life() {
        super("Game of Life");
        this.setSize(1005, 1030);
        this.setDefaultCloseOperation(EXIT_ON_CLOSE);
        this.setVisible(true);
        this.setResizable(false);
        ra = new RenderArea();
        ra.setFocusable(true);
        ra.grabFocus();
        add(ra);
        int[][] siklokilovo = {{6,0},{6,1},
            {7,0},{7,1},
            {3,13},
            {4,12},{4,14},
            {5,11},{5,15},{5,16},{5,25},
            {6,11},{6,15},{6,16},{6,22},{6,23},{6,24},{6,25},
            {7,11},{7,15},{7,16},{7,21},{7,22},{7,23},{7,24},
            {8,12},{8,14},{8,21},{8,24},{8,34},{8,35},
            {9,13},{9,21},{9,22},{9,23},{9,24},{9,34},{9,35},
            {10,22},{10,23},{10,24},{10,25},
            {11,25}};
        int min_o = 5;
        int min_s = 85;]]>
			</programlisting>
			A <function>game_of_life</function> osztálynak a 
			<function>JFrame</function> a szülőosztálya. A 
		    <function>JFrame</function> osztályra azért van szükség,
			hogy az ablak, amiben a prograunk fut, megjelenjen.
			Deklarálunk egy <function>RenderArea</function> objektumot,
			melynek segítségével az ablak specifikációját adjuk meg.
			A <function>game_of_life()</function> konstruktorban pont
			ezeket állítjuk be. Megadjuk az ablak nevét, a méretét. Beállítjuk
			azt, hogy hogyan záródjon be a program alapértelmezetten, és az
			átméretezhetőséget kikapcsoljuk, mivel fix abalkmérettel
			dolgozunk. Az <function>ra</function> objektumot hozzáadjuk
			az ablakhoz, így tudjuk kirajzolni a sejtautomatát. Ezután
			pedig megalkotjuk a siklókilövőhöz szükséges fix pontok
			koordinátáit. Végül pedig meghatározzuk, hol legyen az origó, 
			ahonnan a koordinátákat kirajzoljuk.
			<programlisting language="java"><![CDATA[
	    for (int i = 0; i < siklokilovo.length; ++i)
        {
          ra.entities.get(min_o + siklokilovo[i][1]).set(min_s+ siklokilovo[i][0],!ra.entities.get(min_o + siklokilovo[i][1]).get((min_s+ siklokilovo[i][0])));
                this.update(this.getGraphics());  
        }
        

        ra.edit_mode = false;
        ra.running = true;]]>
			</programlisting>
			A <function>for</function> ciklusban kirajzoljuk az egyes
			sejteket a képernyő megadott pontjaira.
			Az <function>edit_mode</function>-ra azért van szükség, mert
			a program képes lenne egyedi ábrák használatára is, de ez most
			nem része a feladatnak. A <function>running</function>
			pedig jelzi, hogy a program fut.
			<programlisting language="c++"><![CDATA[
	public void update() {
        ArrayList<ArrayList<Boolean>> entities = new ArrayList<ArrayList<Boolean>>();// = ra.entities;
        int size1 = ra.entities.size();
        int size2 = ra.entities.get(0).size();
        for(int i=0;i<size1;i++)
        {
            entities.add( new ArrayList<Boolean>());
            for(int j=0;j<size2;j++)
            {
                int alive = 0;
                
                if(ra.entities.get((size1+i-1)%size1).get((size2+j-1)%size2)) alive++;
                if(ra.entities.get((size1+i-1)%size1).get((size2+j)%size2)) alive++;
                if(ra.entities.get((size1+i-1)%size1).get((size2+j+1)%size2)) alive++;

                if(ra.entities.get((size1+i)%size1).get((size2+j-1)%size2)) alive++;
                if(ra.entities.get((size1+i)%size1).get((size2+j+1)%size2)) alive++;

                if(ra.entities.get((size1+i+1)%size1).get((size2+j-1)%size2)) alive++;
                if(ra.entities.get((size1+i+1)%size1).get((size2+j)%size2)) alive++;
                if(ra.entities.get((size1+i+1)%size1).get((size2+j+1)%size2)) alive++;
                


                /*for(int k=-1;i<2;k++)
                {
                    for(int l = -1; l < 2 ;l++)
                    {
                        if(!(k==0 && l == 0))
                        {
                            if(ra.entities.get((size1+i+k)%size1).get((size2+j+l)%size2)) alive++;
                        }
                    }
                }*/

                if(ra.entities.get(i).get(j))
                {
                    if(alive < 2 || alive > 3)
                    {
                        //ra.entities.get(i).set(j,false);
                        entities.get(i).add(false);
                    }
                    else
                    {
                        entities.get(i).add(true);
                    }
                }
                else
                {
                    if(alive == 3)
                    {
                        //ra.entities.get(i).set(j,true);
                        entities.get(i).add(true);
                    }
                    else
                    {
                        entities.get(i).add(false);
                    }
                }

            }
        }
        ra.entities = entities;

    }]]>
			</programlisting>
			Az <function>update()</function> függvény felelős a
			Conway által meghatározott szabályok implementálásáért.
			Minden sejthez kiszámoljuk a szomszédjai számát, majd 
			a szabáylok alapján eldöntjük, hogy életben marad-e, meghal,
			vagy születik.
			<programlisting language="java"><![CDATA[	
    class RenderArea extends JPanel implements KeyListener {
        public ArrayList<ArrayList<Boolean>> entities;

        public int diff;
        public boolean edit_mode;
        public boolean running;
        public RenderArea() {
            super();
            setSize(1000, 1000);
            setVisible(true);
            setBackground(Color.WHITE);
            setForeground(Color.BLACK);
            setLocation(0, 0);

            diff = 10;
            

            
            this.addKeyListener(this);
            entities = new ArrayList<ArrayList<Boolean>>();
            for(int i=0;i<1000/diff;i++)
            {
                entities.add(new ArrayList<Boolean>());
                for(int j=0;j<1000/diff;j++)
                {
                    entities.get(i).add(false);
                }
            }
            
        }

        


        @Override
        public void keyTyped(KeyEvent e) {
            //System.out.println(e.getKeyChar());
        }
    
        @Override
        public void keyReleased(KeyEvent e) {
            System.out.println("Key pressed:"+e.getKeyChar());
            if(e.getKeyChar()=='e')
            {
                edit_mode = !edit_mode;
            }
            else if(e.getKeyChar()=='q')
            {
                this.running = false;
            }
            else if(e.getKeyChar()=='c')
            {
                if(edit_mode)
                {
                    for(int i=0;i<this.entities.size();i++)
                    {
                        for(int j=0;j<this.entities.get(1).size();j++)
                        {
                            this.entities.get(i).set(j,false);
                        }
                    }
                    this.update(this.getGraphics());
                }
                
            }

        }
    
        @Override
        public void keyPressed(KeyEvent e) {
            //System.out.println(e.getKeyChar());
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            g.clearRect(0, 0, 1000, 1000);
            for(int i=0;i<1000;i+=diff)
            {
                g.drawLine(i, 0, i, 1000);
            }
            for(int j=0;j<1000;j+=diff)
            {
                g.drawLine(0, j, 1000, j);
            }
            for(int i=0;i<1000;i+=diff)
            {
                for(int j=0;j<1000;j+=diff)
                {
                    if(entities.get(i/diff).get(j/diff))
                    {
                        g.setColor(Color.BLACK);
                    
                    }
                    else
                    {
                        g.setColor(Color.WHITE);
                    }
                    
                    g.fillRect(i+2, j+2, diff-3, diff-3);
                }
            }
        }

        

        private static final long serialVersionUID = 1L;
        
    }]]>
			</programlisting>
			A <function>RenderArea</function> osztály segítségével 
			történik a sejtek kirajzolása, a rácsháló megjelenítése,
			és a billentyűzet kezelést is ez az osztály implementálja,
			és az egérkezelést is, csak most azt nem használjuk, ezért
			a likelt forrásban azt kikommentelve találod. A
			<function><![CDATA[@override]]></function> címke segítségével
			az alatta lévő függvényt nem kell a programban deklarálni.
		</para>
		<para>
			Végezetül a <function>main</function>-ben deklarálunk egy
			<function>game_of_life</function> objektumot, majd addig 
			jelenítjük meg az újabb állapotokat, ameddig a felhasználó
			le nem nyomja a "q" billentyűt, vagy be nem zárja a programot.
		</para>
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/Siklokilovo/QT">itt</link>               
        </para>
		<caution>
			<title>Használat</title>
			<para>
				<progralisting>
sudo apt-get install libqt4-dev
qmake Qt sejtkilövő.pro
make
./Qt sejtkilövő
				</programlisting>
			</para>
		</caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...<emphasis>
        </para>
	    <para>
			Az előző feladatban taglalt Conway-féle életjátékot fogjuk most megcsinálni a Qt grafikus felületet
			használva C++ nyelven. A szabályok továbbra is adottak. A sejtek meghalnak, ha 2-nél kevesebb
			a szomszédjuk vagy 3-nál több szomszédja van. Megszületik, ha pontosan 3 szomszédja van, és ha
			még abban a cellában nem él. Végezetül, ha 2-nél több, de 3-nál kevesebb a szomszédok száma,
			akkor a életben marad a sejt. Ebben a feladatban is a siklőkilövőt kell megvalósítani, de ehhez már
			tudjuk a koordinátákat, tehát ez nem lesz gond. A program nem képes önálló alakzatok megvalósítására,
			még  a forrása sem tartalmazza az ehhez szükséges kódokat.
		</para>
		<para>
			A program forrása 4 fájból áll, erre azért van szükség, hogy áltláthatóbbak legyenek az egyes osztályok
			definíciója.
			<programlisting language="c++"><![CDATA[
#include <QtGui/QMainWindow>
#include <QPainter>
#include "sejtszal.h"

class SejtSzal;

class SejtAblak : public QMainWindow
{
    Q_OBJECT

public:
    SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);
    ~SejtAblak();
    // Egy sejt lehet élõ
    static const bool ELO = true;
    // vagy halott
    static const bool HALOTT = false;
    void vissza(int racsIndex);

protected:
    // Két rácsot használunk majd, az egyik a sejttér állapotát
    // a t_n, a másik a t_n+1 idõpillanatban jellemzi.
    bool ***racsok;
    // Valamelyik rácsra mutat, technikai jellegû, hogy ne kelljen a
    // [2][][]-ból az elsõ dimenziót használni, mert vagy az egyikre
    // állítjuk, vagy a másikra.
    bool **racs;
    // Megmutatja melyik rács az aktuális: [rácsIndex][][]
    int racsIndex;
    // Pixelben egy cella adatai.
    int cellaSzelesseg;
    int cellaMagassag;
    // A sejttér nagysága, azaz hányszor hány cella van?
    int szelesseg;
    int magassag;    
    void paintEvent(QPaintEvent*);
    void siklo(bool **racs, int x, int y);
    void sikloKilovo(bool **racs, int x, int y);

private:
    SejtSzal* eletjatek;

};]]>
			</programlisting>
			A <function>sejtablak.cpp</function> és 
			<function>sejtablak.h</function>-ban található a 
			<function>SejtAblak</function> osztály, ez felelős
			a program kirajzolásáért a képernyőre. A <filename>sejtablak.cpp</filename>
			fájlból a siklókilövő implementációját emelném ki, ebben 
			egy kicsit mást megoldást használtunk.
			<programlisting language="c++"><![CDATA[
void SejtAblak::sikloKilovo(bool **racs, int x, int y) {

    racs[y+ 6][x+ 0] = ELO;
    racs[y+ 6][x+ 1] = ELO;
    racs[y+ 7][x+ 0] = ELO;
    racs[y+ 7][x+ 1] = ELO;

    racs[y+ 3][x+ 13] = ELO;

    racs[y+ 4][x+ 12] = ELO;
    racs[y+ 4][x+ 14] = ELO;

    racs[y+ 5][x+ 11] = ELO;
    racs[y+ 5][x+ 15] = ELO;
    racs[y+ 5][x+ 16] = ELO;
    racs[y+ 5][x+ 25] = ELO;

    racs[y+ 6][x+ 11] = ELO;
    racs[y+ 6][x+ 15] = ELO;
    racs[y+ 6][x+ 16] = ELO;
    racs[y+ 6][x+ 22] = ELO;
    racs[y+ 6][x+ 23] = ELO;
    racs[y+ 6][x+ 24] = ELO;
    racs[y+ 6][x+ 25] = ELO;

    racs[y+ 7][x+ 11] = ELO;
    racs[y+ 7][x+ 15] = ELO;
    racs[y+ 7][x+ 16] = ELO;
    racs[y+ 7][x+ 21] = ELO;
    racs[y+ 7][x+ 22] = ELO;
    racs[y+ 7][x+ 23] = ELO;
    racs[y+ 7][x+ 24] = ELO;

    racs[y+ 8][x+ 12] = ELO;
    racs[y+ 8][x+ 14] = ELO;
    racs[y+ 8][x+ 21] = ELO;
    racs[y+ 8][x+ 24] = ELO;
    racs[y+ 8][x+ 34] = ELO;
    racs[y+ 8][x+ 35] = ELO;

    racs[y+ 9][x+ 13] = ELO;
    racs[y+ 9][x+ 21] = ELO;
    racs[y+ 9][x+ 22] = ELO;
    racs[y+ 9][x+ 23] = ELO;
    racs[y+ 9][x+ 24] = ELO;
    racs[y+ 9][x+ 34] = ELO;
    racs[y+ 9][x+ 35] = ELO;

    racs[y+ 10][x+ 22] = ELO;
    racs[y+ 10][x+ 23] = ELO;
    racs[y+ 10][x+ 24] = ELO;
    racs[y+ 10][x+ 25] = ELO;

    racs[y+ 11][x+ 25] = ELO;

}]]>
			</programlisting>
			A koordinátákat ezúttal nem egy tömbben tároljuk, hanem
			egyesével kirajzoljuk az összes sejtet a megfelelő pontokra.
			Egy másik különbség, hogy a Java-s példában a konstruktor készítette
			el a siklókilövőhöz szükséges ábrát, itt egy külön eljárást írtunk ezen
			funkcionalitás megoldására.
			<programlisting language="c++"><![CDATA[
#include <QThread>
#include "sejtablak.h"

class SejtAblak;

class SejtSzal : public QThread
{
    Q_OBJECT

public:
    SejtSzal(bool ***racsok, int szelesseg, int magassag,
             int varakozas, SejtAblak *sejtAblak);
    ~SejtSzal();
    void run();

protected:
    bool ***racsok;
    int szelesseg, magassag;
    // Megmutatja melyik rács az aktuális: [rácsIndex][][]
    int racsIndex;
    // A sejttér két egymást követõ t_n és t_n+1 diszkrét idõpillanata
    // közötti valós idõ.
    int varakozas;
    void idoFejlodes();
    int szomszedokSzama(bool **racs,
                        int sor, int oszlop, bool allapot);
    SejtAblak* sejtAblak;

};]]>
			</programlisting>
			A <filename>sejtszal.h</filename> és a 
			<filename>sejtszal.cpp</filename> fájlok tartalmazzák
			a <function>SejtSzal</function> osztályt, mely a 
			szabályok implementálását tartalmazza. Itt zajlik az
			egyes sejtek elhalálozása, születése és életben maradása.
			<programlisting language="c++"><![CDATA[
void SejtSzal::idoFejlodes() {

    bool **racsElotte = racsok[racsIndex];
    bool **racsUtana = racsok[(racsIndex+1)%2];

    for(int i=0; i<magassag; ++i) { // sorok
        for(int j=0; j<szelesseg; ++j) { // oszlopok

            int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);

            if(racsElotte[i][j] == SejtAblak::ELO) {
                /* Élõ élõ marad, ha kettõ vagy három élõ
             szomszedja van, különben halott lesz. */
                if(elok==2 || elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }  else {
                /* Halott halott marad, ha három élõ
             szomszedja van, különben élõ lesz. */
                if(elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
        }
    }
    racsIndex = (racsIndex+1)%2;
}]]>
			</programlisting>
			Magát a konkrét szabályokat a <function>idoFejlodes<function>
			eljárás tartatja be, itt dől el, hogy egy sejt milyen állapotba
			kerül.
		</para>
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/BrainB">itt</link>               
        </para>
        <caution>
            <title>Használata előtt</title>
            <para>
				<programlisting>
sudo apt-get install libqt4-dev
sudo apt-get install opencv-data
sudo apt-get install libopencv-dev
				</programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A BrainB Benchmark feladata az esport tehetségek felkutatása lenne,
            úgy, hogy feltérképezi az agy kognitív képességeit, és az 
            elért pontszámok alapján össze lehet hasonlítani az egyes 
            egyéneket. Maga a benchmark a "karakterelvesztést" teszteli,
            vagyis ha a játékban elveszítjük a karakterünket, mennyi ideig
            tart megtalálnunk, és ha megtaláltuk, mennyi ideig tart elveszítenünk.
            Ideális esetben rövidebb ideig tart megtalálnunk, mint elveszteni.
            A program azt is figyeli, hogy az egyes karakterelvesztésekhez
            milyen bit/sec képernyőváltások tartoznak.
            <figure>
                <title>Program</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/BrainB/program.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A program így néz ki, a feladat annyi, hogy a kurzort rajta kell tartani a Samu Entropyn, minnél tovább tartod
            rajta, annál több New Entropy jelenik meg, ezzel nehezítve a dolgod. Ha elveszted, akkor a szaporodás lelassul, hogy könyebben
            megtalálhasd a karakteredet. 
            A benchmark összesen 10 percig tart, és 
            minél komplikáltabb lesz a kép a végén, annál jobb vagy.
            <figure>
                <title>Eredmény</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/BrainB/eredmeny.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A végén pedig megkapod ezt a fájlt, ami tartalmazza az elért eredményt.
            Hogy te is le tudd futattni, fontos, hogy minden fájl egy mappában legyen, majd
            pedig a következő paracsokat kell kiadni:
            <function>qmake BrainB.pro</function>, <function>make</function>,
            <function>./BrainB</function>. Ha nem szeretnéd az egész
            benchmarkot végig várni, Esc-el ki tudsz lépni bármikor, és
            az addig elért eredményedről is kapsz pontos leírást.
        </para>
        <para>
            A <filename>main.cpp</filename> nézzük át elsőnek.
            <programlisting language="c++"><![CDATA[
#include <QApplication>
#include <QTextStream>
#include <QtWidgets>
#include "BrainBWin.h"

int main ( int argc, char **argv )
{
        QApplication app ( argc, argv );

        QTextStream qout ( stdout );
        qout.setCodec ( "UTF-8" );]]>
            </programlisting>
            Mivel a program a Qt grafikus felületét használja, ezért a
            hozzzá tartozó osztályokat is szükséges hozzáfűzni a 
            forráshoz. Természetesen a <filename>BrainBWin.h</filename>-ra
            is szükségünk van, mert ezzel biztosítjuk, hogy a main-ből
            el tudjuk éerni a többi fájlt. A <function>main</function>
            a már megszokott formában köszön vissza, viszont első
            lépésként deklarálunk egy <function>QApplication</function>
            típusú objektumot, melynek paramétereként adjuk
            át a parancssori argumentumok számát, és tömbüket. A <function>qout</function>
            segítségével pedig a standard kimenetre írunk. Ez is egy objektum, amely
            QTextStream típusú. A <function>qout</function> objektumnak
            része a <function>setCodec</function> függvény, mellyel a
            karakterkódolást tudjuk beállítani.
            <programlisting language="c++"><![CDATA[
                qout << "\n" << BrainBWin::appName << QString::fromUtf8 ( " Copyright (C) 2017, 2018 Norbert Bátfai" ) << endl;]]>
            </programlisting>
            A <function>std::cout</function>-hoz hasonlóan, a <function>qout</function>-ba
            is beleshifteljük a kimenetet. A <function>BrainBWin</function> osztályról majd
            később beszélünk, de itt az osztály <function>appName</function> változóját
            érjük el és írjuk ki. A <function>QString::fromUtf8</function> függvény
            segítségével pedig UTF-8-as stringet írunk ki a parancssorba.
            <programlisting language="c++"><![CDATA[
                QRect rect = QApplication::desktop()->availableGeometry();]]>
            </programlisting>
            A <function>QRect</function> osztály segítségével egy téglalapot
            tudunk rajzolni a síkra, melynek méretét a kijelző méretével tesszük
            egyenlővé. A kijelző méretét úgy kapjuk meg, hogy a 
            <function>desktop()</function> függvéy visszaadja magát az asztalt,
            az <function>availableGeometry()</function> pedig annak a méretét.
            <programlisting language="c++">
                BrainBWin brainBWin ( rect.width(), rect.height() );
            </programlisting>
            Létrehozzuk a <function>BrainBWin</function> objektumunkat, melynek
            átadjuk a képernyő méretét. Ekkor meghívódik a <function>BrainBWin</function>
            konstruktora, amely a következőképpen néz ki:
            <programlisting language = "c++"><![CDATA[
BrainBWin::BrainBWin ( int w, int h, QWidget *parent ) : QMainWindow ( parent )
{


        statDir = appName + " " + appVersion + " - " + QDate::currentDate().toString() + QString::number ( QDateTime::currentMSecsSinceEpoch() );

        brainBThread = new BrainBThread ( w, h - yshift );
        brainBThread->start();

        connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

}]]>
            </programlisting>
            A <function>QMainWindow</function> osztály segítségével hozzuk létre a fő ablkát a 
            programnak, és ezen belül készítjükm el a <function>BrainBWin</function> ablakot. 
            A hierarchikus sorrendet úgy érjuk el, hogy a <function>BrainBWin</function>
            konstruktora meghívja a <function>QMainWindow</function> konstruktorát, és jellezzük
            neki, hogy ő a szülő. A <function>QString</function> típusú <function>statDir</function>
            változóvban tároljuk a későbiiekben létrehozandó mappa nevét. Mjd a
            <filename>BrainBWin.h</filename>-ban deklarált <function>BrainBThread</function>
            objektumra mutató muutatót ráállítjuk egy újonan lefoglalt tárterületre. Ehhez
            meghívódik a <function>BrainBTread</function> konstruktora.
            <programlisting language="c++"><![CDATA[
BrainBThread::BrainBThread ( int w, int h )
{

        dispShift = heroRectSize+heroRectSize/2;

        this->w = w - 3 * heroRectSize;
        this->h = h - 3 * heroRectSize;

        std::srand ( std::time ( 0 ) );

        Hero me ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                  this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                                                         255.0 * std::rand() / ( RAND_MAX + 1.0 ), 9 );

        Hero other1 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Norbi Entropy" );
        Hero other2 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 3, "Greta Entropy" );
        Hero other4 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Nandi Entropy" );
        Hero other5 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 7, "Matyi Entropy" );

        heroes.push_back ( me );
        heroes.push_back ( other1 );
        heroes.push_back ( other2 );
        heroes.push_back ( other4 );
        heroes.push_back ( other5 );

}]]>    
            </programlisting>
            Paramáterként átadjuk a magasságot és a szélességet. A <function>dispShift</function> 
            alapértelmezett értéke 40, és a <function>heroRectSize</function>-é is.
            AZ első sorban a <function>dispShift</function>-hez hozzáadjuk a 
            <function>heroRectSize</function> másfélszeresét. Ezután pedig 
            random számokat generálunk, és létrehozzuk az öt alapértelmezett "karaktert", ami
            meg fog jelenni a képernyőn. A <function>Hero</function> class
            a <filename>BrainBThread.h</filename>-ban van definiálva. A konstruktorának
            5 paraméterre van szüksége, de ha nem adunk meg, akkor használja az alapértelmezett
            értékeket:
            <programlisting language="c++"><![CDATA[
Hero ( int x=0, int  y=0, int color=0, int agility=1,  std::string name ="Samu Entropy" )]]>
            </programlisting>
            Az <function>me</function>-nek nem adtunk meg nevet, ezért
            ő lesz <function>Samu Entropy</function>, akit majd követni kell az egérrel.
            A létrehozott hősöket pedig a <function>heroes</function> vektorba rakjuk.
            A hősök mozgásáért a <function>move</function> függvény lesz a felelős.
            <programlisting language="c++"><![CDATA[
    void move ( int maxx, int maxy, int env ) {

        int newx = x+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 ) ;
        if ( newx-env > 0 && newx+env < maxx ) {
            x = newx;
        }
        int newy = y+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 );
        if ( newy-env > 0 && newy+env < maxy ) {
            y = newy;
        }]]>
            </programlisting>
            Ezzel új pozíciót adunk meg a hősöknek, annak a függvéynében, hogy
            hol van hozzá képest a másik hős, ezt az <function>env</function>
            változóban tároljuk. Az új pozíció meghatározásában fontos szerepe van
            az agilitásnak is, hiszen az előző x-hez az agilitás random számszorosának és
            az agilitás felének a különbségét adjuk. Ha a kapott szám és a környezet
            különbsége nagyobb,mint nulla, és összegük kisebb, mint a max x érték, akkor
            ez lesz az új x koordinátája a hősnek. Ugyan ezt hajtjuk végre az y
            koordinátával is. 
        </para>
        <para>
            A <function>BrainBThread</function> osztály definíciója a következő:
            <programlisting><![CDATA[
class BrainBThread : public QThread
{
    Q_OBJECT

    
     //Norbi
    cv::Scalar cBg { 247, 223, 208 };
    cv::Scalar cBorderAndText { 47, 8, 4 };
    cv::Scalar cCenter { 170, 18, 1 };
    cv::Scalar cBoxes { 10, 235, 252 };]]>
            </programlisting>
            A fejrészben láthatjuk, hogy a <function>BrainBThread</function>
            osztály az alosztályaa lesz a <function>QThread</function> osztálynak.
            A <function>cv::</function> használatához volt szükség az 
            openCV telepítésére. A <function>Scalar</function> osztály 
            konstruktora 4 paramétert kér, mi ebből csak 3-at adunk meg, 
            a negyediket alapértelmezett értéken hagyjuk. A változók neveiből
            sejthető, hogy jeen esetben RGB kódot tárolunk bennük, ezzel hatátozzuk
            meg a hősök színét.
            <programlisting><![CDATA[
    Heroes heroes;
    int heroRectSize {40};

    cv::Mat prev {3*heroRectSize, 3*heroRectSize, CV_8UC3, cBg };
    int bps;
    long time {0};
    long endTime {10*60*10};
    int delay {100};

    bool paused {true};
    int nofPaused {0};

    std::vector<int> lostBPS;
    std::vector<int> foundBPS;

    int w;
    int h;
    int dispShift {40};]]>
            </programlisting>
            Az első sorban deklaráljuk a <function>heroes</function> vektort.
            Majd adunk a <function>heroRectSize</function> értékét 40-re
            állítjuk, ez lényegében a hösőkt ábrázoló téglalap mérete.
            A <function>cv::Mat</function> osztály segítségével
            több dimenziós tömböt hozunk létre, amiben megadjuk a sorok,
            oszlopok számát, egy típust, és egy <function>Scalar</function>
            vektort. A típussal jelöljük, hogy a <function>Scalar</function>
            vektorban RGB színeket tárolunk. Majd létrehozzuk, a <function>bps</function>
            változót, melyben a pillanatnyi bps értékeket fogjuk tárolni. Megadjuk
            a benchmark idejét, ahogy láthatod, 10 percre van állítva. A <function>lostBPS</function>
            és a <function>foundBPS</function> vektorokban fogjuk tárolni a 
            az elvesztés és a megtalálás pillanatában fennálló bps-t.  
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
