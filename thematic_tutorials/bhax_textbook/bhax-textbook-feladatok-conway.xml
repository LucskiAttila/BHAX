<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Myrmecologist">itt</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Használat előtt</title>
            <para>
                sudo apt-get install qtbase5-dev
            </para>
        </caution>
        <para>
            A program lényegében a hanygák feromonokkal történő
            kommunkiációját szimulálja. A képernyőt cellákra
            osztjuk, és a cellákban lévő hangyák megkeresik azt
            a szomszédjukat, akinek a legerősebb a feromonja, és
            arra lép tovább. A cellák fermonon értékei folyamatosan
            csökkennek, viszont ha valamelyik hangya bele lép az egyikbe, 
            akkor ott megnő a fermomon szint. Ezeket az értékeket mind 
            parancssori argumentumok formájában tudjuk megadni.
        </para>
        <para>
            A <filename>main.cpp</filename>-ben megtalálható futtatási javaslat a következő:
            <programlisting>
./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
            </programlisting>
            A <function>w</function> kapcsolóval állítjuk be, hogy egy cella
            hány oszlopból álljon, vagyis, milyen széles legyen, a 
            <function>m</function>-el pedig a cellák magasságát. Az
            <function>n</function> kapcsoló a hangyák számát állítja be, a 
            <function>t</function>-vel pedig a lépéseik gyakoriságát állítjuk,
            melyet miliszekundumba adunk meg. A <function>p</function>-vel
            a feromonok párolgásának a gyorsaságát állítjuk be, az
            <function>f</function>-el pedig azt, hogyha egy hangya belelép
            egy cellába, akkor mennyivel növeli meg annak a feromonértékét.
            A <function>d</function> kapcsolóval meg tudjuk adni, hogy mi legyen
            a cellák feromonértékének a kezdőértéke. Az <function>a</function>
            és a <function>i</function> kapcsolókkal meg tudjuk adni a maximális
            és a minimális fermonoértékeket. Az <function>s</function>
            kapcsoló azt állítja, hogy a hangyák mennyi feromont hagyjanak a
            szomszédos cellákban. Végezetül pedig lehetőségünk van 
            beállítani azt is, hogy az egyes cellákban maximum hány
            hangya lehessen egyszerre. Természetesen ezeket nem muszáj
            megadni, mivel vannak a programban alapértelmezett értékek a 
            futtatáshoz.
        </para>
        <caution>
            <title>Futtatás</title>
            <para>
                Mindegyik fájlnak egy mappában kell lennie. Majd:
                <programlisting>
qmake myrmecologist.pro
make
./myrmecologist //+ a kapcsolók, ha szeretnéd állítani
                </programlisting>
            </para>
        </caution>
        <para>
            <figure>
                <title>Kapcsolók nélkül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Myrmecologist/alapertelmezett.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Kapcsolókkal</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Myrmecologist/kapcsoloval.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
        <para>
            Most, hogy láttuk, hogyan is működik a program, lássuk magát a forrást.
            Mivel most több fájlból áll a forrás, ezért egy kicsit forradalmibb
            módon próbálom neked demonstrálni a program alapvető felépítését. Ezt
            nevezzük UML osztálydiagramnak. Segítségével könnyebben átláthatod
            a bonyolult programokat.
            <figure>
                <title>UML diagram</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Myrmecologist/uml.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Az ábrán láthatjuk a programunk egyes osztáylait. Azon elemek, melyek előtt
            a "-" jel szerepel, nem érhetők el az osztályon kívül, míg a "+"
            jelesek igen. Tehát ezekkel különböztetjük meg az oszrtályok 
            <function>public</function> és <function>private</function> tagjait. 
            A legkisebb osztály az <function>Ant</function>, melyet a 
            <filename>ant.h</filename> header tartalmazza.
            <programlisting language="c++"><![CDATA[
class Ant
{

public:
    int x;
    int y;
    int dir;

    Ant(int x, int y): x(x), y(y) {
        
        dir = qrand() % 8;
        
    }

};

typedef std::vector<Ant> Ants;]]>
            </programlisting>
            Ebben csak a hangyák pozícióját határozzuk meg az x és az y koordináták
            segítségével, plusz az irányát is itt számoljuk ki, melyet a 
            <function>dir</function> változóban tárolunk.
            Az utolsó sor az ábrán már külön bubrékban szerepel. A
            <function>typedef</function> segítségével az 
            <function>Ant</function> típusú elemkeből álló vektorokra 
            az <function>Ants</function> alias-szal tudunk hivatkozni.
            Tehát:
            <programlisting language="c++">
                Ants elso;
            </programlisting>
            Ebben a kódcsipetben tehát egy <function>Ant</function>
            típusú elemekből álló vektort deklaráltunk.
        </para>
        <para>
            A következő osztályunk az <function>AntWin</function>, melyet
            az <filename>antwin.h</filename> és az 
            <filename>antwin.cpp</filename>-ben találunk. A header fájlban
            vannak az egyes elemek deklarációi, míg a C++ forrás tartalmazza
            azok definícióját. Ez viszonylag gyakori eljárás a C++
            programozásban, mivel így letisztultabb kódot kapunk.
            <programlisting language="c++"><![CDATA[
#include <QMainWindow>
#include <QPainter>
#include <QString>
#include <QCloseEvent>
#include "antthread.h"
#include "ant.h"

class AntWin : public QMainWindow
{
    Q_OBJECT

public:
    AntWin(int width = 100, int height = 75,
           int delay = 120, int numAnts = 100,
           int pheromone = 10, int nbhPheromon = 3,
           int evaporation = 2, int cellDef = 1,
           int min = 2, int max = 50,
           int cellAntMax = 4, QWidget *parent = 0);

    AntThread* antThread;

    void closeEvent ( QCloseEvent *event ) {

        antThread->finish();
        antThread->wait();
        event->accept();
    }

    void keyPressEvent ( QKeyEvent *event )
    {

        if ( event->key() == Qt::Key_P ) {
            antThread->pause();
        } else if ( event->key() == Qt::Key_Q
                    ||  event->key() == Qt::Key_Escape ) {
            close();
        }

    }

    virtual ~AntWin();
    void paintEvent(QPaintEvent*);

private:

    int ***grids;
    int **grid;
    int gridIdx;
    int cellWidth;
    int cellHeight;
    int width;
    int height;
    int max;
    int min;
    Ants* ants;

public slots :
    void step ( const int &);

};]]>
            </programlisting>
            A Qt egyes funkcióinak a használatához nélkülözhetetlen a 
            fenti header-ök csatolása. A <function>QMainWindow</function>
            osztállyal tudjuk megalkotni a programunk ablakját, amiben a
            a hangyaszimuláció kirajzolódik. Kirajzolódik, ezért van szükség
            a <function>QPainter</function> osztályra. A <function>QString</function>
            osztály segítségével tudunk Unicode karakterkódulású sztringeket
            tárolni, a <function>QCloseEvent</function> segítségével pedig
            a program bezárását tudjuk szabályozni paraméterek segítségével.
            Ez a header fájl kapcsolja össze az <function>Ant</function> és
            a <function>AntThread</function> osztáylokat. Összességében elmondható,
            hogy ebben az osztályban történik meg a pogramablaknak a létrehozása,
            itt állítjuk be az egyes paramétereket, amkiet parancssori argumentumok
            segítségével a programnak át tudunk adni. A program futásának
            szüneteltetéséért és bezárásáért is ez az  osztály felelős, itt vannak 
            meghatározva az egyes billentyűkhöz rendelt tevékenységek.
        </para>
        <para>
            Maga az érdemi számítást pedig az <filename>antthread.h</filename>
            és az <filename>antthread.cpp</filename> fájlok tartalmazzák.
            Az előzőhöz hasonlóan itt is csak a headert nézzük meg:
            <programlisting language="c++"><![CDATA[
#include <QThread>
#include "ant.h"

class AntThread : public QThread
{
    Q_OBJECT

public:
    AntThread(Ants * ants, int ***grids, int width, int height,
             int delay, int numAnts, int pheromone, int nbrPheromone, 
             int evaporation, int min, int max, int cellAntMax);
    
    ~AntThread();
    
    void run();
    void finish()
    {
        running = false;
    }

    void pause()
    {
        paused = !paused;
    }

    bool isRunnung()
    {
        return running;
    }

private:
    bool running {true};
    bool paused {false};
    Ants* ants;
    int** numAntsinCells;
    int min, max;
    int cellAntMax;
    int pheromone;
    int evaporation;
    int nbrPheromone;
    int ***grids;
    int width;
    int height;
    int gridIdx;
    int delay;
    
    void timeDevel();

    int newDir(int sor, int oszlop, int vsor, int voszlop);
    void detDirs(int irany, int& ifrom, int& ito, int& jfrom, int& jto );
    int moveAnts(int **grid, int row, int col, int& retrow, int& retcol, int);
    double sumNbhs(int **grid, int row, int col, int);
    void setPheromone(int **grid, int row, int col);

signals:
    void step ( const int &);

};]]>
            </programlisting>
            A <function>Qthread</function> osztályra azért van szükség, hogy
            kezelni tudjuk a program egyes szálait. Az  <function>AntThread</function>
            osztély konstruktora megkapja azokat az értékeket, amiket az
            <function>AntWin</function> osztályban megkapott a program, majd 
            elkezdi "mozgatni" a hangyákat. Kiszámolja az irányukat a 
            feromonszintek és a cellatelítettség alapján, állítja az 
            egyes cellák feromonértékeit, és megadja az <function>AntWin</function>
            osztálynak, hogy mely cellákat kell átszínezni.
        </para>
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/Siklokilovo/Java">itt</link>               
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                A feladat megoldásában tutorként részt vett Petrus József Tamás.
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
		<para>
			Melvin Conway 1970-ben alkotta meg saját sejtautomatáját.
			A sejtautomaták lényege, hogy megadunk néhány feltételt
			az életben maradásra, a születésre, és a halálozásra, majd
			figyeljük, hogy az általunk "teremtett" lények, hogyan
			"élnek". Conway 3 egyszerű szabályt adott meg,
			és mind a mai napig ez a legnépszerűbb sejtautomata.
		</para>
		<para>
			A szabályok a következők:
			<programlisting>
1. szabály: Egy sejt csak akkor marad életbe, ha 2 vagy 3 szomszédja van.
2. szabály: Ha egy sejtnek 3-nál több szomszédja van, túlnépesedés miatt
			meghal. Ha pedig 2-nél kevesebb a szomszédai száma, akkor
			pedig az elszigetelődés miatt hal meg.
3. szabály: Egy sejt megszületik, ha az üres cellának 3 élő sejt
			található a szomszédos cellákban.
			</programlisting>
			Ezen szabályok megadásával elképesztő animációkat kapunk,
			de mi most kifejezetten egyre, a siklókilövőre koncentrálunk.
		</para>
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/Siklokilovo/QT">itt</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/fupn26/bhax/tree/master/attention_raising/Source/BrainB">itt</link>               
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Telepíteni kell a következőket:
                <function>sudo apt-get install opencv-data</function> és a
                <function>sudo apt-get install libopencv-dev</function>
                csomagokat a program helyes működéséhez.
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>Használata előtt</title>
            <para>
                sudo apt-get install libqt4-dev
                sudo apt-get install opencv-data
                sudo apt-get install libopencv-dev 
            </para>
        </caution>
        <para>
            A BrainB Benchmark feladata az esport tehetségek felkutatása lenne,
            úgy, hogy feltérképezi az agy kognitív képességeit, és az 
            elért pontszámok alapján össze lehet hasonlítani az egyes 
            egyéneket. Maga a benchmark a "karakterelvesztést" teszteli,
            vagyis ha a játékban elveszítjük a karakterünket, mennyi ideig
            tart megtalálnunk, és ha megtaláltuk, mennyi ideig tart elveszítenünk.
            Ideális esetben rövidebb ideig tart megtalálnunk, mint elveszteni.
            A program azt is figyeli, hogy az egyes karakterelvesztésekhez
            milyen bit/sec képernyőváltások tartoznak.
            <figure>
                <title>Program</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/BrainB/program.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A program így néz ki, a feladat annyi, hogy a kurzort rajta kell tartani a Samu Entropyn, minnél tovább tartod
            rajta, annál több New Entropy jelenik meg, ezzel nehezítve a dolgod. Ha elveszted, akkor a szaporodás lelassul, hogy könyebben
            megtalálhasd a karakteredet. 
            A benchmark összesen 10 percig tart, és 
            minél komplikáltabb lesz a kép a végén, annál jobb vagy.
            <figure>
                <title>Eredmény</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/BrainB/eredmeny.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            A végén pedig megkapod ezt a fájlt, ami tartalmazza az elért eredményt.
            Hogy te is le tudd futattni, fontos, hogy minden fájl egy mappában legyen, majd
            pedig a következő paracsokat kell kiadni:
            <function>qmake BrainB.pro</function>, <function>make</function>,
            <function>./BrainB</function>. Ha nem szeretnéd az egész
            benchmarkot végig várni, Esc-el ki tudsz lépni bármikor, és
            az addig elért eredményedről is kapsz pontos leírást.
        </para>
        <para>
            A <filename>main.cpp</filename> nézzük át elsőnek.
            <programlisting language="c++"><![CDATA[
#include <QApplication>
#include <QTextStream>
#include <QtWidgets>
#include "BrainBWin.h"

int main ( int argc, char **argv )
{
        QApplication app ( argc, argv );

        QTextStream qout ( stdout );
        qout.setCodec ( "UTF-8" );]]>
            </programlisting>
            Mivel a program a Qt grafikus felületét használja, ezért a
            hozzzá tartozó osztályokat is szükséges hozzáfűzni a 
            forráshoz. Természetesen a <filename>BrainBWin.h</filename>-ra
            is szükségünk van, mert ezzel biztosítjuk, hogy a main-ből
            el tudjuk éerni a többi fájlt. A <function>main</function>
            a már megszokott formában köszön vissza, viszont első
            lépésként deklarálunk egy <function>QApplication</function>
            típusú objektumot, melynek paramétereként adjuk
            át a parancssori argumentumok számát, és tömbüket. A <function>qout</function>
            segítségével pedig a standard kimenetre írunk. Ez is egy objektum, amely
            QTextStream típusú. A <function>qout</function> objektumnak
            része a <function>setCodec</function> függvény, mellyel a
            karakterkódolást tudjuk beállítani.
            <programlisting language="c++"><![CDATA[
                qout << "\n" << BrainBWin::appName << QString::fromUtf8 ( " Copyright (C) 2017, 2018 Norbert Bátfai" ) << endl;]]>
            </programlisting>
            A <function>std::cout</function>-hoz hasonlóan, a <function>qout</function>-ba
            is beleshifteljük a kimenetet. A <function>BrainBWin</function> osztályról majd
            később beszélünk, de itt az osztály <function>appName</function> változóját
            érjük el és írjuk ki. A <function>QString::fromUtf8</function> függvény
            segítségével pedig UTF-8-as stringet írunk ki a parancssorba.
            <programlisting language="c++"><![CDATA[
                QRect rect = QApplication::desktop()->availableGeometry();]]>
            </programlisting>
            A <function>QRect</function> osztály segítségével egy téglalapot
            tudunk rajzolni a síkra, melynek méretét a kijelző méretével tesszük
            egyenlővé. A kijelző méretét úgy kapjuk meg, hogy a 
            <function>desktop()</function> függvéy visszaadja magát az asztalt,
            az <function>availableGeometry()</function> pedig annak a méretét.
            <programlisting language="c++">
                BrainBWin brainBWin ( rect.width(), rect.height() );
            </programlisting>
            Létrehozzuk a <function>BrainBWin</function> objektumunkat, melynek
            átadjuk a képernyő méretét. Ekkor meghívódik a <function>BrainBWin</function>
            konstruktora, amely a következőképpen néz ki:
            <programlisting language = "c++"><![CDATA[
BrainBWin::BrainBWin ( int w, int h, QWidget *parent ) : QMainWindow ( parent )
{


        statDir = appName + " " + appVersion + " - " + QDate::currentDate().toString() + QString::number ( QDateTime::currentMSecsSinceEpoch() );

        brainBThread = new BrainBThread ( w, h - yshift );
        brainBThread->start();

        connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

}]]>
            </programlisting>
            A <function>QMainWindow</function> osztály segítségével hozzuk létre a fő ablkát a 
            programnak, és ezen belül készítjükm el a <function>BrainBWin</function> ablakot. 
            A hierarchikus sorrendet úgy érjuk el, hogy a <function>BrainBWin</function>
            konstruktora meghívja a <function>QMainWindow</function> konstruktorát, és jellezzük
            neki, hogy ő a szülő. A <function>QString</function> típusú <function>statDir</function>
            változóvban tároljuk a későbiiekben létrehozandó mappa nevét. Mjd a
            <filename>BrainBWin.h</filename>-ban deklarált <function>BrainBThread</function>
            objektumra mutató muutatót ráállítjuk egy újonan lefoglalt tárterületre. Ehhez
            meghívódik a <function>BrainBTread</function> konstruktora.
            <programlisting language="c++"><![CDATA[
BrainBThread::BrainBThread ( int w, int h )
{

        dispShift = heroRectSize+heroRectSize/2;

        this->w = w - 3 * heroRectSize;
        this->h = h - 3 * heroRectSize;

        std::srand ( std::time ( 0 ) );

        Hero me ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                  this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                                                         255.0 * std::rand() / ( RAND_MAX + 1.0 ), 9 );

        Hero other1 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Norbi Entropy" );
        Hero other2 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 3, "Greta Entropy" );
        Hero other4 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Nandi Entropy" );
        Hero other5 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 7, "Matyi Entropy" );

        heroes.push_back ( me );
        heroes.push_back ( other1 );
        heroes.push_back ( other2 );
        heroes.push_back ( other4 );
        heroes.push_back ( other5 );

}]]>    
            </programlisting>
            Paramáterként átadjuk a magasságot és a szélességet. A <function>dispShift</function> 
            alapértelmezett értéke 40, és a <function>heroRectSize</function>-é is.
            AZ első sorban a <function>dispShift</function>-hez hozzáadjuk a 
            <function>heroRectSize</function> másfélszeresét. Ezután pedig 
            random számokat generálunk, és létrehozzuk az öt alapértelmezett "karaktert", ami
            meg fog jelenni a képernyőn. A <function>Hero</function> class
            a <filename>BrainBThread.h</filename>-ban van definiálva. A konstruktorának
            5 paraméterre van szüksége, de ha nem adunk meg, akkor használja az alapértelmezett
            értékeket:
            <programlisting language="c++"><![CDATA[
Hero ( int x=0, int  y=0, int color=0, int agility=1,  std::string name ="Samu Entropy" )]]>
            </programlisting>
            Az <function>me</function>-nek nem adtunk meg nevet, ezért
            ő lesz <function>Samu Entropy</function>, akit majd követni kell az egérrel.
            A létrehozott hősöket pedig a <function>heroes</function> vektorba rakjuk.
            A hősök mozgásáért a <function>move</function> függvény lesz a felelős.
            <programlisting language="c++"><![CDATA[
    void move ( int maxx, int maxy, int env ) {

        int newx = x+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 ) ;
        if ( newx-env > 0 && newx+env < maxx ) {
            x = newx;
        }
        int newy = y+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 );
        if ( newy-env > 0 && newy+env < maxy ) {
            y = newy;
        }]]>
            </programlisting>
            Ezzel új pozíciót adunk meg a hősöknek, annak a függvéynében, hogy
            hol van hozzá képest a másik hős, ezt az <function>env</function>
            változóban tároljuk. Az új pozíció meghatározásában fontos szerepe van
            az agilitásnak is, hiszen az előző x-hez az agilitás random számszorosának és
            az agilitás felének a különbségét adjuk. Ha a kapott szám és a környezet
            különbsége nagyobb,mint nulla, és összegük kisebb, mint a max x érték, akkor
            ez lesz az új x koordinátája a hősnek. Ugyan ezt hajtjuk végre az y
            koordinátával is. 
        </para>
        <para>
            A <function>BrainBThread</function> osztály definíciója a következő:
            <programlisting><![CDATA[
class BrainBThread : public QThread
{
    Q_OBJECT

    
     //Norbi
    cv::Scalar cBg { 247, 223, 208 };
    cv::Scalar cBorderAndText { 47, 8, 4 };
    cv::Scalar cCenter { 170, 18, 1 };
    cv::Scalar cBoxes { 10, 235, 252 };]]>
            </programlisting>
            A fejrészben láthatjuk, hogy a <function>BrainBThread</function>
            osztály az alosztályaa lesz a <function>QThread</function> osztálynak.
            A <function>cv::</function> használatához volt szükség az 
            openCV telepítésére. A <function>Scalar</function> osztály 
            konstruktora 4 paramétert kér, mi ebből csak 3-at adunk meg, 
            a negyediket alapértelmezett értéken hagyjuk. A változók neveiből
            sejthető, hogy jeen esetben RGB kódot tárolunk bennük, ezzel hatátozzuk
            meg a hősök színét.
            <programlisting><![CDATA[
    Heroes heroes;
    int heroRectSize {40};

    cv::Mat prev {3*heroRectSize, 3*heroRectSize, CV_8UC3, cBg };
    int bps;
    long time {0};
    long endTime {10*60*10};
    int delay {100};

    bool paused {true};
    int nofPaused {0};

    std::vector<int> lostBPS;
    std::vector<int> foundBPS;

    int w;
    int h;
    int dispShift {40};]]>
            </programlisting>
            Az első sorban deklaráljuk a <function>heroes</function> vektort.
            Majd adunk a <function>heroRectSize</function> értékét 40-re
            állítjuk, ez lényegében a hösőkt ábrázoló téglalap mérete.
            A <function>cv::Mat</function> osztály segítségével
            több dimenziós tömböt hozunk létre, amiben megadjuk a sorok,
            oszlopok számát, egy típust, és egy <function>Scalar</function>
            vektort. A típussal jelöljük, hogy a <function>Scalar</function>
            vektorban RGB színeket tárolunk. Majd létrehozzuk, a <function>bps</function>
            változót, melyben a pillanatnyi bps értékeket fogjuk tárolni. Megadjuk
            a benchmark idejét, ahogy láthatod, 10 percre van állítva. A <function>lostBPS</function>
            és a <function>foundBPS</function> vektorokban fogjuk tárolni a 
            az elvesztés és a megtalálás pillanatában fennálló bps-t.  
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
